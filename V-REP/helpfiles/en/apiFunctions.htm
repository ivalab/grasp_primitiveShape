<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>API Functions</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>

<h1><a href="apiOverview.htm">Regular API</a> functions</h1>
<h3 class=subsectionBar><a name="simAddBanner" id="simAddBanner"></a>simAddBanner / sim.addBanner </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds a banner to the scene. Banners  created in a <a href="simulationScripts.htm">simulation script</a> will be automatically removed at simulation end. See also <a href="#simRemoveBanner">sim.removeBanner</a> and <a href="#simAddDrawingObject">sim.addDrawingObject</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddBanner(const simChar* label,simFloat size,simInt options,const simFloat* positionAndEulerAngles,simInt parentObjectHandle,const simFloat* labelColors,const simFloat* backgroundColors)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>label</strong>: the label to display on the banner</div>
<div><strong>size</strong>: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this argument represents the banner height in pixels instead<br>
</div>
<div><strong>options</strong>: a combination of <a href="apiConstants.htm#banners">banner options</a></div>
<div><strong>positionAndEulerAngles</strong>: 6 values representing the banner's position and orientation in space. Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the parent object's position and orientation. This argument can be NULL, in which case the identity transformation is assumed<br>
</div>
<div><strong>parentObjectHandle</strong>: the handle of a scene object you wish to attach the banner to, or -1 if the banner should be independent.<br>
</div>
<div><strong>labelColors</strong>: 12 values representing the RGB values (0-1) for the 3 color components of the text (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in which case a black color will be used<br>
</div>
<div><strong>backgroundColors</strong>: 12 values representing the RGB values (0-1) for the 3 color components of the text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in which case a white color will be used<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the banner if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number bannerID=sim.addBanner(string label,number size,number options,table_6 positionAndEulerAngles=nil,number parentObjectHandle=nil,table_12 labelColors=nil,table_12 backgroundColors=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddDrawingObject" id="simAddDrawingObject"></a>simAddDrawingObject / sim.addDrawingObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a drawing object that will be displayed in the scene. Drawing objects are containers that hold several items of a given type. This can be used for several different applications (simulation of paint, simulation of welding seam, display of 3D objects, etc.). Drawing objects created in a <a href="simulationScripts.htm">simulation script</a> will be automatically removed at simulation end. See also <a href="#simAddDrawingObjectItem">sim.addDrawingObjectItem</a>, <a href="#simRemoveDrawingObject">sim.removeDrawingObject</a> and the <a href="pointClouds.htm">point cloud functionality</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddDrawingObject(simInt objectType,simFloat size,simFloat duplicateTolerance,simInt parentObjectHandle,simInt maxItemCount,const simFloat* ambient_diffuse,const simFloat* setToNULL,const simFloat* specular,const simFloat* emission)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectType</strong>: a <a href="apiConstants.htm#customDrawingObjects">drawing object type combined with attributes</a></div>
<div><strong>size</strong>: size of the item (width of lines or size of points are in pixels, other sizes are in meters</div>
<div><strong>duplicateTolerance</strong>: if different from 0.0, then a call to <a href="#simAddDrawingObjectItem">simAddDrawingObjectItem</a> will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.<br>
</div>
<div><strong>parentObjectHandle</strong>: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)<br>
</div>
<div><strong>maxItemCount</strong>: maximum number of items this object can hold.</div>
<div><strong>ambient_diffuse</strong>: default ambient/diffuse color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>setToNULL</strong>: not used, set to NULL</div>
<div><strong>specular</strong>: default specular color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>emission</strong>: default emissive color (pointer to 3 rgb values). Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the drawing object if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number drawingObjectHandle=sim.addDrawingObject(number objectType,number size,number duplicateTolerance,number parentObjectHandle,number maxItemCount,table_3 ambient_diffuse=nil,nil,table_3 specular=nil,table_3 emission=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAddDrawingObject_points">simxAddDrawingObject_points</a>, <a href="b0RemoteApi-cpp.htm#simxAddDrawingObject_segments">simxAddDrawingObject_segments</a>, <a href="b0RemoteApi-cpp.htm#simxAddDrawingObject_triangles">simxAddDrawingObject_triangles</a>, <a href="b0RemoteApi-cpp.htm#simxAddDrawingObject_spheres">simxAddDrawingObject_spheres</a>, <a href="b0RemoteApi-cpp.htm#simxAddDrawingObject_cubes">simxAddDrawingObject_cubes</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddDrawingObjectItem" id="simAddDrawingObjectItem"></a>simAddDrawingObjectItem / sim.addDrawingObjectItem </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds an item (or clears all items) to a previously inserted drawing object. See also <a href="#simAddDrawingObject">sim.addDrawingObject</a> and <a href="#simRemoveDrawingObject">sim.removeDrawingObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddDrawingObjectItem(simInt objectHandle,const simFloat* itemData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object</div>
<div><strong>itemData</strong>: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, and if the item is a triangle item, 9 values are required. Additional values (auxiliary values) might be required depending on the drawing object attributes. See the <a href="apiConstants.htm#customDrawingObjects">drawing object types and attributes</a> for more information. If NULL the drawing object is emptied of all its items<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. If the point was added, then the return value is &gt;0, if it was not added (e.g. drawing object is saturated or the item was merged with an existing item), then the return value will be 0.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addDrawingObjectItem(number drawingObjectHandle,table itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddForce" id="simAddForce"></a>simAddForce / sim.addForce </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a non-central force to a shape object that is dynamically enabled. Added forces are cumulative, and are reset to zero after <a href="#simHandleDynamics">sim.handleDynamics</a> was called (or by using the following flag: sim.handleflag_resetforcetorque). See also <a href="#simAddForceAndTorque">sim.addForceAndTorque</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddForce (simInt shapeHandle,const simFloat* position,const simFloat* force)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforcetorque in order to clear the accumulated force and torque.</div>
<div><strong>position</strong>: pointer to 3 values that represent the relative position where the force should be applied.</div>
<div><strong>force</strong>: pointer to 3 values that represent the force (in relative coordinates) to add.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addForce(number shapeHandle,table_3 position,table_3 force)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddForceAndTorque" id="simAddForceAndTorque"></a>simAddForceAndTorque / sim.addForceAndTorque </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a force and/or torque to a shape object that is dynamically enabled. Forces are applied at the center of mass. Added forces and torques are cumulative, and are reset to zero after <a href="#simHandleDynamics">sim.handleDynamics</a> was called (or by using the following flags: sim.handleflag_resetforce and/or sim.handleflag_resettorque). See also <a href="#simAddForce">sim.addForce</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddForceAndTorque(simInt shapeHandle,const simFloat* force,const simFloat* torque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.</div>
<div><strong>force</strong>: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.</div>
<div><strong>torque</strong>: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addForceAndTorque(number shapeHandle,table_3 force,table_3 torque)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddGhost" id="simAddGhost"></a>simAddGhost / sim.addGhost </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a light copy of a shape in its current configuration, as a ghost object. Ghosts have a visual start and end time, and are automatically played back during simulation (i.e. visualized), but they do not influence a simulation otherwise. Ghost are a convenient way to visually compare several simulation runs. Ghosts can be modified or cleared with <a href="#simModifyGhost">sim.modifyGhost</a>. Ghosts can also be cleared in the <a href="environmentPropertiesDialog.htm">environment properties</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddGhost(simInt ghostGroup,simInt objectHandle,simInt options,simFloat startTime,simFloat endTime,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ghostGroup</strong>: an identifier that allows grouping several ghosts</div>
<div><strong>objectHandle</strong>: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab><strong>bit0 (1)</strong> set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghosts</div>
<div class=tab><strong>bit1 (2)</strong> set=the provided start- and end-times will be played-back in real-time</div>
<div class=tab><strong>bit2 (4)</strong> set=preserve the original colors</div>
<div class=tab><strong>bit3 (8)</strong> set=force invisible objects to appear too</div>
<div class=tab><strong>bit4 (16)</strong> set=create an invisible ghost</div>
<div class=tab><strong>bit5 (32)</strong> set=backface culling for the ghost (only when using custom colors)</div>
<div><strong>startTime</strong>: the time at which the ghost should appear.</div>
<div><strong>endTime</strong>: the time at which the ghost should disappear.</div>
<div><strong>color</strong>: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise a ghost ID. Several ghosts might share the same  ID (e.g. when a ghost was added with bit0 of <strong>options</strong> set)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number ghostId=sim.addGhost(number ghostGroup,number objectHandle,number options,number startTime,number endTime,table_12 color=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddModuleMenuEntry" id="simAddModuleMenuEntry"></a>simAddModuleMenuEntry</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Attaches a menu entry in the simulator's module menu. This is useful if you created an plugin that can display a custom dialog in V-REP for specific settings/operations. If the user selects an item in the simulator's module menu, a <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_menuitemselected</a> message is generated. See also the <a href="plugins.htm">plugin v_repMessage entry point</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddModuleMenuEntry(const simChar* entryLabel,simInt itemCount,simInt* itemHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entryLabel</strong>: entry label. The same label can be used in consecutive calls (also from different plugins), in which case a sub-menu will group all items under the same label. If you do not plan adding several items, use &quot;&quot; for entryLabel.<br>
</div>
<div><strong>itemCount</strong>: number of items, including separators. If entryLabel is &quot;&quot;, then itemCount should be 1<br>
</div>
<div><strong>itemHandles</strong>: pointer to the item handles. Make sure the pointer can hold &quot;itemCount&quot; number of elements. Use <a href="#simSetModuleMenuItemState">simSetModuleMenuItemState</a> to set-up the individual items.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddObjectToCollection" id="simAddObjectToCollection"></a>simAddObjectToCollection / sim.addObjectToCollection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds an object (or a group of objects) to a <a href="collections.htm">collection</a>. See also <a href="#simEmptyCollection">sim.emptyCollection</a>, <a href="#simRemoveCollection">sim.removeCollection</a>, <a href="#simGetCollectionHandle">sim.getCollectionHandle</a>, <a href="#simGetObjectHandle">sim.getObjectHandle</a>, <a href="#simGetCollectionObjects">sim.getCollectionObjects</a> and <a href="#simCreateCollection">sim.createCollection</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddObjectToCollection(simInt collectionHandle,simInt objectHandle,simInt what,simInt options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: the handle of a collection.</div>
<div><strong>objectHandle</strong>: the handle of an object.</div>
<div><strong>what</strong>: the type of object (or group of objects) to add. Following are allowed values: <em>sim_handle_single</em> (for a single object), <em>sim_handle_all</em> (for all objects in the scene), <em>sim_handle_tree</em> (for a tree of objects), or <em>sim_handle_chain</em> (for a chain of objects (i.e. an inverted tree)).</div>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.</div>
<div class=tab>bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addObjectToCollection(number collectionHandle,number objectHandle,number what,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddObjectToSelection" id="simAddObjectToSelection"></a>simAddObjectToSelection / sim.addObjectToSelection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds an object to the selection. See also <a href="#simRemoveObjectFromSelection">sim.removeObjectFromSelection</a> and <a href="#simGetObjectSelection">sim.getObjectSelection</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddObjectToSelection(simInt what,simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>what</strong>: indicates what we want to add. Valid values are sim_handle_single (adds just one object), sim_handle_all (adds all objects in the scene), sim_handle_tree (adds the tree with base objectHandle (inclusive)) and sim_handle_chain (adds the chain with tip objectHandle (inclusive))<br>
</div>
<div><strong>objectHandle</strong>: handle of an object. Doesn't have a meaning if &quot;what&quot; is sim_handle_all</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>There are two versions of this function:</div>
<div>(1) number result=sim.addObjectToSelection(number what,number objectHandle)</div>
<div>(2) number result=sim.addObjectToSelection(table objectHandles)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) Same as C-function. The second argument can be omitted if &quot;what&quot; is sim.handle_all</div>
<div>(2) <strong>objectHandles</strong>: table of object handles. Can be nil</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectSelection">simxSetObjectSelection</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectSelection">simxSetObjectSelection</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddParticleObject" id="simAddParticleObject"></a>simAddParticleObject / sim.addParticleObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a particle object that will be simulated and displayed in the scene. Particle objects are containers that hold several items (particles) of a given type. This can be used for several different applications (e.g. simulation of air/water jets) See also <a href="#simAddParticleObjectItem">sim.addParticleObjectItem</a> and <a href="#simRemoveParticleObject">sim.removeParticleObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddParticleObject(simInt objectType,simFloat size,simFloat density,const simVoid* parameters,simFloat lifeTime,simInt maxItemCount,const simFloat* ambient_diffuse,const simFloat* setToNULL,const simFloat* specular,const simFloat* emission)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectType</strong>: a <a href="apiConstants.htm#particleObjects">particle object type combined with attributes</a></div>
<div><strong>size</strong>: diameter of the particles (spheres)</div>
<div><strong>density</strong>: density of the particles</div>
<div><strong>parameters</strong>: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:
</div>
<div class=tab>0: Bullet friction coefficient (default: 0.0)</div>
<div class=tab>1: Bullet restitution coefficient (default: 0.0)</div>
<div class=tab>2: ODE friction coefficient (default: 0.0)</div>
<div class=tab>3: ODE soft ERP value (default: 0.2)</div>
<div class=tab>4: ODE soft CFM values (default: 0.0)</div>
<div class=tab>5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</div>
<div class=tab>6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</div>
<div class=tab>7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</div>
<div class=tab>8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</div>
<div class=tab>9: Vortex friction (default: 0.0)</div>
<div class=tab>10: Vortex restitution (default: 0.0)</div>
<div class=tab>11: Vortex restitution threshold (default: 0.001)</div>
<div class=tab>12: Vortex compliance (default: 0.0)</div>
<div class=tab>13: Vortex damping (default: 0.0)</div>
<div class=tab>14: Vortex adhesive force (default: 0.0)</div>
<div class=tab>15: Newton static friction (default: 0.0)</div>
<div class=tab>16: Newton kinetic friction (default: 0.0)</div>
<div class=tab>17: Newton restitution (default: 0.0)</div>
<div class=tab>If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5<br>
</div>
<div><strong>lifeTime</strong>: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.</div>
<div><strong>maxItemCount</strong>: the maximum number of particles that this object can hold</div>
<div><strong>ambient_diffuse</strong>: default ambient/diffuse color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>setToNULL</strong>: not used, set to NULL</div>
<div><strong>specular</strong>: default specular color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>emission</strong>: default emissive color (pointer to 3 rgb values). Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the particle object if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number particleObjectHandle=sim.addParticleObject(number objectType,number size,number density,table parameters,number lifeTime,number maxItemCount,table_3 ambient_diffuse=nil,nil,table_3 specular=nil,table_3 emission=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddParticleObjectItem" id="simAddParticleObjectItem"></a>simAddParticleObjectItem / sim.addParticleObjectItem </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds an item (or clears all items) to a previously inserted particle object. See also <a href="#simAddParticleObject">sim.addParticleObject</a> and <a href="#simRemoveParticleObject">sim.removeParticleObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddParticleObjectItem(simInt objectHandle,const simFloat* itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added particle object</div>
<div><strong>itemData</strong>: data relative to an item. All items (particles) require at least 6 values: p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the <a href="apiConstants.htm#particleObjects">particle object type combined with attributes</a> for more information. If NULL the particle object is emptied of all its items<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addParticleObjectItem(number particleObjectHandle,table itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddScript" id="simAddScript"></a>simAddScript / sim.addScript </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts a new script. Use with care when simulation is running. See also <a href="#simAssociateScriptWithObject">sim.associateScriptWithObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddScript(simInt scriptType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptType</strong>: <a href="apiConstants.htm#scriptTypes">type of the script</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the new script, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=sim.addScript(number scriptType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAddStatusbarMessage" id="simAddStatusbarMessage"></a>simAddStatusbarMessage / sim.addStatusbarMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds a message to the status bar. See also <a href="#simAuxiliaryConsoleOpen">sim.auxiliaryConsoleOpen</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddStatusbarMessage(const simChar* message)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>message</strong>: message. Will clear the status bar if message is NULL. If message has an &quot;@html&quot; suffix, then the statusbar will correctly interpret html font color tags, e.g.:</div>
<div>&lt;font color=&quot;#F00&quot;&gt;Hello&lt;/font&gt; World!@html</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.addStatusbarMessage(string message)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAddStatusbarMessage">simxAddStatusbarMessage</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxAddStatusbarMessage">simxAddStatusbarMessage</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAdjustRealTimeTimer" id="simAdjustRealTimeTimer"></a>simAdjustRealTimeTimer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adjusts the real time timer of a simulation. This allows correcting for effects that might appear if for a reason or another the <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> cannot be called for some time (for instance during a resize action of the simulator window (the main thread is captured in a modal-type message loop)).</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdjustRealTimeTimer(simInt instanceIndex,simFloat deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>instanceIndex</strong>: no use anymore. set to 0.<br>
</div>
<div><strong>deltaTime</strong>: time correction value in seconds</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAdjustView" id="simAdjustView"></a>simAdjustView / sim.adjustView </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adjusts parameters of a view. See also the <a href="#simFloatingViewAdd">sim.floatingViewAdd</a> and <a href="#simCameraFitToView">sim.cameraFitToView</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdjustView(simInt viewHandleOrIndex,simInt associatedViewableObjectHandle,simInt options,const simChar* viewLabel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view.</div>
<div><strong>associatedViewableObjectHandle</strong>: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptied<br>
</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab><strong>bit0-bit3</strong>=the 3D display mode (0=solid rendering, 1=wireframe rendering)<br>
</div>
<div class=tab><strong>bit4 (16)</strong> set=orthogonal projection (otherwise perspective projection)<br>
</div>
<div class=tab><strong>bit5 (32)</strong> set=x/y graph display (otherwise time-graph display)</div>
<div class=tab><strong>bit6 (64)</strong> set=floating view is removed at simulation end</div>
<div class=tab><strong>bit7 (128)</strong> set=floating view is ignored during a scene save operation</div>
<div class=tab><strong>bit8 (256)</strong> set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.</div>
<div class=tab><strong>bit9 (512)</strong> set=the view is not modified. The return value of the function represents the object associated with the view.</div>
<div class=tab><strong>bit10 (1024)</strong> set=x/y graph has x view size proportional to y view size.</div>
<div><strong>viewLabel</strong>: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A value &gt;0 in case of success</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.adjustView(number viewHandleOrIndex,number associatedViewableObjectHandle,number options,string viewLabel=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAdvanceSimulationByOneStep" id="simAdvanceSimulationByOneStep"></a>simAdvanceSimulationByOneStep</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Advances the simulation time by one time step. Call this function only if the simulation is advancing (see <a href="#simGetSimulationState">sim.getSimulationState</a>) and after having called <a href="#simHandleMainScript">simHandleMainScript</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdvanceSimulationByOneStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAnnounceSceneContentChange" id="simAnnounceSceneContentChange"></a>simAnnounceSceneContentChange / sim.announceSceneContentChange </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Announces a change in the scene. This is required for the undo/redo function to operate properly when performing changes via the API. Only call this function directly after a change was made through a dialog element (e.g. a checkbox was checked/unchecked) and that change was reported to the scene (e.g. with <a href="#simWriteCustomDataBlock">sim.writeCustomDataBlock</a>). What this call will do is following: the whole scene will be serialized (saved) to memory as a &quot;scene image&quot; and compared to a previously memorized &quot;scene image&quot;. If both images are same, then the last image is discarded, otherwise only the changes between the two images are memorized. A call to this function has no effect (and doesn't generate any error) when called during simulation or when in edit mode.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAnnounceSceneContentChange()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if nothing was memorized, or 1 if changes were memorized.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.announceSceneContentChange()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simApplyMilling" id="simApplyMilling"></a>simApplyMilling / sim.applyMilling </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies changes made during milling operations to a cuttable object (e.g. a shape). This requires some calculation time. Once changes were applied, they cannot be reset anymore. If the milling operation milled away the whole object, then the object is removed from the scene. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also <a href="#simResetMilling">sim.resetMilling</a>, <a href="#simHandleMill">sim.handleMill</a> and <a href="#simResetMill">sim.resetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simApplyMilling(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the cut object or sim_handle_all to apply changes to all cut objects. <br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if operation was successful but the object was removed from the scene (because entirely cut away) (only available when sim_handle_all is not specified), or 1 if operation was successful and the object still exists in the scene.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.applyMilling(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simApplyTexture" id="simApplyTexture"></a>simApplyTexture</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies a texture via texture coordinates to a shape. See also <a href="#simSetShapeTexture">simSetShapeTexture</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simApplyTexture(simInt shapeHandle,const simFloat* textureCoordinates,simInt textCoordSize,const simUChar* texture,const simInt* textureResolution,simInt options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: The handle of the shape. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>textureCoordinates</strong>: The UV texture coordinates. For each of the shape's triangle, there should be exactly 3 UV texture coordinate pairs</div>
<div><strong>textCoordSize</strong>: The size of the textureCoordinate array</div>
<div><strong>texture</strong>: The RGB or RGBA texture</div>
<div><strong>textureResolution</strong>: The X/Y resolution of the texture</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0: if set (1), then adjacent texture pixels are not interpolated</div>
<div class=tab>bit1: if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions)</div>
<div class=tab>bit2: unused, keep unset</div>
<div class=tab>bit3: unused, keep unset</div>
<div class=tab>bit4: if set (16), then the texture is RGBA, otherwise it is RGB</div>
<div class=tab>bit5: if set (32), then the texture is horizontally flipped</div>
<div class=tab>bit6: if set (64), then the texture is vertically flipped</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The ID of the texture, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAssociateScriptWithObject" id="simAssociateScriptWithObject"></a>simAssociateScriptWithObject / sim.associateScriptWithObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the associated object of a child script. Use with care when simulation is running. See also <a href="#simGetObjectAssociatedWithScript">sim.getObjectAssociatedWithScript</a>, <a href="#simAddScript">sim.addScript</a> and <a href="#simSetScriptText">sim.setScriptText</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAssociateScriptWithObject(simInt scriptHandle,simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the child script</div>
<div><strong>objectHandle</strong>: handle of the associated object, or -1 to remove the association</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.associateScriptWithObject(number scriptHandle,number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAuxiliaryConsoleClose" id="simAuxiliaryConsoleClose"></a>simAuxiliaryConsoleClose / sim.auxiliaryConsoleClose</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">sim.auxiliaryConsoleOpen</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleClose(simInt consoleHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen command<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window was closed.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.auxiliaryConsoleClose(number consoleHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAuxiliaryConsoleClose">simxAuxiliaryConsoleClose</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleClose">simxAuxiliaryConsoleClose</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAuxiliaryConsoleOpen" id="simAuxiliaryConsoleOpen"></a>simAuxiliaryConsoleOpen / sim.auxiliaryConsoleOpen</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens an auxiliary console window for text display. This console window is different from the application main console window. Console window handles are shared across all simulator scenes. See also <a href="#simAuxiliaryConsolePrint">sim.auxiliaryConsolePrint</a>, <a href="#simAuxiliaryConsoleClose">sim.auxiliaryConsoleClose</a> and <a href="#simAddStatusbarMessage">sim.addStatusbarMessage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleOpen(const simChar* title,simInt maxLines,simInt mode,const simInt* position,const simInt* size,const simFloat* textColor,const simFloat* backgroundColor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>title</strong>: the title of the console window</div>
<div><strong>maxLines</strong>: the number of text lines that can be displayed and buffered</div>
<div><strong>mode</strong>: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a <a href="simulationScripts.htm">simulation script</a>, the console window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) is not used, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene (this only applies when called from an add-on script or the sandbox script).<br>
</div>
<div><strong>position</strong>: the initial position of the console window (x and y value). Can be NULL<br>
</div>
<div><strong>size</strong>: the initial size of the console window (x and y value). Can be NULL<br>
</div>
<div><strong>textColor</strong>: the color of the text (rgb values, 0-1). Can be NULL<br>
</div>
<div><strong>backgroundColor</strong>: the background color of the console window (rgb values, 0-1). Can be NULL<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise a console window handle</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number consoleHandle=sim.auxiliaryConsoleOpen(string title,number maxLines,number mode,table_2 position=nil,table_2 size=nil,table_3 textColor=nil,table_3 backgroundColor=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. Last 4 parameters can be omitted too.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAuxiliaryConsoleOpen">simxAuxiliaryConsoleOpen</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleOpen">simxAuxiliaryConsoleOpen</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAuxiliaryConsolePrint" id="simAuxiliaryConsolePrint"></a>simAuxiliaryConsolePrint / sim.auxiliaryConsolePrint</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Prints to an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">sim.auxiliaryConsoleOpen</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsolePrint(simInt consoleHandle,const simChar* text)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a> command<br>
</div>
<div><strong>text</strong>: the text to append, or NULL to clear the console window<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the operation was successful.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.auxiliaryConsolePrint(number consoleHandle,string text)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAuxiliaryConsolePrint">simxAuxiliaryConsolePrint</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxAuxiliaryConsolePrint">simxAuxiliaryConsolePrint</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simAuxiliaryConsoleShow" id="simAuxiliaryConsoleShow"></a>simAuxiliaryConsoleShow / sim.auxiliaryConsoleShow</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Shows or hides an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">sim.auxiliaryConsoleOpen</a> and <a href="#simAuxiliaryConsoleClose">sim.auxiliaryConsoleClose</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleShow(simInt consoleHandle,simBool showState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a> command. When combined with <em>sim.handleflag_extended</em>, then the function will simply query the visibility state of the console.</div>
<div><strong>showState</strong>: indicates whether the console should be hidden (0) or shown (!=0)</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window's show state was changed.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.auxiliaryConsoleShow(number consoleHandle,Boolean showState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.<br>
</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxAuxiliaryConsoleShow">simxAuxiliaryConsoleShow</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleShow">simxAuxiliaryConsoleShow</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBoolAnd32" id="simBoolAnd32"></a>simBoolAnd32 / sim.boolAnd32 </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 32-bit Boolean AND operation between two numbers. See also <a href="#simBoolOr32">sim.boolOr32</a> and <a href="#simBoolXor32">sim.boolXor32</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.boolAnd32(number value1,number value2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or nil in case of an error<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBoolOr32" id="simBoolOr32"></a>simBoolOr32 / sim.boolOr32 </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 32-bit Boolean OR operation between two numbers. See also <a href="#simBoolAnd32">sim.boolAnd32</a> and <a href="#simBoolXor32">sim.boolXor32</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.boolOr32(number value1,number value2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or nil in case of an error<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBoolXor32" id="simBoolXor32"></a>simBoolXor32 / sim.boolXor32 </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 32-bit Boolean exclusive-OR operation between two numbers. See also <a href="#simBoolAnd32">sim.boolAnd32</a> and <a href="#simBoolOr32">sim.boolOr32</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.boolXor32(number value1,number value2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBreakForceSensor" id="simBreakForceSensor"></a>simBreakForceSensor / sim.breakForceSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows breaking a force sensor during simulation. A broken force sensor will lose its positional and orientational constraints. See also <a href="#simReadForceSensor">sim.readForceSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBreakForceSensor(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object (must be a force sensor)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.breakForceSensor(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxBreakForceSensor">simxBreakForceSensor</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxBreakForceSensor">simxBreakForceSensor</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBroadcastMessage" id="simBroadcastMessage"></a>simBroadcastMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows a plugin to communicate with other plugins by broadcasting messages or data that other plugins can intercept. The message is also sent to the plugin that originally broadcasted the message (that module is free to ignore its own message). See V-REP's main client application source code for more details. See also <a href="#simSendModuleMessage">simSendModuleMessage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simBroadcastMessage(simInt* auxiliaryData,simVoid* customData,simInt* replyData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>auxiliaryData</strong>: pointer to 4 integers. auxiliaryData[0] should be a unique identifier different from 0. Use a large, random identifier, or better, your V-REP's serial number if the message is yours. Otherwise, use the identifier of some other module. auxiliaryData[1] could be the messageID of the message you wish to send to another module. auxiliaryData[2] and auxiliaryData[3] can be any values specific to your application.<br>
</div>
<div><strong>customData</strong>: customData of your application (the broadcaster is in charge to release that buffer). Can be NULL.<br>
</div>
<div><strong>replyData</strong>: pointer to 4 integers that can be used by a module to reply to a broadcasted message. Can be NULL. If not NULL, all 4 values are automatically initialized to -1.<br>
</div>
<br>
<div>Broadcasted messages can be intercepted in a plugin's "v_repMessage"-function. In the function, broadcasted messages can be recognized when the function's first argument ("message") is sim_message_module_broadcast.
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to custom reply data that can be used by a module to reply to a broadcasted message. The module that replies is in charge of allocating the data with <a href="#simCreateBuffer">simCreateBuffer</a> and the original broadcaster is in charge of releasing that data with <a href="#simReleaseBuffer">simReleaseBuffer</a>. A reply to a broadcasted message is triggered by a module that writes a value different from -1 into auxiliaryData[0]-auxiliaryData[3], thus aborting further broadcast of the original message and returning to the broadcaster. If the return value is different from NULL, the broadcast is also interrupted.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBuildIdentityMatrix" id="simBuildIdentityMatrix"></a>simBuildIdentityMatrix / sim.buildIdentityMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds an identity transformation matrix. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildIdentityMatrix(simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=sim.buildIdentityMatrix()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the identity matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBuildMatrix" id="simBuildMatrix"></a>simBuildMatrix / sim.buildMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds a transformation matrix based on a position vector and <a href="eulerAngles.htm">Euler angles</a>. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildMatrix(const simFloat* position,const simFloat* eulerAngles,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>position</strong>: pointer to 3 simFloat values representing the position component</div>
<div><strong>eulerAngles</strong>: pointer to 3 simFloat values representing the angular component</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the transformation matrix</div>
<div class=tab>The x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component of the matrix is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=sim.buildMatrix(table_3 position,table_3 eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>position</strong>: table to 3 numbers representing the position component</div>
<div><strong>eulerAngles</strong>: table to 3 numbers representing the angular component</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the transformation matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simBuildMatrixQ" id="simBuildMatrixQ"></a>simBuildMatrixQ / sim.buildMatrixQ </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds a transformation matrix based on a position vector and a quaternion. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildMatrixQ(const simFloat* position,const simFloat* quaternion,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>position</strong>: pointer to 3 simFloat values representing the position component</div>
<div><strong>quaternion</strong>: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the transformation matrix</div>
<div class=tab>The x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component of the matrix is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=sim.buildMatrixQ(table_3 position,table_4 quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>position</strong>: table of 3 numbers representing the position component</div>
<div><strong>quaternion</strong>: table of 4 numbers representing the orientation quaternion (x,y,z,w)</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the transformation matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCallScriptFunction" id="simCallScriptFunction"></a>simCallScriptFunction / sim.callScriptFunction</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a script function (from a <a href="plugins.htm">plugin</a>, <a href="mainClientApplication.htm">the main client application</a>, or from another script). This represents a callback inside of a script. Call this only:<br>
a) from the main thread, or:<br>
b) from a thread that originated from a threaded child script. In that case, you cannot call non-threaded child scripts.<br>
When calling <a href="simulationScripts.htm">simulation scripts</a>, then simulation must be running. See also <a href="#simExecuteScriptString">sim.executeScriptString</a> and <a href="#simSetScriptVariable">sim.setScriptVariable</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>From C/C++, call <a href="#simCallScriptFunctionEx">simCallScriptFunctionEx</a> instead.</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>...=sim.callScriptFunction(string functionNameAtScriptName,number scriptHandleOrType,...)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>functionNameAtScriptName</strong>: a string representing the function name and script name, e.g. <em>myFunctionName@theScriptName</em>. When the script is not associated with an object or name, then just specify the function name.</div>
<div><strong>scriptHandleOrType</strong>: the handle of the script, otherwise the type of the script:</div>
<div class=tab><em>sim.scripttype_mainscript</em> (0): the <a href="mainScript.htm">main script</a> will be called.</div>
<div class=tab><em>sim.scripttype_childscript</em> (1): a <a href="childScripts.htm">child script</a> will be called. A script name needs to be specified (i.e. the object name where the script is attached)</div>
<div class=tab><em>sim.scripttype_customizationscript</em> (6): a <a href="customizationScripts.htm">customization script</a> will be called. A script name needs to be specified (i.e. the object name where the script is attached)</div>
<div class=tab><em>sim.scripttype_sandboxscript</em> (8): <a href="sandboxScript.htm">the sandbox script</a> will be called.</div>
<div class=tab><em>sim.scripttype_addonscript</em> (2): an <a href="addOns.htm">add-on script</a> will be called (the add-on needs to be running). A script name needs to be specified (e.g. for  add-on <em>vrepAddOnScript-b0RemoteApiServer.lua</em>, <em>b0RemoteApiServer</em> is the script name)</div>
<div><strong>...</strong>: any number of arguments that will be handed over to the called function.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>...</strong>: any number of return values from the called function.</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCallScriptFunction">simxCallScriptFunction</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxCallScriptFunction">simxCallScriptFunction</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCallScriptFunctionEx" id="simCallScriptFunctionEx"></a>simCallScriptFunctionEx</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a script function (from a <a href="plugins.htm">plugin</a>, <a href="mainClientApplication.htm">the main client application</a>, or from another script). This represents a callback inside of a script. Call this only:<br>
a) from the main thread, or:<br>
b) from a thread that originated from a threaded child script. In that case, you cannot call non-threaded child scripts.<br>
When calling <a href="simulationScripts.htm">simulation scripts</a>, then simulation must be running. See also <a href="#simExecuteScriptString">sim.executeScriptString</a> and <a href="#simSetScriptVariable">sim.setScriptVariable</a>.
<br><br>
<div>Data exchange between a plugin and a script happens via a <a href="apiFunctionListCategory.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious and error prone. Use instead the helper classes located in <em>programming/common/stack</em> and <em>programming/include/stack</em>: they will greatly simplify the task. Have a look at the example plugins <a href="https://github.com/CoppeliaRobotics/v_repExtSkeletonPlugin" target="_blank">v_repExtSkeletonPlugin</a> and <a href="https://github.com/CoppeliaRobotics/v_repExtSkeletonPluginNG" target="_blank">v_repExtSkeletonPluginNG</a>.</div>


</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCallScriptFunctionEx(simInt scriptHandleOrType,const simChar* functionNameAtScriptName,simInt stackId)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandleOrType</strong>: the handle of the script, otherwise the type of the script:</div>
<div class=tab><em>sim_scripttype_mainscript</em> (0): the <a href="mainScript.htm">main script</a> will be called.</div>
<div class=tab><em>sim.scripttype_sandboxscript</em> (8): <a href="sandboxScript.htm">the sandbox script</a> will be called.</div>
<div class=tab><em>sim_scripttype_childscript</em> (1): a <a href="childScripts.htm">child script</a> will be called. In that case, <em>functionNameAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div class=tab><em>sim_scripttype_customizationscript</em> (6): a <a href="customizationScripts.htm">customization script</a> will be called. In that case, <em>functionNameAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div class=tab><em>sim.scripttype_addonscript</em> (2): an <a href="addOns.htm">add-on script</a> will be called (the add-on needs to be running). In that case, <em>functionNameAtScriptName</em> should also contain the name of the script (e.g. for  add-on <em>vrepAddOnScript-b0RemoteApiServer.lua</em>, <em>b0RemoteApiServer</em> is the script name)</div>
<div><strong>functionNameAtScriptName</strong>: the name of the Lua function to call in the specified script. If <em>scriptHandleOrType</em> is <em>sim_scripttype_childscript</em>, <em>sim_scripttype_customizationscript</em> or <em>sim_scripttype_addonscript</em>, then <em>functionNameAtScriptName</em> should also contain the name of the script: &quot;functionName@scriptName&quot;.</div>
<div><strong>stackId</strong>: a <a href="#simCreateStack">stack handle</a>. The stack represents the function's in/out values. See also the <a href="apiFunctionListCategory.htm#stacks">available stack functions</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>From Lua, call <a href="#simCallScriptFunction">sim.callScriptFunction</a> instead.</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCallScriptFunction">simxCallScriptFunction</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxCallScriptFunction">simxCallScriptFunction</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCameraFitToView" id="simCameraFitToView"></a>simCameraFitToView / sim.cameraFitToView </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Shifts and adjusts a camera associated with a view to fill the view entirely with the specified objects or models. See also the <a href="#simAdjustView">sim.adjustView</a> and <a href="#simFloatingViewAdd">sim.floatingViewAdd</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCameraFitToView(simInt viewHandleOrIndex,simInt objectCount,const simInt* objectHandles,simInt options,simFloat scaling)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the <em>sim_handleflag_camera</em> flag.</div>
<div><strong>objectCount</strong>: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.</div>
<div><strong>objectHandles</strong>: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be included</div>
<div class=tab>bit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size is</div>
<div><strong>scaling</strong>: scaling factor. Use '1' for normal behaviour.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 for a silent error (e.g. when the indicated view doesn't exist anymore), 1 for success<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.cameraFitToView(number viewHandleOrIndex,table objectHandles=nil,simInt options=0,simFloat scaling=1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function </div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckCollision" id="simCheckCollision"></a>simCheckCollision / sim.checkCollision </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether two entities are colliding. Detection is silent (no visual feedback) compared to <a href="#simHandleCollision">sim.handleCollision</a>. Also, the collidable flags of the entities are overridden if the entities are objects. See also <a href="#simReadCollision">sim.readCollision</a> and <a href="#simCheckCollisionEx">sim.checkCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckCollision(simInt entity1Handle,simInt entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 or 1 to indicate a collision state<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.checkCollision(number entity1Handle,number entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCheckCollision">simxCheckCollision</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckCollisionEx" id="simCheckCollisionEx"></a>simCheckCollisionEx / sim.checkCollisionEx </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether two entities are colliding. This is the extended functionality version of <a href="#simCheckCollision">sim.checkCollision</a>, and will return all intersections between the two entities. Detection is silent (no visual feedback) compared to <a href="#simHandleCollision">sim.handleCollision</a>. Also, the collidable flags of the entities are overridden if the entities are objects. See also <a href="#simReadCollision">sim.readCollision</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckCollisionEx(simInt entity1Handle,simInt entity2Handle,simFloat** intersectionSegments)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects<br>
</div>
<div><strong>intersectionSegments</strong>: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use <a href="#simReleaseBuffer">simReleaseBuffer</a> to delete the returned data. That data is only valid if return value is &gt;0<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the number of segments returned<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table intersections=sim.checkCollisionEx(number entity1Handle,number entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other collidable objects<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 for error, otherwise the number of segments returned</div>
<div><strong>intersections</strong>: a table that contains the intersection segments between the two entities.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckDistance" id="simCheckDistance"></a>simCheckDistance / sim.checkDistance </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks the minimum distance between two entities. Detection is silent (no visual feedback) compared to <a href="#simHandleDistance">sim.handleDistance</a>. Also, the measurable flags of the entities are overridden if the entities are objects. See also <a href="#simReadDistance">sim.readDistance</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckDistance(simInt entity1Handle,simInt entity2Handle,simFloat threshold,simFloat* distanceData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)<br>
</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objects<br>
</div>
<div><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.<br>
</div>
<div><strong>distanceData</strong>: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_7 distanceData=sim.checkDistance(number entity1Handle,number entity2Handle,number threshold)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)<br>
</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other measurable objects<br>
</div>
<div><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and result is 0. If threshold is 0 or negative, then no threshold is used.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise<br>
</div>
<div><strong>distanceData</strong>: distanceData[1]-distanceData[6] represents the distance segment, distanceData[7] is the distance between the entities. distanceData is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCheckDistance">simxCheckDistance</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckIkGroup" id="simCheckIkGroup"></a>simCheckIkGroup / sim.checkIkGroup </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Solves a registered IK group, but unlike the <a href="#simHandleIkGroup">sim.handleIkGroup</a> function, sim.checkIkGroup will not apply the calculated joint values, but instead return them in an array. See also <a href="#simHandleIkGroup">sim.handleIkGroup</a>, <a href="#simComputeJacobian">sim.computeJacobian</a> and <a href="#simGenerateIkPath">sim.generateIkPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckIkGroup(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simFloat* jointValues,const simInt* jointOptions)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a></div>
<div><strong>jointCnt</strong>: the number of joint handles provided in the jointHandles array.</div>
<div><strong>jointHandles</strong> (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.</div>
<div><strong>jointValues</strong> (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.</div>
<div><strong>jointOptions</strong>: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise an <a href="apiConstants.htm#ikCalculationResults">IK calculation result</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number ikCalculationResult,table jointValues=sim.checkIkGroup(number ikGroupHandle,table jointHandles,table jointOptions=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckOctreePointOccupancy" id="simCheckOctreePointOccupancy"></a>simCheckOctreePointOccupancy / sim.checkOctreePointOccupancy </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the provided points collide with the <a href="octrees.htm">octree</a> voxels. See also <a href="#simInsertVoxelsIntoOctree">sim.insertVoxelsIntoOctree</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt checkOctreePointOccupancy(simInt octreeHandle,simInt options,const simFloat* pts,simInt ptCnt,simUInt* tag,simUInt64* location,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference frame</div>
<div><strong>pts</strong>: a pointer to the points specified as X/Y/Z coordinates</div>
<div><strong>ptCnt</strong>: the number of points contained in pts</div>
<div><strong>tag</strong>: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.</div>
<div><strong>location</strong>: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:</div>
<div class=tab>bit0 - bit5: the depth level of the voxel in the octree structure (1-63).</div>
<div class=tab>bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:</div>
<div class=tabTab>0: (-1,-1,-1)</div>
<div class=tabTab>1: (+1,-1,-1)</div>
<div class=tabTab>2: (-1,+1,-1)</div>
<div class=tabTab>3: (+1,+1,-1)</div>
<div class=tabTab>4: (-1,-1,+1)</div>
<div class=tabTab>5: (+1,-1,+1)</div>
<div class=tabTab>6: (-1,+1,+1)</div>
<div class=tabTab>7: (+1,+1,+1)</div>
<div class=tab></div>
<div class=tab>as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.</div>

<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if the points do not collide with the voxels, 1 if the points collide with the voxels</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number tag,number locationLow,number locationHigh=sim.checkOctreePointOccupancy(number octreeHandle,number options,table points)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>if a single point is specified and collides with a voxel, 4 values are returned, otherwise only <strong>result</strong> will be returned. The <strong>location</strong> value is divided into a low- and high-value (i.e. first 32 bits and last 32 bits of <strong>location</strong>).</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckProximitySensor" id="simCheckProximitySensor"></a>simCheckProximitySensor / sim.checkProximitySensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated entity. Detection is silent (no visual feedback) compared to <a href="#simHandleProximitySensor">sim.handleProximitySensor</a>. Also, the detectable flags of the entity are overridden if the entity is an object. See also <a href="#simReadProximitySensor">sim.readProximitySensor</a> and <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensor(simInt sensorHandle,simInt entityHandle,simFloat* detectedPoint)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULL<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint=sim.checkProximitySensor(number sensorHandle,number entityHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<div><strong>distance</strong>: distance from the sensor origin to the detected point. Is nil if result is different from 1<br>
</div>
<div><strong>detectedPoint</strong>: position of the detected point relative to the sensor origin. Is nil if result is different from 1<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCheckProximitySensor">simxCheckProximitySensor</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckProximitySensorEx" id="simCheckProximitySensorEx"></a>simCheckProximitySensorEx / sim.checkProximitySensorEx </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated entity. This is the extended functionality version of <a href="#simCheckProximitySensor">sim.checkProximitySensor</a>. Detection is silent (no visual feedback) compared to <a href="#simHandleProximitySensor">sim.handleProximitySensor</a>. Also, the detectable flags of the entity are overridden if the entity is an object. see also <a href="#simReadProximitySensor">sim.readProximitySensor</a> and <a href="#simCheckProximitySensorEx2">sim.checkProximitySensorEx2</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensorEx(simInt sensorHandle,simInt entityHandle,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* surfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object<br>
</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>detectionMode</strong>: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.<br>
</div>
<div><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin<br>
</div>
<div><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULL<br>
</div>
<div><strong>surfaceNormalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULL<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle, table_3 surfaceNormalVector=sim.checkProximitySensorEx(number sensorHandle,number entityHandle,number detectionMode,number detectionthreshold,number maxAngle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object<br>
</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects<br>
</div>
<div><strong>detectionMode</strong>: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account).<br>
</div>
<div><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin<br>
</div>
<div><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<div><strong>distance</strong>: distance from the sensor origin to the detected point. Is nil if result is different from 1<br>
</div>
<div><strong>detectedPoint</strong>: position of the detected point relative to the sensor origin. Is nil if result is different from 1<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of detected object. Is nil if result is different from 1<br>
</div>
<div><strong>surfaceNormalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckProximitySensorEx2" id="simCheckProximitySensorEx2"></a>simCheckProximitySensorEx2 / sim.checkProximitySensorEx2 </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated points, segments or triangles. Detection is silent (no visual feedback). See also <a href="#simReadProximitySensor">sim.readProximitySensor</a> and <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensorEx2(simInt sensorHandle,simFloat* vertexPointer,simInt itemType,simInt itemCount,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simFloat* normalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>vertexPointer</strong>: a pointer to vertices</div>
<div><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</div>
<div><strong>itemCount</strong>: the number of items that vertexPointer points at</div>
<br>
<div>For the other parameters, see the description in <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>. (simCheckProximitySensorEx2 doesn't support occlusion checking)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,table_3 normalVector=sim.checkProximitySensorEx2(number sensorHandle,table vertices,number itemType,number itemCount,number mode,number threshold,number maxAngle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>vertices</strong>: a table containing vertices</div>
<div><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</div>
<div><strong>itemCount</strong>: the number of items that the 'vertices' table contains</div>
<br>
<div>For the other parameters, see the description in <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a>. (sim.checkProximitySensorEx2 doesn't support occlusion checking)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<br>
<div>For the other return values, see the description in <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a>.<br>
</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckVisionSensor" id="simCheckVisionSensor"></a>simCheckVisionSensor / sim.checkVisionSensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the vision sensor detects the indicated entity. Detection is silent (no visual feedback) compared to <a href="#simHandleVisionSensor">sim.handleVisionSensor</a>. Also, the renderable flag of the entity is overridden if the entity is an object. See also <a href="#simReadVisionSensor">sim.readVisionSensor</a> and <a href="#simCheckVisionSensorEx">sim.checkVisionSensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckVisionSensor(simInt sensorHandle,simInt entityHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>auxValues</strong>: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues).<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>Usage example:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
float* auxValues=NULL;
int* auxValuesCount=NULL;
float averageColor[3]={0.0f,0.0f,0.0f};
if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0)
{
    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))
    {
        averageColor[0]=auxValues[11];
        averageColor[1]=auxValues[12];
        averageColor[2]=auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=sim.checkVisionSensor(number sensorHandle,number entityHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function) (table values in Lua are indexed from 1, not 0!)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCheckVisionSensor">simxCheckVisionSensor</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCheckVisionSensorEx" id="simCheckVisionSensorEx"></a>simCheckVisionSensorEx / sim.checkVisionSensorEx </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the vision sensor detects the indicated entity. This is the extended functionality version of <a href="#simCheckVisionSensor">sim.checkVisionSensor</a>. Detection is silent (no visual feedback) compared to <a href="#simHandleVisionSensor">sim.handleVisionSensor</a>. Also, the renderable flag of the entity is overridden if the entity is an object. See also <a href="#simReadVisionSensor">sim.readVisionSensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simCheckVisionSensorEx(simInt sensorHandle,simInt entityHandle,simBool returnImage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>returnImage</strong>: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returned<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>image or depth buffer (use <a href="#simGetVisionSensorResolution">simGetVisionSensorResolution</a> for correct size), or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table buffer=sim.checkVisionSensorEx(number sensorHandle,number entityHandle,boolean returnImage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function: a table containing the image or depth buffer is returned (or nil in case of an error)<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simClearDoubleSignal" id="simClearDoubleSignal"></a>simClearDoubleSignal / sim.clearDoubleSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a double signal (removes it). See also the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearDoubleSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all double signals</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.clearDoubleSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxClearFloatSignal">simxClearFloatSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxClearFloatSignal">simxClearFloatSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simClearIntegerSignal" id="simClearIntegerSignal"></a>simClearIntegerSignal / sim.clearIntegerSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears an integer signal (removes it). See also the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearIntegerSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all integer signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.clearIntegerSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxClearIntegerSignal">simxClearIntegerSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxClearIntegerSignal">simxClearIntegerSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simClearStringSignal" id="simClearStringSignal"></a>simClearStringSignal / sim.clearStringSignal  (remote API equivalent: <a href="remoteApiFunctions.htm#simxClearStringSignal">simxClearStringSignal</a>)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a string signal (removes it). See also the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearStringSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all string signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.clearStringSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCloseModule" id="simCloseModule"></a>simCloseModule / sim.closeModule </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Releases resources reserved with the <a href="#simOpenModule">sim.openModule</a> command. This command can only be called from the main script. Call it from the <a href="mainScript.htm">main script</a> in the last simulation pass (usually with sim.handle_all argument). sim.closeModule is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">sim.openModule</a>, <a href="#simHandleModule">sim.handleModule</a> and simCloseModule.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number result=sim.closeModule(number sim.handle_all)</div>
<div>number result=sim.closeModule(string moduleName)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sim.handle_all</strong>: indicates that all plugins should be closed</div>
<div><strong>moduleName</strong>: the name of a specific plugin that should be closed</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCloseScene" id="simCloseScene"></a>simCloseScene</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes current scene, and switches to another open scene. If there is no other open scene, a new scene is then created. Can only be called from an <a href="addOns.htm">add-on</a>, or from the sanbox script, when called from Lua. See also <a href="#simLoadScene">sim.loadScene</a> and <a href="#simSaveScene">sim.saveScene</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCloseScene()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>none</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the current scene index.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.closeScene()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCloseScene">simxCloseScene</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxCloseScene">simxCloseScene</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCloseTextEditor" id="simCloseTextEditor"></a>sim.closeTextEditor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>DEPRECATED. See <a href="#simTextEditorClose">sim.textEditorClose</a> instead.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCombineRgbImages" id="simCombineRgbImages"></a>simCombineRgbImages / sim.combineRgbImages</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Combines two RGB images. See also <a href="#simTransformImage">sim.transformImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string outImg=sim.combineRgbImages(string img1,table_2 img1Res,string img2,table_2 img2Res,number operation)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>img1</strong>: input image 1, as succession of rgb values.</div>
<div><strong>img1Res</strong>: x/y resolution of image 1.</div>
<div><strong>img2</strong>: input image 2, as succession of rgb values.</div>
<div><strong>img2Res</strong>: x/y resolution of image 2.</div>
<div><strong>operation</strong>: <a href="apiConstants.htm#imageCombination">operation</a> to be performed with the two input images.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>output image as succession of rgb values, or nil in case of an error.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simComputeJacobian" id="simComputeJacobian"></a>simComputeJacobian / sim.computeJacobian </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Computes the Jacobian of a registered IK group. The result can then be read via <a href="#simGetIkGroupMatrix">sim.getIkGroupMatrix</a>. See also <a href="#simHandleIkGroup">sim.handleIkGroup</a> and <a href="#simCheckIkGroup">sim.checkIkGroup</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simComputeJacobian(simInt ikGroupHandle,simInt options,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group. See also <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): the joint IK weights are taken into account.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation failed</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.computeJacobian(number ikGroupHandle,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simComputeMassAndInertia" id="simComputeMassAndInertia"></a>simComputeMassAndInertia / sim.computeMassAndInertia </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Computes and applies the mass and inertia properties for a convex shape (or convex compound shape), based on a density value. If call this function while the simulation is running, you will have to call <a href="#simResetDynamicObject">sim.resetDynamicObject</a> upon the object, for the changes to take effect. See also <a href="#simGetShapeMassAndInertia">sim.getShapeMassAndInertia</a> and <a href="#simConvexDecompose">sim.convexDecompose</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simComputeMassAndInertia(simInt shapeHandle,simFloat density))</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of shape. The shape must be convex (or a convex compound).</div>
<div><strong>density</strong>: the density expressed in kg/m^3</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the shape is not convex, otherwise 1.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.computeMassAndInertia(number shapeHandle,number density)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simConvexDecompose" id="simConvexDecompose"></a>simConvexDecompose / sim.convexDecompose </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calculates the <a href="convexDecomposition.htm">convex decomposition</a> of a <a href="shapes.htm">shape</a> using the HACD or V-HACD algorithms. See also <a href="#simGetQHull">sim.getQHull</a>, <a href="#simGetDecimatedMesh">sim.getDecimatedMesh</a>, <a href="#simUngroupShape">sim.ungroupShape</a> and <a href="#simComputeMassAndInertia">sim.computeMassAndInertia</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simConvexDecompose(simInt shapeHandle,simInt options,const simInt* intParams,const simFloat* floatParams)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape to operate on</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scene</div>
<div class=tab>bit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.</div>
<div class=tab>bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.</div>
<div class=tab>bit3 set (8): HACD: extra points will be added when computing the concavity</div>
<div class=tab>bit4 set (16): HACD: faces points will be added when computing the concavity</div>
<div class=tab>bit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single mesh</div>
<div class=tab>bit6  (64): reserved. Do not set.</div>
<div class=tab>bit7 set (128): the V-HACD algorithm ○will be used. If not set, the HACD algorithm will be used.</div>
<div class=tab>bit8 set (256): V-HACD: pca is enabled (default is disabled).</div>
<div class=tab>bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).</div>

<div><strong>intParams</strong>: 10 int values:</div>
<div class=tab>intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)</div>
<div class=tab>intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)</div>
<div class=tab>intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)</div>
<div class=tab>intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).</div>
<div class=tab>intParams[4]: reserved. Set to 0.</div>
<div class=tab>intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).</div>
<div class=tab>intParams[6]: V-HACD: depth (1-32, 20 is default).</div>
<div class=tab>intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).</div>
<div class=tab>intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).</div>
<div class=tab>intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).</div>

<div><strong>floatParams</strong>: 10 float values:</div>
<div class=tab>floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)</div>
<div class=tab>floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)</div>
<div class=tab>floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)</div>
<div class=tab>floatParams[3]: reserved. Set to 0.0</div>
<div class=tab>floatParams[4]: reserved. Set to 0.0</div>
<div class=tab>floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).</div>
<div class=tab>floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).</div>
<div class=tab>floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).</div>
<div class=tab>floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).</div>
<div class=tab>floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise the handle of the new shape, or the handle of the original shape when morphing.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=sim.convexDecompose(number shapeHandle,number options,table_4 intParams,table_3 floatParams)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCopyMatrix" id="simCopyMatrix"></a>simCopyMatrix / sim.copyMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Copies a transformation matrix. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCopyMatrix(const simFloat* matrixIn,simFloat* matrixOut)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn</strong>: matrix to be copied</div>
<div><strong>matrixOut</strong>: copy of matrixIn (after the call)</div>
<br>
<div>matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)<br>
</div>
<div>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])<br>
</div>
<div>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])<br>
</div>
<div>The position component is (matrix[3],matrix[7],matrix[11])<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrixOut=sim.copyMatrix(table_12 matrixIn)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrixIn</strong>: matrix to be copied</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>matrixOut</strong>: copied matrix, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCopyPasteObjects" id="simCopyPasteObjects"></a>simCopyPasteObjects / sim.copyPasteObjects</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Copies and pastes objects, together with all their associated calculation objects and associated scripts. See also <a href="#simRemoveObject">sim.removeObject</a> and <a href="#simRemoveModel">sim.removeModel</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCopyPasteObjects(simInt* objectHandles,simInt objectCount,simInt options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandles</strong>: array containing the handles of the objects to copy and paste. The same array will receive the copied object handles.</div>
<div><strong>objectCount</strong>: the number of handles contained in the objectHandles array.</div>
<div><strong>options</strong>: bit-coded. If bit0 is set (i.e. 1), then whole models will be copied. In that case, all specified objects should be flagged as <em>model base</em>..</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of handles returned in the objectHandles array.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table copiedObjectHandles=sim.copyPasteObjects(table objectHandles,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCopyPasteObjects">simxCopyPasteObjects</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxCopyPasteObjects">simxCopyPasteObjects</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCopyStack" id="simCopyStack"></a>simCopyStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Duplicates a stack object. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCopyStack(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the handle of the duplicated stack.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateBuffer" id="simCreateBuffer"></a>simCreateBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a buffer. The buffer needs to be released with <a href="#simReleaseBuffer">simReleaseBuffer</a> except otherwise explicitly specified.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simCreateBuffer(simInt size)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>size</strong>: size of the buffer</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>buffer if operation was successful, NULL otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateCollection" id="simCreateCollection"></a>simCreateCollection / sim.createCollection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Creates a new <a href="collections.htm">collection</a>. See also <a href="#simRemoveCollection">sim.removeCollection</a> and <a href="#simAddObjectToCollection">sim.addObjectToCollection</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateCollection(const simChar* collectionName,simInt options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionName</strong>: the name of the collection. Use an empty string for a default name.</div>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): collection overrides collidable, measurable, renderable<!--, cuttable--> and detectable properties.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the new collection.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collectionHandle=sim.createCollection(string collectionName,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateDummy" id="simCreateDummy"></a>simCreateDummy / sim.createDummy </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="dummies.htm">dummy</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateDummy(simFloat size,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>size</strong>: the dummy size<br>
</div>
<div><strong>color</strong>: pointer to 4x3 values representing the dummy color (ambient/diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the dummy</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number dummyHandle=sim.createDummy(number size,table_12 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxCreateDummy">simxCreateDummy</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxCreateDummy">simxCreateDummy</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateForceSensor" id="simCreateForceSensor"></a>simCreateForceSensor / sim.createForceSensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="forceSensors.htm">force sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateForceSensor(simInt options,const simInt* intParams,const simFloat* floatParams,const float* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): force threshold enabled</div>
<div class=tab>bit 1 set (2): torque threshold enabled</div>
<div><strong>intParams (input)</strong>: 5 integer parameters:</div>
<div class=tab>intParams[0]: filter type (0=average, 1=median)</div>
<div class=tab>intParams[1]: value count the filter operates on</div>
<div class=tab>intParams[2]: number of consecutive threshold violation for the sensor to break</div>
<div class=tab>intParams[3]: reserved. Set to 0</div>
<div class=tab>intParams[4]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 5 floating point parameters:</div>
<div class=tab>floatParams[0]: sensor size</div>
<div class=tab>floatParams[1]: force threshold value</div>
<div class=tab>floatParams[2]: torque threshold value</div>
<div class=tab>floatParams[3]: reserved. Set to 0.0</div>
<div class=tab>floatParams[4]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=sim.createForceSensor(number options,table_5 intParams,table_5 floatParams,table_24 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateHeightfieldShape" id="simCreateHeightfieldShape"></a>simCreateHeightfieldShape / sim.createHeightfieldShape </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a heightfield <a href="shapes.htm">shape</a>. See also <a href="#simCreatePureShape">sim.createPureShape</a>, <a href="#simCreateMeshShape">sim.createMeshShape</a> and <a href="#simAddParticleObject">sim.addParticleObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateHeightfieldShape(simInt options,simFloat shadingAngle,simInt xPointCount,simInt yPointCount,simFloat xSize,const simFloat* heights)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): back faces are culled</div>
<div class=tab>bit 1 set (2): overlay mesh is visible</div>
<div class=tab>bit 2 set (4): a simple shape is generated instead of a heightfield</div>
<div class=tab>bit 3 set (8): the heightfield is not respondable</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>xPointCount/yPointCount</strong>: the number of rows and lines of the heightfield.</div>
<div><strong>xSize</strong>: the length of the x side of the heightfield</div>
<div><strong>heights</strong>: a pointer to xPointCount*yPointCount height values.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.createHeightfieldShape(number options,number shadingAngle,number xPointCount,number yPointCount,number xSize,table heights)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateIkElement" id="simCreateIkElement"></a>simCreateIkElement / sim.createIkElement </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates an <a href="basicsOnIkGroupsAndIkElements.htm">IK element</a>. See also <a href="#simCreateIkGroup">sim.createIkGroup</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateIkElement(simInt ikGroupHandle,simInt options,const simInt* intParams,const simFloat* floatParams,const simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: the handle to an IK group which will contain this IK element.</div>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): the element is inactive</div>
<div><strong>intParams</strong>: an array of 4 integer parameters:</div>
<div class=tab>intParams[0]: the handle of the tip dummy.</div>
<div class=tab>intParams[1]: the handle of the base object, or -1 for none (i.e. world).</div>
<div class=tab>intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.</div>
<div class=tab>intParams[3]: the <a href="apiConstants.htm#ikConstraints">IK constraints</a>.</div>
<div><strong>floatParams</strong>: an optional array of 4 float parameters (i.e. array can be NULL):</div>
<div class=tab>floatParams[0]: the linear precision.</div>
<div class=tab>floatParams[1]: the angular precision.</div>
<div class=tab>floatParams[2]: the position weight.</div>
<div class=tab>floatParams[3]: the orientation weight.</div>
<div><strong>reserved</strong>: reserved. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.createIkElement(number ikGroupHandle,number options,table intParams,table floatParams=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateIkGroup" id="simCreateIkGroup"></a>simCreateIkGroup / sim.createIkGroup </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates an <a href="basicsOnIkGroupsAndIkElements.htm">IK group</a>. See also <a href="#simRemoveIkGroup">sim.removeIkGroup</a> and <a href="#simCreateIkElement">sim.createIkElement</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateIkGroup(simInt options,const simInt* intParams,const simFloat* floatParams,const simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): the group is inactive.</div>
<div class=tab>bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).</div>
<div class=tab>bit 2 set (4): restore if position not reached.</div>
<div class=tab>bit 3 set (8): restore if orientation not reached.</div>
<div class=tab>bit 4 set (16): do not ignore the joint's max. step sizes.</div>
<div class=tab>bit 5 set (32): the group is explicitely handled.</div>
<div><strong>intParams</strong>: an optional array of 2 integer parameters (i.e. array can be NULL):</div>
<div class=tab>intParams[0]: the <a href="apiConstants.htm#ikCalculationMethods">IK calculation method</a>.</div>
<div class=tab>intParams[1]: the maximum number of iterations.</div>
<div><strong>floatParams</strong>: an optional array of 4 float parameters (i.e. array can be NULL):</div>
<div class=tab>floatParams[0]: the DLS factor.</div>
<div class=tab>floatParams[1]: the joint limit weight.</div>
<div class=tab>floatParams[2]: the prismatic joint limit threshold.</div>
<div class=tab>floatParams[3]: the revolute joint limit threshold.</div>
<div><strong>reserved</strong>: reserved. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the IK group handle.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number ikGroupHandle=sim.createIkGroup(number options,table intParams=nil,table floatParams=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateJoint" id="simCreateJoint"></a>simCreateJoint / sim.createJoint </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="joints.htm">joint</a>. See also <a href="#simSetJointInterval">sim.setJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateJoint(simInt jointType,simInt jointMode,simInt options,const simFloat* sizes,const simFloat* colorA,const simFloat* colorB)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointType</strong>: <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_revolute_subtype</a>, <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_prismatic_subtype</a> or <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_spherical_subtype</a><br>
</div>
<div><strong>jointMode</strong>: a <a href="apiConstants.htm#jointModes">joint mode</a> value</div>
<div><strong>options</strong>: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)</div>
<div><strong>sizes</strong>: pointer to 2 values indicating the joint length and diameter. Can be NULL for default values<br>
</div>
<div><strong>colorA</strong>: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values<br>
</div>
<div><strong>colorB</strong>: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the joint</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number jointHandle=sim.createJoint(number jointType,number jointMode,number options,table_2 sizes=nil,table_12 colorA=nil,table_12 colorB=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateMeshShape" id="simCreateMeshShape"></a>simCreateMeshShape / sim.createMeshShape </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a mesh shape. See also <a href="#simCreatePureShape">sim.createPureShape</a>, <a href="#simCreateHeightfieldShape">sim.createHeightfieldShape</a> and <a href="#simGetShapeMesh">sim.getShapeMesh</a>, and see <a href="#simImportMesh">sim.importMesh</a> for a usage example.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateMeshShape(simInt options,simFloat shadingAngle,const simFloat* vertices,simInt verticesSize,const simInt* indices,simInt indicesSize,simFloat* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>vertices</strong>: an array of vertices</div>
<div><strong>verticesSize</strong>: the size of the vertice array</div>
<div><strong>indices</strong>: an array of indices</div>
<div><strong>indicesSize</strong>: the size of the indice array</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.createMeshShape(number options,number shadingAngle,table vertices,table indices)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>options</strong>: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>vertices</strong>: a table of vertices</div>
<div><strong>indices</strong>: a table of indices</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateOctree" id="simCreateOctree"></a>simCreateOctree / sim.createOctree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates an empty <a href="octrees.htm">octree</a>. See also <a href="#simRemoveObject">sim.removeObject</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateOctree(simFloat voxelSize,simInt options,simFloat pointSize,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>voxelSize</strong>: the size of the voxels</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): voxels have random colors</div>
<div class=tab>bit1 set (2): show octree structure</div>
<div class=tab>bit2 set (4): show points instead of voxels</div>
<div class=tab>bit3 set (8): reserved. keep unset</div>
<div class=tab>bit4 set (16): color is emissive</div>
<div><strong>pointSize</strong>: the size of the points in pixels, when voxels are rendered with points</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the octree</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number handle=sim.createOctree(number voxelSize,number options,number pointSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreatePath" id="simCreatePath"></a>simCreatePath / sim.createPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="paths.htm">path object</a>. See also <a href="#simInsertPathCtrlPoints">sim.insertPathCtrlPoints</a> and <a href="#simCutPathCtrlPoints">sim.cutPathCtrlPoints</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreatePath(simInt attributes,const simInt* intParams,const simFloat* floatParams,const simFloat* color)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>attributes</strong>: a combination of <a href="apiConstants.htm#pathObjectProperties">path properties</a>, or -1 for default attributes</div>
<div><strong>intParams (input)</strong>: NULL for default values, or 3 integer values:</div>
<div class=tab>intParams[0]: line size of the path</div>
<div class=tab>intParams[1]: the path <a href="apiConstants.htm#distanceCalculationMethods">length calculation method</a></div>
<div class=tab>intParams[2]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: NULL for default values, or 3 float values:</div>
<div class=tab>floatParams[0]: control point size</div>
<div class=tab>floatParams[1]: the angular to linear conversion coefficient</div>
<div class=tab>floatParams[2]: the virtual distance scaling factor</div>
<div><strong>color (input)</strong>: pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created path</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number pathHandle=sim.createPath(number attributes,table_3 intParams=nil,table_3 floatParams=nil,table_12 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreatePointCloud" id="simCreatePointCloud"></a>simCreatePointCloud / sim.createPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates an empty <a href="pointClouds.htm">point cloud</a>. See also <a href="#simRemoveObject">sim.removeObject</a>, <a href="#simSetPointCloudOptions">sim.setPointCloudOptions</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreatePointCloud(simFloat maxVoxelSize,simInt maxPtCntPerVoxel,simInt options,simFloat pointSize,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>maxVoxelSize</strong>: the maximum size of the octree voxels containing points</div>
<div><strong>maxPtCntPerVoxel</strong>: the maximum number of points allowed in a same octree voxel</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): points have random colors</div>
<div class=tab>bit1 set (2): show octree structure</div>
<div class=tab>bit2 set (4): reserved. keep unset</div>
<div class=tab>bit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="collidableObjects.htm">collidable</a>, <a href="measurableObjects.htm">measurable</a> or <a href="detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</div>
<div class=tab>bit4 set (16): color is emissive</div>
<div><strong>pointSize</strong>: the size of the points, in pixels</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number handle=sim.createPointCloud(number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateProximitySensor" id="simCreateProximitySensor"></a>simCreateProximitySensor / sim.createProximitySensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="proximitySensors.htm">proximity sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateProximitySensor(simInt sensorType,simInt subType,simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorType</strong>: the desired <a href="apiConstants.htm#sceneObjectSubTypes">proximity sensor type</a> (e.g. sim_proximitysensor_cone_subtype)</div>
<div><strong>subType</strong>: the desired <a href="apiConstants.htm#sceneObjectSpecialProperties">proximity sensor sub-type</a> (e.g. sim_objectspecialproperty_detectable_ultrasonic)</div>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): the sensor will be explicitely handled</div>
<div class=tab>bit 1 set (2): the detection volumes are not shown when detecting something</div>
<div class=tab>bit 2 set (4): the detection volumes are not shown when not detecting anything</div>
<div class=tab>bit 3 set (8): front faces are not detected</div>
<div class=tab>bit 4 set (16): back faces are not detected</div>
<div class=tab>bit 5 set (32): fast detection (i.e. not exact detection)</div>
<div class=tab>bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold angle</div>
<div class=tab>bit 7 set (128): occlusion check is active</div>
<div class=tab>bit 8 set (256): smallest distance threshold will be active</div>
<div class=tab>bit 9 set (512): randomized detection (only with ray-type proximity sensors)</div>
<div><strong>intParams (input)</strong>: 8 integer parameters:</div>
<div class=tab>intParams[0]: face count (volume description)</div>
<div class=tab>intParams[1]: face count far (volume description)</div>
<div class=tab>intParams[2]: subdivisions (volume description)</div>
<div class=tab>intParams[3]: subdivisions far (volume description)</div>
<div class=tab>intParams[4]: randomized detection, sample count per reading</div>
<div class=tab>intParams[5]: randomized detection, individual ray detection count for triggering</div>
<div class=tab>intParams[6]: reserved. Set to 0</div>
<div class=tab>intParams[7]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 15 floating point parameters:</div>
<div class=tab>floatParams[0]: offset (volume description)</div>
<div class=tab>floatParams[1]: range (volume description)</div>
<div class=tab>floatParams[2]: x size (volume description)</div>
<div class=tab>floatParams[3]: y size (volume description)</div>
<div class=tab>floatParams[4]: x size far (volume description)</div>
<div class=tab>floatParams[5]: y size far (volume description)</div>
<div class=tab>floatParams[6]: inside gap (volume description)</div>
<div class=tab>floatParams[7]: radius (volume description)</div>
<div class=tab>floatParams[8]: radius far (volume description)</div>
<div class=tab>floatParams[9]: angle (volume description)</div>
<div class=tab>floatParams[10]: threshold angle for limited angle detection (see bit 6 above)</div>
<div class=tab>floatParams[11]: smallest detection distance (see bit 8 above)</div>
<div class=tab>floatParams[12]: sensing point size</div>
<div class=tab>floatParams[13]: reserved. Set to 0.0</div>
<div class=tab>floatParams[14]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=sim.createProximitySensor(number sensorType,number subType,number options,table_8 intParams,table_15 floatParams,table_48 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreatePureShape" id="simCreatePureShape"></a>simCreatePureShape / sim.createPureShape </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a pure primitive shape. See also <a href="#simCreateMeshShape">sim.createMeshShape</a>, <a href="#simCreateHeightfieldShape">sim.createHeightfieldShape</a> and <a href="#simAddParticleObject">sim.addParticleObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreatePureShape(simInt primitiveType,simInt options,const simFloat* sizes,simFloat mass,const simInt* precision)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>primitiveType</strong>: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a cone</div>
<div><strong>options</strong>: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open ends<br>
</div>
<div><strong>sizes</strong>: 3 values indicating the size of the shape</div>
<div><strong>mass</strong>: the mass of the shape</div>
<div><strong>precision</strong>: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default values<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.createPureShape(number primitiveType,number options,table_3 sizes,number mass,table_2 precision=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateStack" id="simCreateStack"></a>simCreateStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a stack object that is mainly used to exchange complex data in an easy way with scripts. See also <a href="#simReleaseStack">simReleaseStack</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateStack()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise a stack handle.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateTexture" id="simCreateTexture"></a>simCreateTexture / sim.createTexture </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a planar shape, that will be textured with a new, or imported texture. See also <a href="#simGetTextureId">sim.getTextureId</a>, <a href="#simReadTexture">sim.readTexture</a>,  <a href="#simWriteTexture">sim.writeTexture</a> and <a href="#simSetShapeTexture">sim.setShapeTexture</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateTexture(const simChar* fileName,simInt options,const simFloat* planeSizes,const simFloat* scalingUV,const simFloat* xy_g,simInt fixedResolution,simInt* textureId,simInt* resolution,const simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileName</strong>: the filename of the texure to import, or an empty string if you wish to create a new texture.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab><strong>bit0</strong> set (1) =do not interpolate adjacent color patches.</div>
<div class=tab><strong>bit1</strong> set (2) =apply the texture in decal-mode.</div>
<div class=tab><strong>bit2</strong> set (4) =repeat the texture along the U direction.</div>
<div class=tab><strong>bit3</strong> set (8) =repeat the texture along the V direction.</div>
<div><strong>planeSizes</strong>: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.</div>
<div><strong>scalingUV</strong>: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.</div>
<div><strong>xy_g</strong>: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.</div>
<div><strong>fixedResolution</strong>: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).</div>
<div><strong>resolution</strong>: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.</div>
<div><strong>textureId</strong>: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.</div>
<div><strong>reserved</strong>: reserved. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the object handle of the created planar shape.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle,number textureId,table_2 resolution=sim.createTexture(string fileName,number options,table_2 planeSizes=nil,table_2 scalingUV=nil,table_2 xy_g=nil,number fixedResolution=0,table_2 resolution=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCreateVisionSensor" id="simCreateVisionSensor"></a>simCreateVisionSensor / sim.createVisionSensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="visionSensors.htm">vision sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateVisionSensor(simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set (1): the sensor will be explicitely handled</div>
<div class=tab>bit 1 set (2): the sensor will be in perspective operation mode</div>
<div class=tab>bit 2 set (4): the sensor volume will not be shown when not detecting anything</div>
<div class=tab>bit 3 set (8): the sensor volume will not be shown when detecting something</div>
<div class=tab>bit 4 set (16): the sensor will be passive (use an external image)</div>
<div class=tab>bit 5 set (32): the sensor will use local lights</div>
<div class=tab>bit 6 set (64): the sensor will not render any fog</div>
<div class=tab>bit 7 set (128): the sensor will use a specific color for default background (i.e. "null" pixels)</div>
<div><strong>intParams (input)</strong>: 4 integer parameters:</div>
<div class=tab>intParams[0]: sensor resolution x</div>
<div class=tab>intParams[1]: sensor resolution y</div>
<div class=tab>intParams[2]: reserved. Set to 0</div>
<div class=tab>intParams[3]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 11 floating point parameters:</div>
<div class=tab>floatParams[0]: near clipping plane</div>
<div class=tab>floatParams[1]: far clipping plane</div>
<div class=tab>floatParams[2]: view angle / ortho view size</div>
<div class=tab>floatParams[3]: sensor size x</div>
<div class=tab>floatParams[4]: sensor size y</div>
<div class=tab>floatParams[5]: sensor size z</div>
<div class=tab>floatParams[6]: "null" pixel red-value</div>
<div class=tab>floatParams[7]: "null" pixel green-value</div>
<div class=tab>floatParams[8]: "null" pixel blue-value</div>
<div class=tab>floatParams[9]: reserved. Set to 0.0</div>
<div class=tab>floatParams[10]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=sim.createVisionSensor(number options,table_4 intParams,table_11 floatParams,table_48 color=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simCutPathCtrlPoints" id="simCutPathCtrlPoints"></a>simCutPathCtrlPoints / sim.cutPathCtrlPoints </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes one or several control points from a <a href="paths.htm">path object</a>. See also <a href="#simInsertPathCtrlPoints">sim.insertPathCtrlPoints</a> and <a href="#simCreatePath">sim.createPath</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCutPathCtrlPoints(simInt pathHandle,simInt startIndex,simInt ptCnt)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: the handle of the path. Refer also to <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>startIndex</strong>: the zero-based index of the first control point to remove, or -1 to remove all the control points.</div>
<div><strong>ptCnt</strong>: the number of control points to remove.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.cutPathCtrlPoints(number pathHandle,number startIndex,number ptCnt)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simDebugStack" id="simDebugStack"></a>simDebugStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Prints the content of the specified stack to the console. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDebugStack(simInt stackHandle,simInt cIndex)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>cIndex</strong>: the zero-based index of the stack location to print, or -1 to print the full stack.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simDisplayDialog" id="simDisplayDialog"></a>simDisplayDialog / sim.displayDialog</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Displays a generic dialog box. Use in conjunction with <a href="#simGetDialogResult">sim.getDialogResult</a> ,<a href="#simGetDialogInput">sim.getDialogInput</a> and <a href="#simEndDialog">sim.endDialog</a>. From C, the function will only create non-modal dialogs (non-blocking), from Lua, modal dialogs can be created if called from a child script that runs in a thread. Use <a href="customUIPlugin.htm">custom user interfaces</a> instead if a higher customization level is required. Dialogs displayed from a <a href="mainScript.htm">main script</a> or a <a href="childScripts.htm">child script</a> will automatically close at simulation end. See also <a href="#simMsgBox">sim.msgBox</a> and <a href="#simFileDialog">sim.fileDialog</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDisplayDialog(const simChar* titleText,const simChar* mainText,simInt dialogType,const simChar* initialText,void* NULL,void* NULL,void* NULL)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>titleText</strong>: Title bar text</div>
<div><strong>mainText</strong>: Information text</div>
<div><strong>dialogType</strong>: <a href="apiConstants.htm#genericDialogStyles">generic dialog style</a></div>
<div><strong>initialText</strong>: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of generic dialog if operation was successful, -1 otherwise. The handle should be used with following functions: <a href="#simGetDialogResult">simGetDialogResult</a> ,<a href="#simGetDialogInput">simGetDialogInput</a> and <a href="#simEndDialog">simEndDialog</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number dialogHandle=sim.displayDialog(string titleText,string mainText,number dialogType,boolean modalDialog,string initialText)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>titleText</strong>: Title bar text</div>
<div><strong>mainText</strong>: information text</div>
<div><strong>dialogType</strong>: generic dialog style</div>
<div><strong>modalDialog</strong>: specifies whether the dialog is modal. Modal dialogs are only allowed when not called from the main thread.<br>
</div>
<div><strong>initialText</strong>: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be nil or omitted<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>dialogHandle</strong>: handle of generic dialog, or nil if operation failed</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxDisplayDialog">simxDisplayDialog</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxDisplayDialog">simxDisplayDialog</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simDoesFileExist" id="simDoesFileExist"></a>simDoesFileExist</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether a file exists.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDoesFileExist(const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: The filename extension is required</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the filename exists, 0 if it does not exist, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simEmptyCollection" id="simEmptyCollection"></a>simEmptyCollection / sim.emptyCollection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Clears a collection from all the objects it contains. An empty collection will not survive, unless you add some objects to it again with <a href="#simAddObjectToCollection">sim.addObjectToCollection</a> right after. See also <a href="#simRemoveCollection">sim.removeCollection</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simEmptyCollection(simInt collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection to clear. sim_handle_all clears all collections from their obects.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.emptyCollection(number collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simEnableEventCallback" id="simEnableEventCallback"></a>simEnableEventCallback</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Enables or disables a specific <a href="apiConstants.htm#simulatorMessages">event callback</a>, on a <a href="plugins.htm">plugin</a> base. Some event callbacks might be called very frequently, and are not enabled by default, in order not to slow down V-REP. A plugin may enable one or several of such event callbacks, in which case only that plugin will receive the event callback notifications. If a given plugin registers twice the same event callback, it will be disabled again.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simEnableEventCallback(simInt eventCallbackType,const simChar* plugin,simInt reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>eventCallbackType</strong>: one of following values: sim_message_eventcallback_renderingpass, sim_message_eventcallback_opengl, sim_message_eventcallback_openglframe or sim_message_eventcallback_openglcameraview.</div>
<div><strong>plugin</strong>: the case-sensitive name of the plugin that wishes to receive the notifications. For the plugin &quot;v_repExtMyPlugin&quot;, specify &quot;MyPlugin&quot;.</div>
<div><strong>reserved</strong>: reserved. Set to -1.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error. Otherwise 1 if the callback is enabled, or 0 if it is disabled.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>-</strong></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>-</strong></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simEndDialog" id="simEndDialog"></a>simEndDialog / sim.endDialog</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes and releases resource from a previous call to <a href="#simDisplayDialog">sim.displayDialog</a>. Even if the dialog is not visible anymore, you should release resources by using this function (however at the end of a simulation, all dialog resources allocated from a <a href="mainScript.htm">main script</a> or a <a href="childScripts.htm">child script</a> are automatically released).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simEndDialog(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of generic dialog (return value of simDisplayDialog)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.endDialog(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxEndDialog">simxEndDialog</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxEndDialog">simxEndDialog</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simExecuteScriptString" id="simExecuteScriptString"></a>simExecuteScriptString / sim.executeScriptString</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes some Lua code in a specific script (from a <a href="plugins.htm">plugin</a>, <a href="mainClientApplication.htm">the main client application</a>, or from another script). Call this only:<br>
a) from the main thread, or:<br>
b) from a thread that originated from a threaded child script. In that case, you cannot call non-threaded child scripts.<br>
When calling <a href="simulationScripts.htm">simulation scripts</a>, then simulation must be running. See also <a href="#simCallScriptFunction">sim.callScriptFunction</a>. <br><br>
<div>Data exchange between a plugin and a script happens via a <a href="apiFunctionListCategory.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious and error prone. Use instead the helper classes located in <em>programming/common/stack</em> and <em>programming/include/stack</em>: they will greatly simplify the task. Have a look at the example plugins <a href="https://github.com/CoppeliaRobotics/v_repExtSkeletonPlugin" target="_blank">v_repExtSkeletonPlugin</a> and <a href="https://github.com/CoppeliaRobotics/v_repExtSkeletonPluginNG" target="_blank">v_repExtSkeletonPluginNG</a>.</div>


</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simExecuteScriptString(simInt scriptHandleOrType,const simChar* stringAtScriptName,simInt stackId)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandleOrType</strong>: the handle of the script, otherwise the type of the script:</div>
<div class=tab><em>sim_scripttype_mainscript</em> (0): the <a href="mainScript.htm">main script</a>.</div>
<div class=tab><em>sim_scripttype_childscript</em> (1): a <a href="childScripts.htm">child script</a>. In that case, <em>stringAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div class=tab><em>sim_scripttype_customizationscript</em> (6): a <a href="customizationScripts.htm">customization script</a>. In that case, <em>stringAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div class=tab><em>sim_scripttype_sandboxscript</em> (8): <a href="sandboxScript.htm">the sandbox script</a>.</div>
<div><strong>stringAtScriptName</strong>: some Lua code to execute in the specified script, followed by @: &quot;string@&quot;. If <em>scriptHandleOrType</em> is <em>sim_scripttype_childscript</em>, or <em>sim_scripttype_customizationscript</em>, then <em>stringAtScriptName</em> should also contain the name of the object associated with the script: &quot;string@objectName&quot;.</div>
<div><strong>stackId</strong>: 0 (for no stack) or a <a href="#simCreateStack">stack handle</a>. The stack holds possible out values. See also the <a href="apiFunctionListCategory.htm#stacks">available stack functions</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,executionResult=sim.executeScriptString(string stringAtScriptName,number scriptHandleOrType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: -1 in case of an error</div>
<div><strong>executionResult</strong>: return value of the executed code</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxExecuteScriptString">simxExecuteScriptString</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simExportIk" id="simExportIk"></a>simExportIk / sim.exportIk </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Exports the IK content of a scene. The generated file can be used with the <a href="externalIk.htm">external IK</a>, to do IK computations in an external application.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simExportIk(const simChar* pathAndFilename,simInt reserved1,simVoid* reserved2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathAndFilename</strong>: the location and the name of the file to create.</div>
<div><strong>reserved1</strong>: reserved argument, keep at 0.</div>
<div><strong>reserved2</strong>: reserved argument, keep at NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 or 0 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.exportIk(string pathAndFilename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simExportMesh" id="simExportMesh"></a>simExportMesh / sim.exportMesh </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Exports a mesh to a file. See also <a href="#simImportMesh">sim.importMesh</a> and <a href="#simGetShapeMesh">sim.getShapeMesh</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simExportMesh(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat scalingFactor,simInt elementCount,simFloat** vertices,const simInt* verticesSizes,simInt** indices,const simInt* indicesSizes,simFloat** reserved,simChar** names)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: the fileformat to export to:</div>
<div class=tab>0: OBJ format</div>
<div class=tab>3: TEXT STL format</div>
<div class=tab>4: BINARY STL format</div>
<div class=tab>5: COLLADA format</div>
<div class=tab>6: TEXT PLY format</div>
<div class=tab>7: BINARY PLY format</div>
<div><strong>pathAndFilename</strong>: the location of the file to create.</div>
<div><strong>options</strong>: keep at 0</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the vertices to export</div>
<div><strong>vertices</strong>: an array to vertice arrays. See the example below</div>
<div><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. See the example below</div>
<div><strong>indices</strong>: an array to indice arrays. See the example below</div>
<div><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. See the example below</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.</div>
<div><strong>names</strong>: Keep at NULL</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
// Exports all shapes in the scene
simInt shapeCount=0;
while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);
shapeCount--;
simFloat** vertices=new simFloat*[shapeCount];
simInt* verticesSizes=new simInt[shapeCount];
simInt** indices=new simInt*[shapeCount];
simInt* indicesSizes=new simInt[shapeCount];
simInt index=0;
while (true)
{
    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);
    if (shapeHandle&#60;0)
        break;
    simFloat* vert;
    simInt vertS;
    simInt* ind;
    simInt indS;
    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);
    vertices[index-1]=vert;
    verticesSizes[index-1]=vertS;
    indices[index-1]=ind;
    indicesSizes[index-1]=indS;
    simFloat m[12];
    simGetObjectMatrix(shapeHandle,-1,m);
    for (simInt i=0;i&#60;vertS/3;i++)
    {
        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};
        simTransformVector(m,v);
        vert[3*i+0]=v[0];
        vert[3*i+1]=v[1];
        vert[3*i+2]=v[2];
    }
}
simExportMesh(0,"d:\\example.obj",0,1,shapeCount,vertices,
                 verticesSizes,indices,indicesSizes,NULL,NULL);
for (simInt i=0;i&#60;shapeCount;i++)
{
    simReleaseBuffer((simChar*)vertices[i]);
    simReleaseBuffer((simChar*)indices[i]);
}
delete[] vertices;
delete[] verticesSizes;
delete[] indices;
delete[] indicesSizes;</pre>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.exportMesh(number fileformat,string pathAndFilename,number options,number scalingFactor,table_of_table vertices,table_of_table indices)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>fileformat</strong>: same as C function</div>
<div><strong>pathAndFilename</strong>: same as C function</div>
<div><strong>options</strong>: same as C function</div>
<div><strong>scalingFactor</strong>: same as C function</div>
<div><strong>vertices</strong>: a table of vertice tables. See the example below</div>
<div><strong>indices</strong>: a table of indice tables. See the example below</div>
<br>
<div>USAGE EXAMPLE (e.g. in a <a href="customizationScripts.htm">customization script</a>):</div>
<pre class=lightRedBoxNoMarginAndSmall>
-- Exports all shapes in the scene
if (exportButtonPressed) then
    allVertices={}
    allIndices={}
    shapeIndex=0
    while (true) do
        h=sim.getObjects(shapeIndex,sim.object_shape_type)
        if (h&#60;0) then
            break
        end
        shapeIndex=shapeIndex+1
        vertices,indices=sim.getShapeMesh(h)
        m=sim.getObjectMatrix(h,-1)
        for i=1,#vertices/3,1 do
            v={vertices[3*(i-1)+1],vertices[3*(i-1)+2],vertices[3*(i-1)+3]}
            v=sim.multiplyVector(m,v)
            vertices[3*(i-1)+1]=v[1]
            vertices[3*(i-1)+2]=v[2]
            vertices[3*(i-1)+3]=v[3]
        end
        table.insert(allVertices,vertices)
        table.insert(allIndices,indices)
    end
    if (#allVertices>0) then
        sim.exportMesh(0,"d:\\example.obj",0,1,allVertices,allIndices)
    end
end</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simFileDialog" id="simFileDialog"></a>simFileDialog / sim.fileDialog </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a dialog that allows selecting a file for save or load operations, or a folder. See also <a href="#simMsgBox">sim.msgBox</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simFileDialog(simInt dlgType,const simChar* title,const simChar* startPath,const simChar* initName,const simChar* extName,const simChar* ext)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dlgType</strong>: the <a href="apiConstants.htm#fileDlgTypes">file dialog type</a>.</div>
<div><strong>title</strong>: title of the dialog</div>
<div><strong>startPath</strong>: the initial path. Indicate an empty string for the path to V-REP's application</div>
<div><strong>initName</strong>: the initial name. Can be an empty string</div>
<div><strong>extName</strong>: the extension name, e.g. &quot;text file&quot;. Should be an empty string with dlgType=sim_filedlg_type_folder.</div>
<div><strong>ext</strong>: the extension, e.g. &quot;txt&quot;. Can contain several extensions, separated by semicolons, with dlgType=sim_filedlg_type_load or dlgType=sim_filedlg_type_load_multiple. Should be an empty string with dlgType=sim_filedlg_type_folder.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to a string representing the selected file name and path, or folder name and path. In case several files were selected for a load operation, then they will be separated by a semicolon. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string pathAndName=sim.fileDialog(number mode,string title,string startPath,string initName,string extName,string ext)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simFloatingViewAdd" id="simFloatingViewAdd"></a>simFloatingViewAdd / sim.floatingViewAdd </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a floating view to current page. See also the <a href="#simFloatingViewRemove">sim.floatingViewRemove</a>, <a href="#simAdjustView">sim.adjustView</a> and <a href="#simCameraFitToView">sim.cameraFitToView</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simFloatingViewAdd(simFloat posX,simFloat posY,simFloat sizeX,simFloat sizeY,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>posX &amp; posY</strong>: relative position of the center of the floating view. Accepted values are between 0 and 1.</div>
<div><strong>sizeX &amp; sizeY</strong>: relative size of the floating view. Accepted values are between 0 and 1.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1)=double click allows swapping the floating view with the main view</div>
<div class=tab>bit1 set (2)=the floating view doesn't have a close button</div>
<div class=tab>bit2 set (4)=the floating view cannot be shifted</div>
<div class=tab>bit3 set (8)=the floating view cannot be resized</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the floating view, or -1 in case of an error. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number floatingViewHandle=sim.floatingViewAdd(number posX,number posY,number sizeX,number sizeY,number options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simFloatingViewRemove" id="simFloatingViewRemove"></a>simFloatingViewRemove / sim.floatingViewRemove </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a floating view previously added with <a href="#simFloatingViewAdd">sim.floatingViewAdd</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simFloatingViewRemove(simInt floatingViewHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>floatingViewHandle</strong>: handle of the floating view to be removed</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the floating view could not be found (e.g. because closed by the user), or 1 if the floating view was closed. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.floatingViewRemove(number floatingViewHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simFollowPath" id="simFollowPath"></a>simFollowPath / sim.followPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object along a path object. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simRMLPos">sim.rmlPos</a>, <a href="#simRMLVel">sim.rmlVel</a> and <a href="#simMoveToObject">sim.moveToObject</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft =sim.followPath(number objectHandle,number pathHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number accel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object to be moved<br>
</div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>positionAndOrOrientation</strong>: a value between 1 and 3 (1: only position is modified, 2: only orientation is modified, 3: position and orientation is modified). Can be nil in which case 3 is applied.<br>
</div>
<div><strong>relativeDistanceOnPath</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the <a href="pathPositionCalculationMethod.htm">path position calculation method</a> section).<br>
</div>
<div><strong>velocity</strong>: movement nominal velocity. </div>
<div><strong>accel</strong>: the acceleration/deceleration.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to follow the path is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGenerateIkPath" id="simGenerateIkPath"></a>simGenerateIkPath / sim.generateIkPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Generates a path that drives a robot from its current configuration to its target dummy in a straight line (i.e. shortest path in Cartesian space). The function returns NULL if the robot is not able to perform the movement with its end-effector, the reasons can be: there are collisions on the way, or some of the points on the line cannot be reached (e.g. out of reach, or due to joint limits)</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGenerateIkPath(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simInt ptCnt,simInt collisionPairCnt,const simInt* collisionPairs,const simInt* jointOptions,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as <em>explicit handling</em> if needed. See also <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.</div>
<div><strong>jointCnt</strong>: the number of joint handles provided in the <em>jointHandles</em> array.</div>
<div><strong>jointHandles</strong> (input): an array with <em>jointCnt</em> entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.</div>
<div><strong>ptCnt</strong>: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for <em>ptCnt</em> leads to better results for this function.</div>
<div><strong>collisionPairCnt</strong>: the number of collision pairs. Can be 0 if collision checking is not required.</div>
<div><strong>collisionPairs</strong>: an array containing 2 <a href="entities.htm">entity</a> handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an <a href="objects.htm">object</a> or a <a href="collections.htm">collection</a> handle. The collidee can be an object or collection handle, or <em>sim_handle_all</em>, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.</div>
<div><strong>jointOptions</strong>: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.</div>
<div><strong>reserved</strong>: reserved for future extension. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to the computed path, or NULL if no path could be computed. The pointer points to <em>ptCnt</em>*<em>jointCnt</em> values, representing <em>ptCnt</em> robot configurations. The user is in charge of releasing the returned array with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table path=sim.generateIkPath(number ikGroupHandle,table jointHandles,number ptCnt,table collisionPairs=nil,table jointOptions=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetApiFunc" id="simGetApiFunc"></a>simGetApiFunc / sim.getApiFunc</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves all API functions and variables that match a specific word. Useful for script code auto-completion functionality. See also <a href="#simGetApiInfo">sim.getApiInfo</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetApiFunc(simInt scriptHandleOrType,const simChar* apiWord)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandleOrType</strong>: the <a href="#simGetScriptAssociatedWithObject">handle of the script</a>, otherwise the <a href="apiConstants.htm#scriptTypes">type of the script</a>.</div>
<div><strong>apiWord</strong>: the word that API functions and variables should match, e.g. "sim.getObj". Only matches up to the first dot are returned, if the apiWord does not contain any dot. To retrieve all functions and variables, leave apiWord empty. To retrieve only functions, add '+' as prefix. To retrieve only variables, add '-' as prefix.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL in case of an error, or if there is no match. Otherwise all matching API functions and variables, space-separated. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table funcsAndVars=sim.getApiFunc(number scriptHandleOrType,string apiWord)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>funcsAndVars</strong>: nil in case of an error, otherwise a table containing all matching API functions and variables.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetApiInfo" id="simGetApiInfo"></a>simGetApiInfo / sim.getApiInfo</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the call tip (or info text) for an API function or variable. See also <a href="#simGetApiFunc">sim.getApiFunc</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetApiInfo(simInt scriptHandleOrType,const simChar* apiWord)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandleOrType</strong>: the <a href="#simGetScriptAssociatedWithObject">handle of the script</a>, otherwise the <a href="apiConstants.htm#scriptTypes">type of the script</a>.</div>
<div><strong>apiWord</strong>: the API functions or variable to retrieve the info for, e.g. "sim.getObjectHandle"</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL in case of an error, or if there is no information. Otherwise the information related to the API function or variable. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string info=sim.getApiInfo(number scriptHandleOrType,string apiWord)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to the C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetArrayParameter" id="simGetArrayParameter"></a>simGetArrayParameter / sim.getArrayParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves 3 values from an array. See the <a href="apiConstants.htm#arrayParameters">array parameter identifiers</a>. See also <a href="#simSetArrayParameter">sim.setArrayParameter</a>, <a href="#simGetBoolParameter">sim.getBoolParameter</a>, <a href="#simGetInt32Parameter">sim.getInt32Parameter</a>, <a href="#simGetFloatParameter">sim.getFloatParameter</a> and <a href="#simGetStringParameter">sim.getStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetArrayParameter(simInt parameter,simVoid* parameterValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#arrayParameters">array parameter identifier</a></div>
<div><strong>parameterValues</strong>: a simFloat pointer  (simVoid is kept for backward compatibility). The 3 values will be copied to that location</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table parameterValues=sim.getArrayParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>parameterValues</strong>: a table that holds the returned values, or nil in case of an error</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetArrayParameter">simxGetArrayParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetArrayParameter">simxGetArrayParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetBoolParameter" id="simGetBoolParameter"></a>simGetBoolParameter / sim.getBoolParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a boolean value. See the <a href="apiConstants.htm#booleanParameters">Boolean parameter identifiers</a>. See also <a href="#simSetBoolParameter">sim.setBoolParameter</a>, <a href="#simGetInt32Parameter">sim.getInt32Parameter</a>, <a href="#simGetFloatParameter">sim.getFloatParameter</a>, <a href="#simGetArrayParameter">sim.getArrayParameter</a> and <a href="#simGetStringParameter">sim.getStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetBoolParameter(simInt parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#booleanParameters">boolean parameter identifier</a></div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the parameter (0 or 1) or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean boolState=sim.getBoolParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>boolState</strong>: value of the Boolean parameter, or nil in case of an error</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetBoolParameter">simxGetBoolParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetBooleanParameter">simxGetBooleanParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetClosestPositionOnPath" id="simGetClosestPositionOnPath"></a>simGetClosestPositionOnPath / sim.getClosestPositionOnPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic relative position on a path that is closest to the specified point. The returned value is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simGetPathPosition">sim.getPathPosition</a>, <a href="#simGetPathLength">sim.getPathLength</a>, <a href="#simGetPositionOnPath">sim.getPositionOnPath</a> and <a href="#simGetOrientationOnPath">sim.getOrientationOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetClosestPositionOnPath(simInt pathHandle,simFloat* relativePosition,simFloat* pathPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativePosition</strong>: a point in coordinates (x, y and z) relative to the path object position</div>
<div><strong>pathPosition</strong>: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method).<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number positionOnPath=sim.getClosestPositionOnPath(number pathHandle,table_3 relativePosition)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativePosition</strong>: a table containing a point in relative coordinates (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>positionOnPath</strong>: the intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (value is dependent on the selected path length calculation method), or nil in case of an error. <br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetCollectionHandle" id="simGetCollectionHandle"></a>simGetCollectionHandle / sim.getCollectionHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a collection handle based on its name. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simCreateCollection">sim.createCollection</a>, <a href="#simAddObjectToCollection">sim.addObjectToCollection</a>, <a href="#simGetCollectionObjects">sim.getCollectionObjects</a> and <a href="#simIsHandleValid">sim.isHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetCollectionHandle(const simChar* collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionName</strong>: name of the collection.  If the name is appended by a &quot;@silentError&quot; suffix, then no error will be output if the collection does not exist.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the collection, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collectionHandle=sim.getCollectionHandle(string collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetCollectionHandle">simxGetCollectionHandle</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetCollectionHandle">simxGetCollectionHandle</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetCollectionName" id="simGetCollectionName"></a>simGetCollectionName / sim.getCollectionName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the name of a collection based on its handle. See also <a href="#simSetCollectionName">sim.setCollectionName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetCollectionName(simInt collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the name of the collection or NULL if an error occurred. The user is in charge of destroying the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string collectionName=sim.getCollectionName(number collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetCollectionObjects" id="simGetCollectionObjects"></a>simGetCollectionObjects / sim.getCollectionObjects </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the object handles that compose a given <a href="collections.htm">collection</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt* simGetCollectionObjects(simInt collectionHandle,simInt* objectCount)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection</div>
<div><strong>objectCount</strong>: pointer to a value receiving the number of returned object handles</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to n object handles, or NULL if an error occurred. The user is in charge of destroying the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table objectHandles=sim.getCollectionObjects(number collectionHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetCollisionHandle" id="simGetCollisionHandle"></a>simGetCollisionHandle / sim.getCollisionHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a collision object. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">sim.isHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetCollisionHandle(const simChar* collisionObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectName</strong>: name of the collision object.  If the name is appended by a &quot;@silentError&quot; suffix, then no error will be output if the collision object does not exist.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of collision object or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionObjectHandle=simGetCollisionObject(string collisionObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetCollisionHandle">simxGetCollisionHandle</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetCollisionHandle">simxGetCollisionHandle</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetConfigForTipPose" id="simGetConfigForTipPose"></a>simGetConfigForTipPose / sim.getConfigForTipPose </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Searches for a manipulator configuration that matches a given end-effector position/orientation in space. Search is randomized.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetConfigForTipPose(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simFloat thresholdDist,simInt maxTimeInMs,simFloat* retConfig,const simFloat* metric,simInt collisionPairCnt,const simInt* collisionPairs,const simInt* jointOptions,const simFloat* lowLimits,const simFloat* ranges,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as <em>explicit handling</em> if needed. See also <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.</div>
<div><strong>jointCnt</strong>: the number of joint handles provided in the <em>jointHandles</em> array.</div>
<div><strong>jointHandles</strong> (input): an array with <em>jointCnt</em> entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.</div>
<div><strong>thresholdDist</strong>: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a <em>metric</em>.</div>
<div><strong>maxTimeInMs</strong>: a maximum time in ms after which the search is aborted.</div>
<div><strong>retConfig</strong> (output): an array with <em>jointCnt</em> entries, that will receive the IK calculated joint values, as specified by the <em>jointHandles</em> array.</div>
<div><strong>metric</strong> (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.</div>
<div><strong>collisionPairCnt</strong>: the number of collision pairs. Can be 0 if collision checking is not required.</div>
<div><strong>collisionPairs</strong>: an array containing 2 <a href="entities.htm">entity</a> handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an <a href="objects.htm">object</a> or a <a href="collections.htm">collection</a> handle. The collidee can be an object or collection handle, or <em>sim_handle_all</em>, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.</div>
<div><strong>jointOptions</strong>: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.</div>
<div><strong>lowLimits</strong>: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then <em>ranges</em> should also not be NULL.</div>
<div><strong>ranges</strong>: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then <em>lowLimits</em> should also not be NULL.</div>
<div><strong>reserved</strong>: reserved for future extension. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if no result was found, otherwise 1.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table jointPositions=sim.getConfigForTipPose(number ikGroupHandle,table jointHandles,number distanceThreshold,number maxTimeInMs,table_4 metric=nil,table collisionPairs=nil,table jointOptions=nil,table lowLimits=nil,table ranges=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetConfigurationTree" id="simGetConfigurationTree"></a>simGetConfigurationTree / sim.getConfigurationTree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves configuration information for a hierarchy tree (object relative positions/orientations, joint/path values). Calling <a href="#simSetConfigurationTree">sim.setConfigurationTree</a> at a later time, will restore the object configuration (use this function to temporarily save object positions/orientations/joint/path values)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetConfigurationTree(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that is at the base of the tree (all objects built on top of this one (including this one)) will have their configuration retrieved. sim_handle_all will retrieve the configuration for the whole scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Configuration data if operation was successful, NULL otherwise. The returned data should be deleted with <a href="#simReleaseBuffer">simReleaseBuffer</a> when not used anymore<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number rawBufferHandle=sim.getConfigurationTree(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. In addition, child scripts can use the argument sim.handle_self to retrieved the configuration tree of the object that the child script is attached to<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a block of raw memory, or -1 in case of an error. Use that value to restore the configuration tree with <a href="#simSetConfigurationTree">sim.setConfigurationTree</a>. The raw buffer is attached to the script until the simulation ends, at which time it is automatically released. Alternatively, you can release that buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetContactInfo" id="simGetContactInfo"></a>simGetContactInfo / sim.getContactInfo </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves contact point information of a dynamic simulation pass. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetContactInfo(simInt dynamicPass,simInt objectHandle,simInt index,simInt* objectHandles,simFloat* contactInfo)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dynamicPass</strong>: a specific dynamic sub-step index or sim_handle_all. By default a call to <a href="#simHandleDynamics">simHandleDynamics</a> executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also <a href="#simGetInt32Parameter">simGetInt32Parameter</a>(sim_intparam_dynamic_step_divider).<br>
</div>
<div><strong>objectHandle</strong>: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.<br>
</div>
<div><strong>index</strong>: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)<br>
</div>
<div><strong>objectHandles</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.<br>
</div>
<div><strong>contactInfo</strong>: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if no contact was found at the given index or 1 if a contact was returned.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 collidingObjects,table_3 collisionPoint,table_3 reactionForce,table_3 normalVector=sim.getContactInfo(number dynamicPass,number objectHandle,number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>collidingObjects</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects</div>
<div><strong>collisionPoint</strong>: coordinates of the contact</div>
<div><strong>reactionForce</strong>: vector that represents the force generated by the contact</div>
<div><strong>normalVector</strong>: the normal vector at the contact point</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetCustomizationScriptAssociatedWithObject" id="simGetCustomizationScriptAssociatedWithObject"></a>simGetCustomizationScriptAssociatedWithObject / sim.getCustomizationScriptAssociatedWithObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a customization script's handle based on its associated object. See also <a href="#simGetObjectAssociatedWithScript">sim.getObjectAssociatedWithScript</a> and <a href="#simGetScriptAssociatedWithObject">sim.getScriptAssociatedWithObject</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetCustomizationScriptAssociatedWithObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that might have a customization script associated<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the customization script associated with the object, or -1 if the operation was not successful or the object doesn't have an associated script<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=sim.getCustomizationScriptAssociatedWithObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDataOnPath" id="simGetDataOnPath"></a>simGetDataOnPath / sim.getDataOnPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves interpolated user data along a path object. See also <a href="#simGetPositionOnPath">sim.getPositionOnPath</a>, <a href="#simGetOrientationOnPath">sim.getOrientationOnPath</a>, <a href="#simGetPathPosition">sim.getPathPosition</a> and <a href="#simGetClosestPositionOnPath">sim.getClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDataOnPath(simInt pathHandle,simFloat relativeDistance,simInt dataType,simInt* intData,simFloat* floatData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. See also <a href="#simGetPathLength">simGetPathLength</a>. In order to retrieve data that lies exactly on a specific path control point, specify following for <em>relativeDistance</em>: -ctrlPtIndex-1 (the value will be rounded appropriately).<br>
</div>
<div><strong>dataType</strong>: the type of the desired data. Keep 0.</div>
<div><strong>intData</strong>: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.</div>
<div><strong>floatData</strong>: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number auxFlags,table_4 auxChannels=sim.getDataOnPath(number pathHandle,number relativeDistance)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDecimatedMesh" id="simGetDecimatedMesh"></a>simGetDecimatedMesh / sim.getDecimatedMesh </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a decimated mesh (i.e. a simplified mesh). See also <a href="#simConvexDecompose">sim.convexDecompose</a> and <a href="#simGetQHull">sim.getQHull</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDecimatedMesh(const simFloat* inVertices,simInt inVerticesL,const simInt* inIndices,simInt inIndicesL,simFloat** verticesOut,simInt* verticesOutL,simInt** indicesOut,simInt* indicesOutL,simFloat decimationPercent,simInt reserved1,const simFloat* reserved2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>inVertices</strong>: a pointer to the input vertices (succession of x/y/z values).</div>
<div><strong>inVerticesL</strong>: the number of input vertices times 3.</div>
<div><strong>inIndices</strong>: a pointer to the input indices (3 values for each triangle).</div>
<div><strong>inIndicesL</strong>: the number of input triangles times 3.</div>
<div><strong>verticesOut</strong>: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>verticesOutL</strong>: a pointer to the number of output vertices times 3.</div>
<div><strong>indicesOut</strong>: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>indicesOutL</strong>: a pointer to the number of output indices (i.e. the number of triangles times 3).</div>
<div><strong>decimationPercent</strong>: the percentage of the desired decimation (0.1-0.9).</div>
<div><strong>reserved1</strong>: reserved, set to 0.</div>
<div><strong>reserved2</strong>: reserved, set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 or 0 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table verticesOut,table indicesOut=sim.getDecimatedMesh(table verticesIn,table indicesIn,number decimationPercentage)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>verticesIn</strong>: a table containing the input vertices (succession of x/y/z values).</div>
<div><strong>indicesIn</strong>: a table containing the input indices (3 values for each triangle).</div>
<div><strong>decimationPercentage</strong>: the percentage of the desired decimation (0.1-0.9).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>verticesOut</strong>: a table containing the output vertices (succession of x/y/z values).</div>
<div><strong>indicesOut</strong>: a table containing the output indices (3 values for each triangle).</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDialogInput" id="simGetDialogInput"></a>simGetDialogInput / sim.getDialogInput</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Queries the text of the edit box of a generic dialog box of style sim_dlgstyle_input. To be used after <a href="#simDisplayDialog">sim.displayDialog</a> was called and after <a href="#simGetDialogResult">sim.getDialogResult</a> returned sim.dlgret_ok<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetDialogInput(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of the generic dialog<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to a text buffer or NULL in case of an error. The user is in charge of releasing the returned string with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string input=sim.getDialogInput(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetDialogInput">simxGetDialogInput</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetDialogInput">simxGetDialogInput</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDialogResult" id="simGetDialogResult"></a>simGetDialogResult / sim.getDialogResult</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Queries the result of a dialog box. To be used after <a href="#simDisplayDialog">sim.displayDialog</a> was called<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDialogResult(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of the generic dialog<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#genericDialogReturnValues">result of the dialog</a> or -1 in case of an error.<br>
</div>
<br>
<div>Note. If the return value is sim_dlgret_still_open, the dialog was not closed and no button was pressed. Otherwise, you should free resources with <a href="#simEndDialog">simEndDialog</a> (the dialog might not be visible anymore, but is still present)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.getDialogResult(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetDialogResult">simxGetDialogResult</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetDialogResult">simxGetDialogResult</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDistanceHandle" id="simGetDistanceHandle"></a>simGetDistanceHandle / sim.getDistanceHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a distance object. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">sim.isHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDistanceHandle(const simChar* distanceObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectName</strong>: name of distance object.  If the name is appended by a &quot;@silentError&quot; suffix, then no error will be output if the distance object does not exist.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the distance object or -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number distanceObjectHandle=sim.getDistanceHandle(string distanceObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetDistanceHandle">simxGetDistanceHandle</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetDistanceHandle">simxGetDistanceHandle</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetDoubleSignal" id="simGetDoubleSignal"></a>simGetDoubleSignal / sim.getDoubleSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of a double signal. Signals are cleared at simulation start.  See also <a href="#simSetDoubleSignal">sim.setDoubleSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  and <a href="#simPersistentDataRead">sim.persistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDoubleSignal(const simChar* signalName,simDouble* signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number signalValue=sim.getDoubleSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>signalName</strong>: name of the signal</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal. nil if operation was not successful or if signal does not exist<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetFloatSignal">simxGetFloatSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetFloatSignal">simxGetFloatSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetEngineBoolParameter" id="simGetEngineBoolParameter"></a>simGetEngineBoolParameter / sim.getEngineBoolParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves a Boolean value from the physics engine properties. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simBool simGetEngineBoolParameter(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>ok</strong>: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the requested parameter. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean boolParam=sim.getEngineBoolParameter(number paramId,number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetEngineFloatParameter" id="simGetEngineFloatParameter"></a>simGetEngineFloatParameter / sim.getEngineFloatParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves a float value from the physics engine properties. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetEngineFloatParameter(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>ok</strong>: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the requested parameter. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number floatParam=sim.getEngineFloatParameter(number paramId,number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetEngineInt32Parameter" id="simGetEngineInt32Parameter"></a>simGetEngineInt32Parameter / sim.getEngineInt32Parameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves an int32 value from the physics engine properties. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetEngineInt32Parameter(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>ok</strong>: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the requested parameter. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number int32Param=sim.getEngineInt32Parameter(number paramId,number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetEulerAnglesFromMatrix" id="simGetEulerAnglesFromMatrix"></a>simGetEulerAnglesFromMatrix / sim.getEulerAnglesFromMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the <a href="eulerAngles.htm">Euler angles</a> from a transformation matrix. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetEulerAnglesFromMatrix(const simFloat* matrix,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>eulerAngles</strong>: pointer to 3 simFloat values representing the Euler angles of the matrix</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=sim.getEulerAnglesFromMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: table to 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not needed). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table to 3 numbers representing the Euler angles, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetExplicitHandling" id="simGetExplicitHandling"></a>simGetExplicitHandling / sim.getExplicitHandling </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the explicit handling flags for a general object. See also <a href="#simSetExplicitHandling">sim.setExplicitHandling</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetExplicitHandling(simInt generalObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalObjectHandle</strong>: handle of a general object. Can be a scene object, collision object, distance object, etc.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if command was not successful, otherwise the explicit handling flags for the specified general object (for now only bit 0 is used).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number explicitHandlingFlags=sim.getExplicitHandling(number generalObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function. See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetExtensionString" id="simGetExtensionString"></a>simGetExtensionString / sim.getExtensionString </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a string that describes additional environment or object properties, mainly used by extension plugins.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetExtensionString(simInt objectHandle,simInt index,const simChar* key)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: the handle of an object, or -1 if you wish to retrieve the extension string of the environment.</div>
<div><strong>index</strong>: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes).</div>
<div><strong>key</strong>: an optional key indicating what value to retrieve. If none is specified, then the whole extension string will be returned. Keys should have the form of <em>key@parentKey@...@parentKey</em>. To retrieve the <em>shadow enabled</em> value of extension string &quot;povray{ shadow {true} fadeXDist {0.00}}&quot;, specify following key: <em>shadow@povray</em>. The key is case sensitive.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a string if the operation was successful. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string theString=sim.getExtensionString(number objectHandle,number index,string key=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetFloatParameter" id="simGetFloatParameter"></a>simGetFloatParameter / sim.getFloatParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a floating point value. See the <a href="apiConstants.htm#floatingParameters">floating-point parameter identifiers</a>. See also <a href="#simSetFloatParameter">sim.setFloatParameter</a>, <a href="#simGetBoolParameter">sim.getBoolParameter</a>, <a href="#simGetInt32Parameter">sim.getInt32Parameter</a>, <a href="#simGetArrayParameter">sim.getArrayParameter</a> and <a href="#simGetStringParameter">sim.getStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetFloatParameter(simInt parameter,simFloat* floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#floatingParameters">floating parameter identifier</a></div>
<div><strong>floatState</strong>: value of the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parameterValue=sim.getFloatParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>parameter</strong>: parameter identifier (sim_floatparam_...)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>parameterValue</strong>: value of the parameter or nil in case of an error</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetFloatParameter">simxGetFloatParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetFloatingParameter">simxGetFloatingParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetIkGroupHandle" id="simGetIkGroupHandle"></a>simGetIkGroupHandle / sim.getIkGroupHandle </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an IK group. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">sim.isHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetIkGroupHandle(const simChar* ikGroupName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupName</strong>: name of an IK group.  If the name is appended by a &quot;@silentError&quot; suffix, then no error will be output if the IK group does not exist.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the IK group or -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number ikGroupHandle=sim.getIkGroupHandle(string ikGroupName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetIkGroupMatrix" id="simGetIkGroupMatrix"></a>simGetIkGroupMatrix / sim.getIkGroupMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr><div>Retrieves various information from an IK group, such as the Jacobian. For the result to be valid, the Jacobian must previously have been computed via the <a href="#simComputeJacobian">sim.computeJacobian</a>, <a href="#simHandleIkGroup">sim.handleIkGroup</a> or <a href="#simCheckIkGroup">sim.checkIkGroup</a> functions. Following situations have to be differentiated:</div>
<div class=tab><strong>a)</strong> If you call <a href="#simComputeJacobian">sim.computeJacobian</a> just before calling sim.getIkGroupMatrix, then the returned Jacobian will be the one at the current state/configuration of the mechanism. This is the recommended way to retrieve the Jacobian.</div>
<div class=tab><strong>b)</strong> If you call <a href="#simHandleIkGroup">sim.handleIkGroup</a> or <a href="#simCheckIkGroup">sim.checkIkGroup</a> just before calling sim.getIkGroupMatrix, then the returned Jacobian will be the one <strong>computed last, while trying to reach the target</strong> (since it usually takes at least 2-3 iterations to reach a target because of the linearization), which is not the current state/configuration of the mechanism, unless the target overlaps the tip.</div>
<div>See also <a href="#simGetIkGroupHandle">sim.getIkGroupHandle</a>.</div></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGetIkGroupMatrix(simInt ikGroupHandle,simInt options,simInt* matrixSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of an IK group</div>
<div><strong>options</strong>: a value indicating what kind of information to retrieve:</div>
<div class=tab>0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.</div>
<div class=tab>1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.</div>
<div><strong>matrixSize</strong>: the dimensions of the returned matrix (x=rows, y=columns)</div>

<br>
<div>USAGE EXAMPLE (to correctly interpret the Jacobian):</div>
<pre class=lightBlueBoxNoMarginAndSmall>
float jacobianSize[2];
float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);

// jacobianSize[0] represents the row count of the Jacobian 
// (i.e. the number of equations or the number of joints involved
// in the IK resolution of the given kinematic chain)
// Joints appear from tip to base.

// jacobianSize[1] represents the column count of the Jacobian 
// (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)

// The Jacobian data is ordered row-wise, i.e.:
// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.

for (int i=0;i&lt;jacobianSize[0];i++)
{
    std::string str;
    for (int j=0;j&lt;jacobianSize[1];j++)
    {
        if (str.size()==0)
            str+=", ";
        str+=boost::str(boost::format("%.1e") % jacobian[j*jacobianSize[0]+i]);
    }
    printf(str.c_str());
}</pre>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A pointer to x*y float values. The values should be copied since the pointer might not remain valid.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table matrix,table_2 matrixSize=sim.getIkGroupMatrix(number ikGroupHandle,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

<br>
<div>USAGE EXAMPLE (to correctly interpret the Jacobian):</div>
<pre class=lightRedBoxNoMarginAndSmall>
jacobian,jacobianSize=sim.getIkGroupMatrix(ikGroupHandle,0)

-- jacobianSize[1] represents the row count of the Jacobian 
-- (i.e. the number of equations or the number of joints involved
-- in the IK resolution of the given kinematic chain)
-- Joints appear from tip to base.

-- jacobianSize[2] represents the column count of the Jacobian 
-- (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency,etc.)

-- The Jacobian data is ordered row-wise, i.e.:
-- [row1,col1],[row2,col1],..,[rowN,col1],[row1,col2],[row2,col2],etc.

for i=1,jacobianSize[1],1 do
    str=''
    for j=1,jacobianSize[2],1 do
        if #str~=0 then
            str=str..', '
        end
        str=str..string.format("%.1e",jacobian[(j-1)*jacobianSize[1]+i])
    end
    print(str)
end</pre>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetInt32Parameter" id="simGetInt32Parameter"></a>simGetInt32Parameter / sim.getInt32Parameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an integer value. See the <a href="apiConstants.htm#integerParameters">integer parameter identifiers</a>. See also <a href="#simSetInt32Parameter">sim.setInt32Parameter</a>, <a href="#simGetBoolParameter">sim.getBoolParameter</a>, <a href="#simGetFloatParameter">sim.getFloatParameter</a>, <a href="#simGetArrayParameter">sim.getArrayParameter</a> and <a href="#simGetStringParameter">sim.getStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetInt32Parameter(simInt parameter,simInt* intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#integerParameters">integer parameter identifier</a></div>
<div><strong>intState</strong>: value of the parameter</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parameterValue=sim.getInt32Parameter(number parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>parameter</strong>: parameter identifier (sim_intparam_...)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet><div><strong>parameterValue</strong>: value of the parameter or nil in case of an error</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetIntParameter">simxGetIntParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetIntegerParameter">simxGetIntegerParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetIntegerSignal" id="simGetIntegerSignal"></a>simGetIntegerSignal / sim.getIntegerSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of an integer signal. Signals are cleared at simulation start.  See also <a href="#simSetIntegerSignal">sim.setIntegerSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  and <a href="#simPersistentDataRead">sim.persistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetIntegerSignal(const simChar* signalName,simInt* signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number signalValue=sim.getIntegerSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>signalName</strong>: name of the signal</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal. nil if operation was not successful or if signal does not exist<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetIntSignal">simxGetIntSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetIntegerSignal">simxGetIntegerSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointForce" id="simGetJointForce"></a>simGetJointForce / sim.getJointForce</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the force or torque applied to a joint  along/about its active axis. This function retrieves meaningful information only if the joint is prismatic or revolute, and is dynamically enabled. With the <a href="dynamicsModule.htm#bullet">Bullet</a> engine, this function returns the force or torque applied to the joint motor  (torques from joint limits are not taken into account). With the <a href="dynamicsModule.htm#ode">ODE</a> and <a href="dynamicsModule.htm#vortex">Vortex</a> engine, this function returns the total force or torque applied to a joint  along/about its z-axis. See also <a href="#simSetJointForce">sim.setJointForce</a> and <a href="#simReadForceSensor">sim.readForceSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointForce(simInt jointHandle,simFloat* forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint. Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_rawvalue</a> (simply add sim_handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="callbackFunctions.htm">callback function</a> triggered by the physics engine.</div>
<div><strong>forceOrTorque</strong>: the force or the torque applied to the joint  along/about its z-axis.
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if no value is available yet (e.g. when <a href="#simHandleDynamics">simHandleDynamics</a> hasn't yet handled that joint), otherwise a value &gt;0.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number forceOrTorque=sim.getJointForce(number jointHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>forceOrTorque</strong>: the force or the torque applied to the joint  along/about its z-axis, or nil in case of an error, or if no value is available yet.</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetJointForce">simxGetJointForce</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetJointForce">simxGetJointForce</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointInterval" id="simGetJointInterval"></a>simGetJointInterval / sim.getJointInterval </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the interval parameters of a joint. See also <a href="#simSetJointInterval">sim.setJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointInterval(simInt objectHandle,simBool* cyclic,simFloat* interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is &quot;cyclic&quot;, then the interval parameters don't have any meaning.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean cyclic,table_2 interval=sim.getJointInterval(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner). Is nil in case of an error.<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is &quot;cyclic&quot;, then the interval parameters don't have any meaning. Is nil in case of an error.<br>
</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointMatrix" id="simGetJointMatrix"></a>simGetJointMatrix / sim.getJointMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic transformation matrix of a joint (the transformation caused by the joint movement). See also <a href="#simSetSphericalJointMatrix">sim.setSphericalJointMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointMatrix(simInt objectHandle,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=sim.getJointMatrix(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>objectHandle</strong>: handle of the joint</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table of 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not returned), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: -</div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetJointMatrix">simxGetJointMatrix</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointMode" id="simGetJointMode"></a>simGetJointMode / sim.getJointMode </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the operation mode of a joint. See also <a href="#simSetJointMode">sim.setJointMode</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointMode(simInt jointHandle,simInt* options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint object</div>
<div><strong>options</strong> (output): bit-coded: if bit0 is set (1), the joint operates in hybrid mode.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the  <a href="apiConstants.htm#jointModes">joint mode</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number jointMode,number options=sim.getJointMode(number jointHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function. See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointPosition" id="simGetJointPosition"></a>simGetJointPosition / sim.getJointPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic position of a joint. This function cannot be used with spherical joints (use <a href="#simGetJointMatrix">sim.getJointMatrix</a> instead). See also <a href="#simSetJointPosition">sim.setJointPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointPosition(simInt objectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>position</strong>: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number position=sim.getJointPosition(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of the joint</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>position</strong>: intrinsic position of the joint or nil in case of an error</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetJointPosition">simxGetJointPosition</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetJointPosition">simxGetJointPosition</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointTargetPosition" id="simGetJointTargetPosition"></a>simGetJointTargetPosition / sim.getJointTargetPosition </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the target position of a joint. See also <a href="#simSetJointTargetPosition">sim.setJointTargetPosition</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointTargetPosition(simInt objectHandle,simFloat* targetPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetPosition</strong> (output): target position of the joint (angular or linear value depending on the joint type)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number targetPosition=sim.getJointTargetPosition(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>targetPosition</strong>: target position of the joint, or nil in case of an error.</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetJointTargetPosition">simxGetJointTargetPosition</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointTargetVelocity" id="simGetJointTargetVelocity"></a>simGetJointTargetVelocity / sim.getJointTargetVelocity 
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic target velocity of a non-spherical joint. See also <a href="#simSetJointTargetVelocity">sim.setJointTargetVelocity</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointTargetVelocity(simInt objectHandle,simFloat* targetVelocity)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetVelocity</strong> (output): target velocity of the joint (linear or angular velocity depending on the joint-type). </div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number targetVelocity=sim.getJointTargetVelocity(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>targetVelocity</strong>: target velocity of the joint, or -1 in case of an error.</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetJointTargetVelocity">simxGetJointTargetVelocity</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetJointType" id="simGetJointType"></a>simGetJointType / sim.getJointType </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the type of a joint 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointType(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Type of the joint (sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtype), or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number jointType=sim.getJointType(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetLastError" id="simGetLastError"></a>simGetLastError / sim.getLastError</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the last generated error message for the calling thread and/or script. By calling this function, the last error message is reset and a subsequent call to this function returns NULL. Errors are memorized on a thread- and/or script basis (e.g. each script have each an individual error handler, so does the C API functions (when the simulation thread and the GUI thread are differentiated)). See also <a href="#simSetLastError">simSetLastError</a>, <a href="#simGetStackTraceback">sim.getStackTraceback</a>, the <a href="apiConstants.htm#integerParameters">sim.intparam_error_report_mode</a> and the <a href="apiConstants.htm#errorReportModes">error report modes</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetLastError()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Error message buffer or NULL if no error message is present. The user has to delete the returned buffer with a call to <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string lastError=sim.getLastError()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: -</div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetLastErrors">simxGetLastErrors</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetLightParameters" id="simGetLightParameters"></a>simGetLightParameters / sim.getLightParameters </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves various parameters of a light object. See also <a href="#simSetLightParameters">sim.setLightParameters</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetLightParameters(simInt objectHandle,simFloat* setToNULL,simFloat* diffusePart,simFloat* specularPart)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the light</div>
<div><strong>setToNULL</strong>: not used, set to NULL</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part. Can be NULL</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise bit-coded: for now, only bit 0 is used: 1=light on<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number state,table_3 zero,table_3 diffusePart,table_3 specularPart=sim.getLightParameters(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the light</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>state</strong>: -1 in case of an error, otherwise bit-coded: for now, only bit 0 is used: 1=light on.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div><strong>zero</strong>: ignore this value</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetLinkDummy" id="simGetLinkDummy"></a>simGetLinkDummy / sim.getLinkDummy </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the object handle of the dummy linked to this one. See also <a href="#simSetLinkDummy">sim.setLinkDummy</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetLinkDummy(simInt dummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dummyHandle</strong>: handle of the dummy whose linked dummy has to be retrieved.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the dummy linked to the specified dummy object, or -1 if the dummy is not linked or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number linkedDummyHandle=sim.getLinkDummy(number dummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetMainWindow" id="simGetMainWindow"></a>simGetMainWindow</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle or pointer of the main window.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simGetMainWindow(simInt type)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>type</strong>: type of the desired return value. 0 for a native window handle, 1 for a pointer to a QWidget object.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a native window handle or  a pointer to a QWidget object.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetMatchingPersistentDataTags" id="simGetMatchingPersistentDataTags"></a>sim.getMatchingPersistentDataTags</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves  persistent data block tags that match a specific pattern. See also <a href="#simGetPersistentDataTags">sim.getPersistentDataTags</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>table tags=sim.getMatchingPersistentDataTags(string pattern)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>pattern</strong>: the pattern to match. e.g. &quot;LuaCommander\.options\.s&quot;.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>tags</strong>: a table containing the retrieved data block tags.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetModelProperty" id="simGetModelProperty"></a>simGetModelProperty / sim.getModelProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the properties of a model. See also <a href="#simSetModelProperty">sim.setModelProperty</a>, <a href="#simGetObjectProperty">sim.getObjectProperty</a> and <a href="#simGetObjectSpecialProperty">sim.getObjectSpecialProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetModelProperty(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that serves as the model base</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#modelProperties">model property values</a>, or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=sim.getModelProperty(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: -</div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetModelProperty">simxGetModelProperty</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetModuleInfo" id="simGetModuleInfo"></a>simGetModuleInfo / sim.getModuleInfo</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns auxiliary information about a loaded plugin. See also <a href="#simSetModuleInfo">simSetModuleInfo</a> and <a href="#simGetModuleName">sim.getModuleName</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetModuleInfo(const simChar* moduleName,simInt infoType,simChar** stringInfo,simInt* intInfo)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>moduleName</strong>: the name of the plugin. See <a href="#simGetModuleName">sim.getModuleName</a>.</div>
<div><strong>infoType</strong>: the type of information to retrieve:</div>
<div class=tab>0: <em>extended version string</em></div>
<div class=tab>1: <em>build date string</em></div>
<div class=tab>2: <em>extended version integer</em></div>
<div><strong>stringInfo</strong>: a pointer to a string information, in case the information type is for a string. The user is in charge of releasing the string buffer with <a href="#simReleaseBuffer">sim.releaseBuffer</a></div>
<div><strong>intInfo</strong>: a pointer to an integer information, in case the information type is for an integer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string/number info=sim.getModuleInfo(string moduleName,number infoType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to the C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetModuleName" id="simGetModuleName"></a>simGetModuleName / sim.getModuleName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a plugin name that was previously registered with <a href="#simLoadModule">sim.loadModule</a>. The simulator normally automatically loads and registers plugins present in the application directory. Users can use the sim.getModuleName to verify if a specific module is present<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetModuleName(simInt index,sumUChar* moduleVersion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: index to a module. To list-up all module names, start with index=0 and increment index until return value is NULL<br>
</div>
<div><strong>moduleVersion</strong>: version of the plugin. Can be NULL.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name of the module or NULL if no module is available at index position, or in case of an error. The user is in charge of destroying the returned name with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string moduleName,number moduleVersion=sim.getModuleName(number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>index</strong>: index to a module. To list-up all module names, start with index=0 and increment index until return value is nil<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>moduleName</strong>: name of the module or nil if no module is available at that index position, or in case of an error.<br>
</div>
<div><strong>moduleVersion</strong>: version of the plugin, or nil if moduleName is also nil<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetNameSuffix" id="simGetNameSuffix"></a>simGetNameSuffix / sim.getNameSuffix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the name suffix for an object name (e.g. &quot;myRobot#42&quot;'s name suffix is 42), or retrieves the name suffix set for the current script or for c/c++ API calls. See also <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and read the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetNameSuffix(const simChar* nameWithSuffix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>nameWithSuffix</strong>: full name (e.g. &quot;myRobot#42&quot;), or NULL to retrieve the name suffix for all c/c++ API calls<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name suffix of nameWithSuffix, or current name suffix for c/c++ API calls</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number nameSuffix,string name=sim.getNameSuffix(string nameWithSuffix): retieves the name suffix of nameWithSuffix<br>
</div>
<div>(2) number nameSuffix=sim.getNameSuffix(nil): retrieves the name suffix set for current script<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>nameWithSuffix</strong>: full name (e.g. &quot;myRobot#42&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>nameSuffix</strong>: name suffix (e.g. 42) of nameWithSuffix, or name suffix that is set for current script</div>
<div><strong>name</strong>: name without suffix (e.g. &quot;myRobot&quot;) or nil if the sim.getNameSuffix argument was nil</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetNavigationMode" id="simGetNavigationMode"></a>simGetNavigationMode / sim.getNavigationMode </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the navigation and selection mode for the mouse. See also <a href="#simSetNavigationMode">sim.setNavigationMode</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetNavigationMode()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#navigationModes">navigation mode</a> if operation was successful, -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number navigationMode=sim.getNavigationMode()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectAssociatedWithScript" id="simGetObjectAssociatedWithScript"></a>simGetObjectAssociatedWithScript / sim.getObjectAssociatedWithScript </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrives the handle of the object the script is attached to. See also <a href="#simGetScriptAssociatedWithObject">sim.getScriptAssociatedWithObject</a>, <a href="#simGetCustomizationScriptAssociatedWithObject">sim.getCustomizationScriptAssociatedWithObject</a> and <a href="#simAssociateScriptWithObject">sim.associateScriptWithObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectAssociatedWithScript(simInt scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the object that is associated with the script, or -1 if no object is associated with the script, or in case of an error.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.getObjectAssociatedWithScript (number scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>scriptHandle</strong>: handle of the script, or sim.handle_self for the handle of the current script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>objectHandle</strong>: handle of the object that the script is associated with, or -1 if the script is not associated (e.g. <a href="mainScript.htm">main scripts</a> or <a href="addOns.htm">add-ons</a> don't have associated objects) or in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectChild" id="simGetObjectChild"></a>simGetObjectChild / sim.getObjectChild</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an object's child object. See also <a href="#simGetObjectParent">sim.getObjectParent</a> and <a href="#simGetObjectsInTree">sim.getObjectsInTree</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectChild(simInt objectHandle,simInt index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>index</strong>: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of child object or -1 if the child doesn't exist at that index or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number childHandle=sim.getObjectChild(number objectHandle,number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectChild">simxGetObjectChild</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectChild">simxGetObjectChild</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectConfiguration" id="simGetObjectConfiguration"></a>simGetObjectConfiguration / sim.getObjectConfiguration </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves configuration information for an object (object relative position/orientation, joint/path value). See also <a href="#simSetObjectConfiguration">sim.setObjectConfiguration</a> and <a href="#simGetConfigurationTree">sim.getConfigurationTree</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectConfiguration(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to configuration data if operation was successful, NULL otherwise. The returned data should be deleted with <a href="#simReleaseBuffer">simReleaseBuffer</a> when not used anymore<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number rawBufferHandle=sim.getObjectConfiguration(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a raw data buffer, or -1 in case of an error. The raw buffer is attached to the script until the simulation ends, at which time it is automatically released. Alternatively, you can release that buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectFloatParameter" id="simGetObjectFloatParameter"></a>simGetObjectFloatParameter / sim.getObjectFloatParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a floating-point parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simSetObjectFloatParameter">sim.setObjectFloatParameter</a>, <a href="#simGetObjectInt32Parameter">sim.getObjectInt32Parameter</a> and <a href="#simGetObjectStringParameter">sim.getObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectFloatParameter(simInt objectHandle,simInt parameterID,simFloat* parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number parameter=sim.getObjectFloatParameter(number objectHandle,number parameterID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><span class="apiTableRightLSyn"><strong>result</strong></span>: -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful </div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectFloatParameter">simxGetObjectFloatParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectFloatParameter">simxGetObjectFloatParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectHandle" id="simGetObjectHandle"></a>simGetObjectHandle / sim.getObjectHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an object handle based on its name. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">sim.isHandleValid</a> and <a href="#simGetObjectUniqueIdentifier">sim.getObjectUniqueIdentifier</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectHandle(const simChar* objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectName</strong>: name of object. If the name is appended by a &quot;@alt&quot; suffix, then the object handle based on the object's alternative name will be retrieved. If the name is appended by a &quot;@silentError&quot; suffix, then no error will be output if the object does not exist.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of object or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.getObjectHandle(string objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectHandle">simxGetObjectHandle</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectHandle">simxGetObjectHandle</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectInt32Parameter" id="simGetObjectInt32Parameter"></a>simGetObjectInt32Parameter / sim.getObjectInt32Parameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an int32 parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simSetObjectInt32Parameter">sim.setObjectInt32Parameter</a>, <a href="#simGetObjectFloatParameter">sim.getObjectFloatParameter</a> and <a href="#simGetObjectStringParameter">sim.getObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectInt32Parameter(simInt objectHandle,simInt parameterID,simInt* parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number parameter=sim.getObjectInt32Parameter(number objectHandle,number parameterID)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
<div><strong>parameter</strong>: retrieved parameter.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectIntParameter">simxGetObjectIntParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectIntParameter">simxGetObjectIntParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectMatrix" id="simGetObjectMatrix"></a>simGetObjectMatrix / sim.getObjectMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the transformation matrix of an object. See also <a href="#simSetObjectMatrix">sim.setObjectMatrix</a>, <a href="#simGetObjectPosition">sim.getObjectPosition</a>, <a href="#simGetObjectOrientation">sim.getObjectOrientation</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectMatrix(simInt objectHandle,simInt relativeToObjectHandle,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.<br>
</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)<br>
</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=sim.getObjectMatrix(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim.handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>matrix</strong>: table of 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not returned), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectMatrix">simxGetObjectMatrix</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectName" id="simGetObjectName"></a>simGetObjectName / sim.getObjectName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the name of an object based on its handle. See also <a href="#simSetObjectName">sim.setObjectName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectName(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object. By adding <em>sim.handleflag_altname</em> to the object handle, the object alternative name can be retrieved.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name (or alternative name) of the object if operation was successful, NULL otherwise. The user is in charge of destroying the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string objectName=sim.getObjectName(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectName">simxGetObjectName</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectOrientation" id="simGetObjectOrientation"></a>simGetObjectOrientation / sim.getObjectOrientation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the orientation (<a href="eulerAngles.htm">Euler angles</a>) of an object. See also <a href="#simGetObjectQuaternion">sim.getObjectQuaternion</a>, <a href="#simSetObjectOrientation">sim.setObjectOrientation</a>, <a href="#simGetObjectPosition">sim.getObjectPosition</a>, <a href="#simGetObjectMatrix">sim.getObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectOrientation(simInt objectHandle,simInt relativeToObjectHandle,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.<br>
</div>
<div><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=sim.getObjectOrientation(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table of 3 values (Euler angles) or nil in case of an error</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectOrientation">simxGetObjectOrientation</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectOrientation">simxGetObjectOrientation</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectParent" id="simGetObjectParent"></a>simGetObjectParent / sim.getObjectParent</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an object's parent object. See also <a href="#simSetObjectParent">sim.setObjectParent</a> and <a href="#simGetObjectChild">sim.getObjectChild</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectParent(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of parent or -1 if the parent doesn't exist or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parentHandle=sim.getObjectParent(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectParent">simxGetObjectParent</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectParent">simxGetObjectParent</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectPosition" id="simGetObjectPosition"></a>simGetObjectPosition / sim.getObjectPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the position of an object. See also <a href="#simSetObjectPosition">sim.setObjectPosition</a>, <a href="#simGetObjectOrientation">sim.getObjectOrientation</a>, <a href="#simGetObjectMatrix">sim.getObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectPosition(simInt objectHandle,simInt relativeToObjectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.<br>
</div>
<div><strong>position</strong>: pointer to 3 values (x, y and z)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 position=sim.getObjectPosition(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>position</strong>: table of 3 values (x, y and z) or nil in case of an error</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectPosition">simxGetObjectPosition</a>, <a href="b0RemoteApi-cpp.htm#simxGetObjectPose">simxGetObjectPose</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectPosition">simxGetObjectPosition</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectProperty" id="simGetObjectProperty"></a>simGetObjectProperty / sim.getObjectProperty </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the main properties of a scene object. See also <a href="#simSetObjectProperty">sim.setObjectProperty</a>, <a href="#simGetObjectSpecialProperty">sim.getObjectSpecialProperty</a> and <a href="#simGetModelProperty">sim.getModelProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectProperty(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#sceneObjectProperties">object property values</a>, -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=sim.getObjectProperty(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectQuaternion" id="simGetObjectQuaternion"></a>simGetObjectQuaternion / sim.getObjectQuaternion </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the quaternion (x,y,z,w) of an object. See also <a href="#simGetObjectOrientation">sim.getObjectOrientation</a>, <a href="#simGetObjectMatrix">sim.getObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectQuaternion(simInt objectHandle,simInt relativeToObjectHandle,simFloat* quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.<br>
</div>
<div><strong>quaternion</strong>: the quaternion (x,y,z,w)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_4 quaternion=sim.getObjectQuaternion(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectQuaternion">simxGetObjectQuaternion</a>, <a href="b0RemoteApi-cpp.htm#simxGetObjectPose">simxGetObjectPose</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectQuaternion">simxGetObjectQuaternion</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectSelection" id="simGetObjectSelection"></a>simGetObjectSelection / sim.getObjectSelection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves all selected object's handles. See also <a href="#simGetObjectSelectionSize">simGetObjectSelectionSize</a>, <a href="#simAddObjectToSelection">sim.addObjectToSelection</a> and <a href="#simRemoveObjectFromSelection">sim.removeObjectFromSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSelection(simInt* objectHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandles</strong>: pointer to object handles. Make sure to have at least <a href="#simGetObjectSelectionSize">simGetObjectSelectionSize</a> simInts available<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size of the selection (&gt;=0) if operation was successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table selectedObjectHandles=sim.getObjectSelection()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>selectedObjectHandles</strong>: table containing the handles of all selected objects, or nil if no object is selected or in case of an error <br>
</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectSelection">simxGetObjectSelection</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectSelection">simxGetObjectSelection</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectSelectionSize" id="simGetObjectSelectionSize"></a>simGetObjectSelectionSize</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the size of the object selection. See also <a href="#simGetObjectSelection">sim.getObjectSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSelectionSize()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size of the selection, or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectSizeFactor" id="simGetObjectSizeFactor"></a>simGetObjectSizeFactor / sim.getObjectSizeFactor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the size factor of a scene object. The size factor is different from the real object size. Use this to be able to react to scaling operations. See also <a href="#simGetObjectSizeValues">sim.getObjectSizeValues</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetObjectSizeFactor(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size factor or negative value in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sizeFactor=sim.getObjectSizeFactor(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectSizeValues" id="simGetObjectSizeValues"></a>simGetObjectSizeValues / sim.getObjectSizeValues </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the x, y and z size values of a scene object. The size values are different from the real object sizes. Use this to be able to react to scaling operations. See also <a href="#simSetObjectSizeValues">sim.setObjectSizeValues</a> and <a href="#simGetObjectSizeFactor">sim.getObjectSizeFactor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSizeValues(simInt objectHandle,simFloat* sizeValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object</div>
<div><strong>sizeValues (output)</strong>: a pointer to 3 size values (x, y and z)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 sizeValues=sim.getObjectSizeValues(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectSpecialProperty" id="simGetObjectSpecialProperty"></a>simGetObjectSpecialProperty / sim.getObjectSpecialProperty </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the special properties of a scene object. See also <a href="#simSetObjectSpecialProperty">sim.setObjectSpecialProperty</a>, <a href="#simGetObjectProperty">sim.getObjectProperty</a> and <a href="#simGetModelProperty">sim.getModelProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSpecialProperty(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#sceneObjectSpecialProperties">object special property values</a>, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=sim.getObjectSpecialProperty(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.  See also the <a href="apiFunctionListCategory.htm#luaBool">boolean operators in Lua</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectStringParameter" id="simGetObjectStringParameter"></a>simGetObjectStringParameter / sim.getObjectStringParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a string parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simSetObjectStringParameter">sim.setObjectStringParameter</a>, <a href="#simGetObjectInt32Parameter">sim.getObjectInt32Parameter</a> and <a href="#simGetObjectFloatParameter">sim.getObjectFloatParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectStringParameter(simInt objectHandle,simInt parameterID,simInt* parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameterLength</strong>: the length of the retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A buffer containing the retrieved string, or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. The returned buffer might contain embedded zeros, and its length is specified by the parameterLength argument.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string parameter=sim.getObjectStringParameter(number objectHandle,number parameterID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectStringParameter">simxGetObjectStringParameter</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectType" id="simGetObjectType"></a>simGetObjectType / sim.getObjectType </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the type of an object 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectType(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>type of the object (sim_object_shape_type, sim_object_joint_type, etc. (see the <a href="apiConstants.htm#sceneObjectTypes">object types</a>) or -1 in case of error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectType=sim.getObjectType(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectUniqueIdentifier" id="simGetObjectUniqueIdentifier"></a>simGetObjectUniqueIdentifier / sim.getObjectUniqueIdentifier </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an object's unique identifier (an object handle is unique, but not across opened scenes. Additionally, if a huge amount of objects are created/destroyed (&gt;2000000), then handles of destroyed objects will be reused. This is not the case with unique identifiers).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectUniqueIdentifier(simInt objectHandle,simInt* uniqueIdentifier)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle, or sim_handle_all to retrieve all object identifiers<br>
</div>
<div><strong>uniqueIdentifier</strong>: pointer to the unique identifier, or if sim_handle_all is specified as the object handle, then the pointer points to several values. The user is in charge of reserving the buffer (size 1 if handle is specified, or number of objects in the scene if sim_handle_all is specified)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number uniqueId=sim.getObjectUniqueIdentifier(number objectHandle)</div>
<div>(2) table uniqueIds=sim.getObjectUniqueIdentifier(sim.handle_all)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>(1) <strong>uniqueId</strong>: the unique identifier or nil in case of an error</div>
<div>(2) <strong>uniqueIds</strong>: a table containing the unique identifiers or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectVelocity" id="simGetObjectVelocity"></a>simGetObjectVelocity / sim.getObjectVelocity</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the linear and/or angular velocity of an object, in absolute coordinates. The velocity is a measured velocity (i.e. from one simulation step to the next), and is available for all objects in the scene. See also <a href="#simGetVelocity">sim.getVelocity</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectVelocity(simInt objectHandle,simFloat* linearVelocity,simFloat* angularVelocity)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a <a href="objects.htm">scene object</a>. It is recommended to add <em><a href="apiConstants.htm#specialHandleFlags">sim.handleflag_axis</a></em> to the object handle, in order to obtain the <em>regular</em> angular velocity for the object, i.e. the rotation axis and the rotation velocity that is represented by the axis' length.</div>
<div><strong>linearVelocity</strong>: pointer to 3 values that will receive the linear velocity. Can be NULL</div>
<div><strong>angularVelocity</strong>: pointer to 3 values that will receive the angular velocity. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 linearVelocity,table_3 angularVelocity=sim.getObjectVelocity(number shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>linearVelocity</strong>: table containing 3 values that represent the linear velocity, or nil in case of an error<br>
</div>
<div><strong>angularVelocity</strong>: table containing 3 values that represent the angular velocity, or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectVelocity">simxGetObjectVelocity</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjectVelocity">simxGetObjectVelocity</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjects" id="simGetObjects"></a>simGetObjects / sim.getObjects</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves object handles. Use this in a loop where index starts at 0 and is incremented to get all object handles in the scene. See also <a href="#simGetObjectsInTree">sim.getObjectsInTree</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjects(simInt index,simInt objectType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: object index (not handle!). First object is located at index 0</div>
<div><strong>objectType</strong>: object type (sim_object_shape_type, sim_object_joint_type, etc. (see the <a href="apiConstants.htm#sceneObjectTypes">object types</a>) or sim_handle_all for any type of object<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the object or -1 if no object is located at that index or in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=sim.getObjects(number index,number objectType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjects">simxGetObjects</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetObjects">simxGetObjects</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetObjectsInTree" id="simGetObjectsInTree"></a>simGetObjectsInTree / sim.getObjectsInTree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves object handles in a given hierarchy tree. See also <a href="#simGetObjects">sim.getObjects</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt* simGetObjectsInTree(simInt treeBaseHandle,simInt objectType,simInt options,simInt* objectCount)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>treeBaseHandle</strong>: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.</div>
<div><strong>objectType</strong>: the <a href="apiConstants.htm#sceneObjectTypes">object type</a> to retrieve or sim_handle_all for any type of object in the tree</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): exclude the tree base from the returned array</div>
<div class=tab>bit1 set (2): include in the returned array only the object's first children. If <strong>treeBaseHandle</strong> is sim_handle_scene, then only parentless objects will be included.</div>
<div><strong>objectCount (out value)</strong>: the number of returned object handles</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to an array containing object handles, or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table objects=sim.getObjectsInTree(number treeBaseHandle,number objectType=sim.handle_all, number options=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetObjectsInTree">simxGetObjectsInTree</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetOctreeVoxels" id="simGetOctreeVoxels"></a>simGetOctreeVoxels / sim.getOctreeVoxels </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves voxel positions from an <a href="octrees.htm">octree</a>. See also the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>const float* simGetOctreeVoxels(simInt octreeHandle,simInt* ptCnt,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>ptCnt</strong>: a pointer receiving the number of voxels contained in the returned pointer.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or if the octree doesn't contain any voxels. Otherwise a pointer to the voxel X/Y/Z positions, relative to the octree reference frame</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table voxels=sim.getOctreeVoxels(number octreeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetOrientationOnPath" id="simGetOrientationOnPath"></a>simGetOrientationOnPath / sim.getOrientationOnPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the absolute interpolated orientation of a point along a path object. See also <a href="#simGetPositionOnPath">sim.getPositionOnPath</a>, <a href="#simGetPathPosition">sim.getPathPosition</a> and <a href="#simGetClosestPositionOnPath">sim.getClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetOrientationOnPath(simInt pathHandle,simFloat relativeDistance,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the <a href="pathPositionCalculationMethod.htm">path position calculation method</a> section). See also <a href="#simGetPathLength">simGetPathLength</a>. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for <em>relativeDistance</em>: -ctrlPtIndex-1 (the value will be rounded appropriately).<br>
</div>
<div><strong>eulerAngles</strong>: <a href="eulerAngles.htm">Euler angles</a> (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=sim.getOrientationOnPath (number pathHandle,number relativeDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. See also <a href="#simGetPathLength">sim.getPathLength</a>. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for <em>relativeDistance</em>: -ctrlPtIndex-1 (the value will be rounded appropriately).<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table of 3 values (alpha, beta and gamma) or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPage" id="simGetPage"></a>simGetPage / sim.getPage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the current page index (view). See also <a href="#simSetPage">sim.setPage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>page index or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number pageIndex=sim.getPage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPathLength" id="simGetPathLength"></a>simGetPathLength / sim.getPathLength </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the length of a path object. The length is given in meters, but the actual returned length is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simGetPathPosition">sim.getPathPosition</a> and <a href="#simSetPathPosition">sim.setPathPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPathLength(simInt objectHandle,simFloat* length)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>length</strong>: length of the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number length=sim.getPathLength(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>length</strong>: length of the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>), or nil in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPathPosition" id="simGetPathPosition"></a>simGetPathPosition / sim.getPathPosition </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic position of a path object (a distance along the path). The position is given in meters, but the actual returned position is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simSetPathPosition">sim.setPathPosition</a>, <a href="#simGetPathLength">sim.getPathLength</a>, <a href="#simGetPositionOnPath">sim.getPositionOnPath</a> and <a href="#simGetClosestPositionOnPath">sim.getClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPathPosition(simInt objectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number position=sim.getPathPosition(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>), or nil in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPersistentDataTags" id="simGetPersistentDataTags"></a>simGetPersistentDataTags / sim.getPersistentDataTags</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves all persistent data block tags or names. See also <a href="#simGetMatchingPersistentDataTags">sim.getMatchingPersistentDataTags</a> and <a href="#simPersistentDataRead">sim.persistentDataRead</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetPersistentDataTags(simInt* tagCount)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tagCount</strong>: the number of retrieved data block tags</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or no data block exists. Otherwise the data block tags, separated by the '\0' char. In that case the returned buffer should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>table tags=sim.getPersistentDataTags()</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>tags</strong>: a table containing the retrieved data block tags.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPointCloudOptions" id="simGetPointCloudOptions"></a>simGetPointCloudOptions / sim.getPointCloudOptions </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets various properties of a <a href="pointClouds.htm">point cloud</a>. See also <a href="#simSetPointCloudOptions">sim.setPointCloudOptions</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPointCloudOptions(simInt pointCloudHandle,simFloat* maxVoxelSize,simInt* maxPtCntPerVoxel,simInt* options,simFloat* pointSize,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>maxVoxelSize</strong>: the maximum size of the octree voxels containing points</div>
<div><strong>maxPtCntPerVoxel</strong>: the maximum number of points allowed in a same octree voxel</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): points have random colors</div>
<div class=tab>bit1 set (2): show octree structure</div>
<div class=tab>bit2 set (4): reserved. keep unset</div>
<div class=tab>bit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="collidableObjects.htm">collidable</a>, <a href="measurableObjects.htm">measurable</a> or <a href="detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</div>
<div class=tab>bit4 set (16): color is emissive</div>
<div><strong>pointSize</strong>: the size of the points, in pixels</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize=sim.getPointCloudOptions(number pointCloudHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPointCloudPoints" id="simGetPointCloudPoints"></a>simGetPointCloudPoints / sim.getPointCloudPoints </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves point positions from a <a href="pointClouds.htm">point cloud</a>. See also the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>const float* simGetPointCloudPoints(simInt pointCloudHandle,simInt* ptCnt,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>ptCnt</strong>: a pointer receiving the number of points contained in the returned pointer.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or if the point cloud doesn't contain any points. Otherwise a pointer to the point X/Y/Z positions, relative to the point cloud reference frame</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table points=sim.getPointCloudPoints(number pointCloudHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetPositionOnPath" id="simGetPositionOnPath"></a>simGetPositionOnPath / sim.getPositionOnPath </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the absolute interpolated position of a point along a path object. See also <a href="#simGetOrientationOnPath">sim.getOrientationOnPath</a>, <a href="#simGetDataOnPath">sim.getDataOnPath</a>, <a href="#simGetPathPosition">sim.getPathPosition</a> and <a href="#simGetClosestPositionOnPath">sim.getClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPositionOnPath(simInt pathHandle,simFloat relativeDistance,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. See also <a href="#simGetPathLength">simGetPathLength</a>.  In order to retrieve the position that lies exactly on a specific path control point, specify following for <em>relativeDistance</em>: -ctrlPtIndex-1 (the value will be rounded appropriately).<br>
</div>
<div><strong>position</strong>: pointer to 3 values (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 position=sim.getPositionOnPath (number pathHandle,number relativeDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. See also <a href="#simGetPathLength">sim.getPathLength</a>.  In order to retrieve the position that lies exactly on a specific path control point, specify following for <em>relativeDistance</em>: -ctrlPtIndex-1 (the value will be rounded appropriately).<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>position</strong>: table of 3 values (x, y and z) or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetQHull" id="simGetQHull"></a>simGetQHull / sim.getQHull </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the convex hull mesh from the specified vertices. See also <a href="#simConvexDecompose">sim.convexDecompose</a> and <a href="#simGetDecimatedMesh">sim.getDecimatedMesh</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetQHull(const simFloat* inVertices,simInt inVerticesL,simFloat** verticesOut,simInt* verticesOutL,simInt** indicesOut,simInt* indicesOutL,simInt reserved1,const simFloat* reserved2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>inVertices</strong>: a pointer to the input vertices (succession of x/y/z values).</div>
<div><strong>inVerticesL</strong>: the number of input vertices times 3.</div>
<div><strong>verticesOut</strong>: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>verticesOutL</strong>: a pointer to the number of output vertices times 3.</div>
<div><strong>indicesOut</strong>: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>indicesOutL</strong>: a pointer to the number of output indices (i.e. the number of triangles times 3).</div>
<div><strong>reserved1</strong>: reserved, set to 0.</div>
<div><strong>reserved2</strong>: reserved, set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 or 0 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table verticesOut,table indicesOut=sim.getQHull(table verticesIn)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>verticesIn</strong>: a table containing the input vertices (succession of x/y/z values).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>verticesOut</strong>: a table containing the output vertices (succession of x/y/z values).</div>
<div><strong>indicesOut</strong>: a table containing the output indices (3 values for each triangle).</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetQuaternionFromMatrix" id="simGetQuaternionFromMatrix"></a>simGetQuaternionFromMatrix / sim.getQuaternionFromMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the quaternion from a transformation matrix. See also <a href="#simGetEulerAnglesFromMatrix">sim.getEulerAnglesFromMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetQuaternionFromMatrix(const simFloat* matrix,simFloat* quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>quaternion</strong>: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_4 quaternion=sim.getQuaternionFromMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: table to 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not needed). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>quaternion</strong>: table of 4 numbers representing the quaternion, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetRandom" id="simGetRandom"></a>sim.getRandom</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Generates a random value in the range between 0 and 1. The value is generated from an individual generator attach to the calling script (i.e. scripts do not share a common generator as is the case with Lua's <em>math.random</em> function). <em>sim.getRandom</em> has however also been wrapped inside of two new Lua functions, in order to mimic Lua's <em>math.random</em> and <em>math.randomseed</em>:
<br>
<pre class=lightRedBoxNoMarginAndSmall>
function math.random2(lower,upper)
    local r=sim.getRandom()
    if lower then
        local b=1
        local d
        if upper then
            b=lower
            d=upper-b
        else
            d=lower-b
        end
        local e=d/(d+1)
        r=b+math.floor(r*d/e)
    end
    return r
end

function math.randomseed2(seed)
    sim.getRandom(seed)
end</pre>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number randomValue=sim.getRandom(number seed=nil)
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>seed</strong>: an optional number that can be used to seed/reseed the random number generator. Leave empty or set to nil if the generator should not be reseeded.</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>randomValue</strong>: a random number in the range of 0 and 1, or nil if operation was not successful</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetRealTimeSimulation" id="simGetRealTimeSimulation"></a>simGetRealTimeSimulation / sim.getRealTimeSimulation </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether the simulation is real-time. See also <a href="#simIsRealTimeSimulationStepNeeded">simIsRealTimeSimulationStepNeeded</a> and <a href="#simAdjustRealTimeTimer">simAdjustRealTimeTimer</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetRealTimeSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if simulation is real-time, 0 if it is not, and -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.getRealTimeSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetReferencedHandles" id="simGetReferencedHandles"></a>simGetReferencedHandles / sim.getReferencedHandles </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves a list of custom handles, linking a given object to other objects. See also <a href="#simSetReferencedHandles">sim.setReferencedHandles</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetReferencedHandles(simInt objectHandle,simInt** referencedHandles,simInt** reserved1,simInt** reserved2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object that stores the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved.</div>
<div><strong>referencedHandles</strong>: a pointer to a pointer that will be allocated and receive the list of handles. The user is in charge of releasing that buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups and collections.</div>
<div><strong>reserved1</strong>: reserved for future extensions</div>
<div><strong>reserved2</strong>: reserved for future extensions</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error. Otherwise, the number of handles returned.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table referencedHandles=sim.getReferencedHandles(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the  C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to the  C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetRotationAxis" id="simGetRotationAxis"></a>simGetRotationAxis / sim.getRotationAxis </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an axis and rotation angle that brings one transformation matrix onto another one. The translation part of the transformation matrices is ignored. This function, when used in combination with <a href="#simRotateAroundAxis">sim.rotateAroundAxis</a>, can be used to build interpolations between transformation matrices. See also <a href="#simGetObjectMatrix">sim.getObjectMatrix</a>, <a href="#simSetObjectMatrix">sim.setObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetRotationAxis(const simFloat* matrixStart,const simFloat* matrixGoal,simFloat* axis,simFloat* angle)  <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixStart</strong>: the <em>start</em> transformation matrix</div>
<div><strong>matrixGoal</strong>: the <em>goal</em> transformation matrix</div>
<div><strong>axis</strong>: the returned rotation axis in absolute coordinates</div>
<div><strong>angle</strong>: the returned rotation angle</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 axis,number angle=sim.getRotationAxis(table_12 matrixStart,table_12 matrixGoal)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>axis</strong>: the rotation axis in absolute coordinates, or nil in case of an error</div>
<div><strong>angle</strong>: the rotation angle, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScaledImage" id="simGetScaledImage"></a>simGetScaledImage / sim.getScaledImage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Generates a scaled-up or scaled down version of the input image. See also <a href="#simTransformImage">sim.transformImage</a>, <a href="#simLoadImage">sim.loadImage</a>, <a href="#simSaveImage">sim.saveImage</a> and <a href="#simSetVisionSensorCharImage">sim.setVisionSensorCharImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simUChar* simGetScaledImage(const simUChar* imageIn,const simInt* resolutionIn,const simInt* resolutionOut,simInt options,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>imageIn</strong>: a pointer to rgb or rgba values of the input image.</div>
<div><strong>resolutionIn</strong>: the resolution of the input image.</div>
<div><strong>resolutionOut</strong>: the desired resolution of the output image. The values will be replaced by the effective resolution of the output image</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): the input image is rgba, otherwise it is rgb</div>
<div class=tab>bit1 set (2): the returned image is rgba, otherwise it is rgb</div>
<div class=tab>bit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)</div>
<div class=tab>bit4 set (16): no smooth transformation</div>
<div><strong>reserved</strong>: Reserved for future extension. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful, otherwise a buffer containing the output image data. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string imageOut,table_2 effectiveRolutionOut=sim.getScaledImage(string imageIn,table_2 resolutionIn,table_2 desiredResolutionOut,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScript" id="simGetScript"></a>simGetScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves script handles. Use this in a loop where index starts at 0 and is incremented to get all script handles. See also <a href="#simGetScriptHandle">sim.getScriptHandle</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScript(simInt index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: script index (not handle). First script is located at index 0<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of a script if function was successful and a script exists at the given index, or -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptAssociatedWithObject" id="simGetScriptAssociatedWithObject"></a>simGetScriptAssociatedWithObject / sim.getScriptAssociatedWithObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a child script's handle based on its associated object. See also <a href="#simGetObjectAssociatedWithScript">sim.getObjectAssociatedWithScript</a>, <a href="#simGetCustomizationScriptAssociatedWithObject">sim.getCustomizationScriptAssociatedWithObject</a> and <a href="#simAssociateScriptWithObject">sim.associateScriptWithObject</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptAssociatedWithObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that might have a child script associated<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the child script associated with the object, or -1 if the operation was not successful or the object doesn't have an associated script<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=sim.getScriptAssociatedWithObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptAttribute" id="simGetScriptAttribute"></a>simGetScriptAttribute / sim.getScriptAttribute </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads various script attributes or properties. See also <a href="#simSetScriptAttribute">sim.setScriptAttribute</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptAttribute(simInt scriptHandle,simInt attributeID,simFloat* floatVal,simInt* intOrBoolVal)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div><strong>attributeID</strong>: the <a href="apiConstants.htm#scriptAttributes">script attributeID</a></div>
<div><strong>floatVal</strong>: pointer to a floating point value, receiving the floating point attribute (if applicable)</div>
<div><strong>intOrBoolVal</strong>: pointer to an integer value, receiving the integer or Boolean attribute (if applicable)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number/boolean attribute=sim.getScriptAttribute(number scriptHandle,number attributeID)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>attribute</strong>: the requested attribute value</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptExecutionCount" id="simGetScriptExecutionCount"></a>simGetScriptExecutionCount / sim.getScriptExecutionCount </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the number of times the current script was called and returned. See also <a href="#simGetSimulationState">sim.getSimulationState</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number executionCount=sim.getScriptExecutionCount()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>executionCount</strong>: number of times the current script was called and returned, or -1 in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptHandle" id="simGetScriptHandle"></a>simGetScriptHandle / sim.getScriptHandle </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a script. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">sim.getNameSuffix</a>, <a href="#simSetNameSuffix">sim.setNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). A script doesn't directly have a name assigned, however the script inherits the name of its associated object, if it has one. See also <a href="#simIsHandleValid">sim.isHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptHandle(const simChar* scriptName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptName</strong>: name of the script. The name of a child script. If the name is left blank, the handle of the main script is retrieved. In order to retrieve the handle of a customization script, use following scriptName prefix: <em>customization@</em> (for instance, <em>customization@objectName</em>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the script if operation was successful, -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=sim.getScriptHandle(string scriptName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. Alternatively, scriptName can be sim.handle_self, nil or inexistent, in which case the current script's handle is returned<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptName" id="simGetScriptName"></a>simGetScriptName / sim.getScriptName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a script's name based on its handle. A script doesn't have a name assigned, however if the script is a child script and associated with a scene object, then this function will retrieve the name of the associated scene object. If the script is not a child script or is not associated with a scene object, then the returned value is NULL <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptName(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>buffer to the script's name if function was successful and the name is valid, NULL otherwise. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string scriptName=sim.getScriptName(number scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>scriptHandle</strong>: handle of the script, or sim.handle_self for the handle of the current script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>scriptName</strong>: name of the script if associated with a scene object, empty string if the script is the main script, or the name of the <a href="addOns.htm">add-on</a> if the script is an add-on.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptProperty" id="simGetScriptProperty"></a>simGetScriptProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves properties relative to a script. 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptProperty(simInt scriptHandle,simInt* scriptProperty,simInt* associatedObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>scriptProperty</strong>: pointer to a script property value (see the <a href="apiConstants.htm#scriptTypes">script type values</a>))</div>
<div><strong>associatedObjectHandle</strong>: pointer to the handle of an associated object if script is a child script, -1 otherwise (if the child script doesn't have an associated object, the value is -1 also)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptRawBuffer" id="simGetScriptRawBuffer"></a>simGetScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the raw data that is attached to a given script. See also <a href="#simSetScriptRawBuffer">simSetScriptRawBuffer</a> and <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptRawBuffer(simInt scriptHandle,simInt bufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>bufferHandle</strong>: handle of the raw buffer</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to the raw buffer (the buffer is owned by the simulator and will be released by the simulator or through a call to <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>) or NULL if the buffer doesn't exist or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptSimulationParameter" id="simGetScriptSimulationParameter"></a>simGetScriptSimulationParameter / sim.getScriptSimulationParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a main script's or child script's parameter from its simulation parameter list. Useful for simple interaction with the user, or for simple parameter exchange with other scripts. See also <a href="#simSetScriptSimulationParameter">sim.setScriptSimulationParameter</a>, and the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptSimulationParameter(simInt scriptHandle,const simChar* parameterName,simInt* parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the main script or child script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)<br>
</div>
<div><strong>parameterName</strong>: name of the parameter to retrieve</div>
<div><strong>parameterLength</strong>: the number of bytes that compose the value of the parameter (excluding the terminal zero)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the parameter or NULL if parameterName does not exist for the given script, or in case of an error. The user is in charge of releasing the returned value with <a href="#simReleaseBuffer">simReleaseBuffer</a>. The returned pointer points to parameterLength byte values, terminated by a terminal zero (the returned buffer may however contain several embedded zeros).<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) boolean/number/string parameterValue=sim.getScriptSimulationParameter(number scriptHandle,string parameterName,boolean forceStringReturn=false)</div>
<div>2) table parameterValues,table scriptHandles=sim.getScriptSimulationParameter(number targetScripts,string parameterName,boolean forceStringReturn=false)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) <strong>scriptHandle</strong>: handle of the script, or sim.handle_main_script or sim_handle_self.
</div>
<div>(2) <strong>targetScripts</strong>: sim.handle_all, sim.handle_tree or sim.handle_chain (with sim.handle_tree and sim.handle_chain the calling script is excluded).
</div>
<div>
 <strong>parameterName</strong>: name of the parameter to retrieve.
</div>
<div>
 <strong>forceStringReturn</strong>: forces the return of a string (i.e. raw value). False by default. If false, then the returned string will be converted to nil, false, true, a number or a string as appropriate (and in that order).
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>(1) <strong>parameterValue</strong>: value of the parameter, or nil in case of an error (or if that value is nil!).</div>
<div>(2) <strong>parameterValues</strong>: table of parameter values or nil if no such parameter was found or in case of an error. <strong>scriptHandles</strong>: table of script handles associated with the parameter values (i.e. parameterValue[i] comes from the script with handle scriptHandles[i]) or nil if no such parameter was found or in case of an error.<br>
</div>
<br>
<div>If the returned parameter value is a string, then it might contain any values (also embedded zeros)</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetScriptText" id="simGetScriptText"></a>simGetScriptText</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the content of a script (i.e. Lua code). See also <a href="#simSetScriptText">sim.setScriptText</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>const simChar* simGetScriptText(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the script buffer (0-terminated buffer), or NULL in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeColor" id="simGetShapeColor"></a>simGetShapeColor / sim.getShapeColor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the color of a shapes. See also <a href="#simSetShapeColor">sim.setShapeColor</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeColor(simInt shapeHandle,const simChar* colorName,simInt colorComponent,simFloat* rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape<br>
</div>
<div><strong>colorName</strong>: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.<br>
</div>
<div><strong>colorComponent</strong>: a <a href="apiConstants.htm#colorComponents">color component</a>.</div>
<div><strong>rgbData</strong> (output): red, green and blue components of the color (3 values), or the transparency value (1 value)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the color name was not found in the shape. Otherwise, the operation was successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_3 rgbData=sim.getShapeColor(number shapeHandle,string colorName,number colorComponent)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeGeomInfo" id="simGetShapeGeomInfo"></a>simGetShapeGeomInfo / sim.getShapeGeomInfo </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves geometric information related to a shape. See also <a href="#simGetShapeMesh">sim.getShapeMesh</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeGeomInfo(simInt shapeHandle,simInt* intData,simFloat* floatData,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>intData (output)</strong>: pointer to 5 integer values:</div>
<div class=tab>intData[0]: the <a href="apiConstants.htm#pureTypes">pure type</a> of the shape. Undefined if the shape is a compound shape.</div>
<div><strong>floatData (output)</strong>: pointer to 5 float values:</div>
<div class=tab>floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise bit-coded:</div>
<div class=tab>bit0 set (1): shape is a compound shape</div>
<div class=tab>bit1 set (2): shape is pure</div>
<div class=tab>bit2 set (4): shape is convex</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number pureType,table_4 dimensions=sim.getShapeGeomInfo(number shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>shapeHandle</strong>: handle of the shape. See also <a href="#simGetObjectHandle">sim.getObjectHandle</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: -1 in case of an error, otherwise bit-coded:</div>
<div class=tab>bit0 set (1): shape is a compound shape</div>
<div class=tab>bit1 set (2): shape is pure</div>
<div class=tab>bit2 set (4): shape is convex</div>
<div><strong>pureType</strong>: the <a href="apiConstants.htm#pureTypes">pure type</a> of the shape. Undefined if the shape is a compound shape.</div>
<div><strong>dimensions</strong>: table to 4 values giving information about the shape's dimensions:</div>
<div class=tab>dimensions[1]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>dimensions[2]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>dimensions[3]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.</div>
<div class=tab>dimensions[4]: Inside scaling. Undefined if the shape is a compound shape or not pure.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeMassAndInertia" id="simGetShapeMassAndInertia"></a>simGetShapeMassAndInertia / sim.getShapeMassAndInertia </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves mass and inertia information from a shape. See also <a href="#simSetShapeMassAndInertia">sim.setShapeMassAndInertia</a>, <a href="#simGetObjectMatrix">sim.getObjectMatrix</a>, <a href="#simBuildMatrix">sim.buildMatrix</a> and <a href="#simComputeMassAndInertia">sim.computeMassAndInertia</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeMassAndInertia(simInt shapeHandle,simFloat* mass,simFloat* inertiaMatrix,simFloat* centerOfMass,const simFloat* transformation)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the <a href="shapes.htm">shape object</a></div>
<div><strong>mass</strong>: the mass of the object</div>
<div><strong>inertia matrix</strong> (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of <strong>transformation</strong> (see further below). </div>
<div><strong>centerOfMass</strong> (output): the position of the center of mass, relative to the specified <strong>transformation</strong> (see next item).</div>
<div><strong>transformation</strong>: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See <a href="#simGetObjectMatrix">here</a> to see how matrix transformations are specified in V-REP.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<a href="#simReleaseBuffer"></a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number mass,table_9 inertiaMatrix,table_3 centerOfMass=sim.getShapeMassAndInertia(number shapeHandle,table_12 transformation=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>See the C-function for details</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>See the C-function for details</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeMesh" id="simGetShapeMesh"></a>simGetShapeMesh / sim.getShapeMesh </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a shape's mesh information. See also <a href="#simGetShapeViz">sim.getShapeViz</a>, <a href="#simCreateMeshShape">sim.createMeshShape</a> and <a href="#simExportMesh">sim.exportMesh</a> for a usage example.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeMesh(simInt shapeHandle,simFloat** vertices,simInt* verticesSize,simInt** indices,simInt* indicesSize,simFloat** normals)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape</div>
<div><strong>vertices</strong>: receives the vertices. The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>verticesSize</strong>: receives the size of the vertices array. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>indices</strong>: receives the indices. The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>indicesSize</strong>: receives the size of the indice array. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>normals</strong>: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Can be NULL.</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table vertices,table indices,table normals=sim.getShapeMesh(number shapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>shapeHandle</strong>: handle of the shape. See <a href="#simExportMesh">sim.exportMesh</a> for a usage example.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>vertices</strong>: table of vertices, or nil in case of an error</div>
<div><strong>indices</strong>: table of indices, or nil in case of an error</div>
<div><strong>normals</strong>: table of normals, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeTextureId" id="simGetShapeTextureId"></a>simGetShapeTextureId / sim.getShapeTextureId </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the texture ID of a texture that is applied to a specific shape. See also <a href="#simGetTextureId">sim.getTextureId</a> and <a href="#simSetShapeTexture">sim.setShapeTexture</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeTextureId(simInt shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The texture ID, or -1 if the texture does not exist or in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number textureId=sim.getShapeTextureId(number shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetShapeViz" id="simGetShapeViz"></a>simGetShapeViz / sim.getShapeViz </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a shape's visual information.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeViz(simInt shapeHandle,simInt index,struct SShapeVizInfo* info)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape</div>
<div><strong>index</strong>: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)</div>
<div><strong>info</strong>: visual information about the shape:</div>
<div><br></div>
<div><strong>vertices</strong>: array of vertices, relative to the shape's reference frame. The user is in charge of releasing this buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a> if the return value is &gt; 0.</div>
<div><strong>verticesSize</strong>: the size of the vertices array</div>
<div><strong>indices</strong>: array of indices. The user is in charge of releasing this buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a> if the return value is &gt; 0.</div>
<div><strong>indicesSize</strong>: the size of the indices array</div>
<div><strong>normals</strong>: array of normals, relative to the shape's reference frame. The user is in charge of releasing this buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a> if the return value is &gt; 0.</div>
<div><strong>shadingAngle</strong>: the gouraud shading angle</div>
<div><strong>colors[9]</strong>: array of colors: RGB for ambient-diffuse,  specular, and  emission.</div>
<div><strong>texture</strong>: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a> if the return value is &gt; 1.</div>
<div><strong>textureId</strong>: a texture id (to identify textures shared among several shapes)</div>
<div><strong>textureRes[2]</strong>: the resolution of the texture</div>
<div><strong>textureCoords</strong>: the texture coordinates. The user is in charge of releasing this buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a> if the return value is &gt; 1.</div>
<div><strong>textureApplyMode</strong>: 0=modulate, 1=decal, 2=add</div>
<div><strong>textureOptions</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): repeat U</div>
<div class=tab>bit1 set (2): repeat V</div>
<div class=tab>bit2 set (4): interpolate colors</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if there is no shape element at the given indexm, 1 if the shape element does not contain any texture, 2 if the shape element contains a texture<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>map data=sim.getShapeViz(number shapeHandle,number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>shapeHandle</strong>: handle of the shape.</div>
<div><strong>index</strong>: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>In case of success, data contains following fields:</div>
<div><strong>data.vertices</strong>: array containing the  vertices, relative to the shape's reference frame</div>
<div><strong>data.indices</strong>: array containing the indices</div>
<div><strong>data.normals</strong>: array containing the normals, relative to the shape's reference frame</div>
<div><strong>data.colors</strong>: array containing the colors: RGB for ambient-diffuse,  specular, and  emission.</div>
<div><strong>data.shadingAngle</strong>: the gouraud shading angle</div>
<div><br></div>
<div>Additionally, if the shape element contains a texture, data contains following additional fields:</div>
<div><strong>data.texture.texture</strong>: the string-coded RGBA texture. See also <a href="#simTransformBuffer">sim.transformBuffer</a></div>
<div><strong>data.texture.id</strong>: a texture id (to identify textures shared among several shapes)</div>
<div><strong>data.texture.resolution</strong>: the resolution of the texture</div>
<div><strong>data.texture.coordinates</strong>: the texture coordinates</div>
<div><strong>data.texture.applyMode</strong>: 0=modulate, 1=decal, 2=add</div>
<div><strong>data.texture.options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): repeat U</div>
<div class=tab>bit1 set (2): repeat V</div>
<div class=tab>bit2 set (4): interpolate colors</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSignalName" id="simGetSignalName"></a>simGetSignalName / sim.getSignalName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the signal name at the given index.  Use this function in a loop until return is NULL to read all set signals. Signals are values that are global to a given simulator scene and cleared at simulation start. See also the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetSignalName(simInt signalIndex,simInt signalType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalIndex</strong>: zero based index</div>
<div><strong>signalType</strong>: signal type. 0 is for integer signals, 1 for float signals and 2 for string signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or signal does not exist at this index, otherwise the name of the signal at the given index (the user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string signalName=sim.getSignalName(number signalIndex,number signalType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSimulationPassesPerRenderingPass" id="simGetSimulationPassesPerRenderingPass"></a>simGetSimulationPassesPerRenderingPass</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the number of simulation passes (calculation passes) per frame (display). This value might not be constant for a given simulation. See also <a href="#simSetSimulationPassesPerRenderingPass">simSetSimulationPassesPerRenderingPass</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSimulationPassesPerRenderingPass()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>&gt;0 if operation was successful (the number of simulation passes per rendering pass), -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSimulationState" id="simGetSimulationState"></a>simGetSimulationState / sim.getSimulationState </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves current <a href="apiConstants.htm#simulationStatus">simulation state</a>. See also the <a href="simulation.htm">simulation state diagram</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSimulationState()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The current state of the simulation (sim_simulation_stopped, sim_simulation_paused, etc. (see the <a href="apiConstants.htm#simulationStatus">simulation state values</a>)), or -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number simulationState=sim.getSimulationState()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetSimulationState">simxGetSimulationState</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSimulationTime" id="simGetSimulationTime"></a>simGetSimulationTime / sim.getSimulationTime </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the current simulation time<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSimulationTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>negative value (-1.0) if operation not successful, otherwise the simulation time<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number simulationTime=getSimulationTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetSimulationTime">simxGetSimulationTime</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSimulationTimeStep" id="simGetSimulationTimeStep"></a>simGetSimulationTimeStep / sim.getSimulationTimeStep </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the simulation time step (the simulation time (i.e. not real-time) that passes at each main script simulation pass). This value might not be constant for a given simulation.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSimulationTimeStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>negative value (-1.0) if operation not successful, otherwise the simulation time step</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number timeStep=getSimulationTimeStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetSimulationTimeStep">simxGetSimulationTimeStep</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSimulatorMessage" id="simGetSimulatorMessage"></a>simGetSimulatorMessage / sim.getSimulatorMessage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves and removes the next message in the C/C++ or Lua message queues. Use this in a while-loop until all messages have been extracted. While the C/C++ interface has one single message queue, each Lua script has its own message queue. The C/C++ version of this function should only be called from the V-REP client application. A given message queue cannot hold more than 64 messages, unread messages will be discarded.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetSimulatorMessage(simInt* messageID,simInt* auxiliaryData,simInt* returnedDataSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>messageID</strong>: a simulator message (see the <a href="apiConstants.htm#simulatorMessages">simulator messages</a>) or -1 if no message is available or in case of an error<br>
</div>
<div><strong>auxiliaryData</strong>: table of 4 integers that can describe the returned message in more details</div>
<div><strong>returnedDataSize</strong>: size of the returned buffer</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if no buffer was returned, otherwise a buffer that should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number message,table_4 auxiliaryData,table auxiliaryData2=sim.getSimulatorMessage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>message</strong>: a simulator message (see the <a href="apiConstants.htm#simulatorMessages">simulator messages</a>) or -1 if no message is available or in case of an error<br>
</div>
<div><strong>auxiliaryData</strong>: table of 4 numbers that can describe the returned message in more details</div>
<div><strong>auxiliaryData2</strong>: optional table of n numbers that hold more data related to the message</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackBoolValue" id="simGetStackBoolValue"></a>simGetStackBoolValue</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve the value at the top of the stack, if that value is a Boolean. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackBoolValue(simInt stackHandle,simBool* boolValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>boolValue</strong>: a pointer to a location receiving the bool value.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the value is not a bool, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackDoubleTable" id="simGetStackDoubleTable"></a>simGetStackDoubleTable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a double-precision float array from an array-type table at the top of the stack. Table values that are not numbers are converted to 0.0. See also <a href="#simGetStackTableInfo">simGetStackTableInfo</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackDoubleTable(simInt stackHandle,simDouble* array,simInt count)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>array</strong>: a pointer to a location receiving the double values. Use <a href="#simGetStackTableInfo">simGetStackTableInfo</a> to determine the number of values the table contains.</div>
<div><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackDoubleValue" id="simGetStackDoubleValue"></a>simGetStackDoubleValue</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve the value at the top of the stack, if that value is a number. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackDoubleValue(simInt stackHandle,simDouble* numberValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>numberValue</strong>: a pointer to a location receiving the double value.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackFloatTable" id="simGetStackFloatTable"></a>simGetStackFloatTable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an float array from an array-type table at the top of the stack. Table values that are not numbers are converted to 0.0. See also <a href="#simGetStackTableInfo">simGetStackTableInfo</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackFloatTable(simInt stackHandle,simFloat* array,simInt count)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>array</strong>: a pointer to a location receiving the float values. Use <a href="#simGetStackTableInfo">simGetStackTableInfo</a> to determine the number of values the table contains.</div>
<div><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackFloatValue" id="simGetStackFloatValue"></a>simGetStackFloatValue</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve the value at the top of the stack, if that value is a number. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackFloatValue(simInt stackHandle,simFloat* numberValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>numberValue</strong>: a pointer to a location receiving the float value.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackInt32Table" id="simGetStackInt32Table"></a>simGetStackInt32Table</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an integer array from an array-type table at the top of the stack. Table values that are not numbers are converted to 0. See also <a href="#simGetStackTableInfo">simGetStackTableInfo</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackInt32Table(simInt stackHandle,simInt* array,simInt count)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>array</strong>: a pointer to a location receiving the integer values. Use <a href="#simGetStackTableInfo">simGetStackTableInfo</a> to determine the number of values the table contains.</div>
<div><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackInt32Value" id="simGetStackInt32Value"></a>simGetStackInt32Value</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve the value at the top of the stack, if that value is a number. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackInt32Value(simInt stackHandle,simInt* numberValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>numberValue</strong>: a pointer to a location receiving the int32 value.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackSize" id="simGetStackSize"></a>simGetStackSize</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the size of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackSize(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the size of the stack.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackStringValue" id="simGetStackStringValue"></a>simGetStackStringValue</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve the value at the top of the stack, if that value is a string. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStackStringValue(simInt stackHandle,simInt* stringSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>stringSize</strong>: a pointer to a location receiving the size of the string. Can be NULL if the string size is of no interest.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>In case of an error, the return value is NULL and <em>stringSize</em> will be set to -1 (if <em>stringSize</em> is not NULL).<br>
  If the stack item is not a string, the return value is NULL and <em>stringSize</em> will be set to 0 (if <em>stringSize</em> is not NULL).<br>
  If the stack item is a string, the return value is not NULL, and <em>stringSize</em> will be the size of the string buffer (if <em>stringSize</em> is not NULL). In that case, the user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackTableInfo" id="simGetStackTableInfo"></a>simGetStackTableInfo</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tries to retrieve information about a possible table at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackTableInfo(simInt stackHandle,simInt infoType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>infoType</strong>: the type of information desired:</div>
<div class=tab><strong>0</strong>: whether we have a table, whether the table is an array-type or map-type, and the size of the array-type table</div>
<div class=tab><strong>1</strong>: whether the table contains only null values.</div>
<div class=tab><strong>2</strong>: whether the table contains only number values.</div>
<div class=tab><strong>3</strong>: whether the table contains only Boolean values.</div>
<div class=tab><strong>4</strong>: whether the table contains only string values.</div>
<div class=tab><strong>5</strong>: whether the table contains only table values.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise one of following:</div>
<div class=tab>if <em>infoType</em> is 0:</div>
<div class=tabTab><em>sim_stack_table_circular_ref</em> (-4): the value at the top of the stack is a circular reference table (is set to an empty table)</div>
<div class=tabTab><em>sim_stack_table_not_table</em> (-3): the value at the top of the stack is not a table</div>
<div class=tabTab><em>sim_stack_table_map</em> (-2): the value at the top of the stack is a map-type table, containing value-key pairs, where the keys are not all numbers, not all consecutive, or not starting at 1. Use <a href="#simUnfoldStackTable">simUnfoldStackTable</a> to read the content of the table.</div>
<div class=tabTab><em>sim_stack_table_empty</em> (0): the value at the top of the stack is an empty table.</div>
<div class=tabTab>a value>0: the value at the top of the stack is an array-type table, containing value-key pairs, where all the keys are numbers, consecutive, and starting at 1. Use <a href="#simUnfoldStackTable">simUnfoldStackTable</a>, <a href="#simGetStackUInt8Table">simGetStackUInt8Table</a>, <a href="#simGetStackInt32Table">simGetStackInt32Table</a>, <a href="#simGetStackFloatTable">simGetStackFloatTable</a> or <a href="#simGetStackDoubleTable">simGetStackDoubleTable</a> to read the content of the table.</div>
<div class=tab>if <em>infoType</em> is 1: 1 if the table contains only null values</div>
<div class=tab>if <em>infoType</em> is 2: 1 if the table contains only number values</div>
<div class=tab>if <em>infoType</em> is 3: 1 if the table contains only Boolean values</div>
<div class=tab>if <em>infoType</em> is 4: 1 if the table contains only string values</div>
<div class=tab>if <em>infoType</em> is 5: 1 if the table contains only table values</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackTraceback" id="simGetStackTraceback"></a>sim.getStackTraceback</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves and clears the last generated stack traceback for the calling script. See also <a href="#simGetLastError">sim.getLastError</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-<a href="#simReleaseBuffer"></a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string stackTraceback=sim.getStackTraceback()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>the stack traceback, or an empty string</div>
<div></div></td> 
</tr> 


</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStackUInt8Table" id="simGetStackUInt8Table"></a>simGetStackUInt8Table</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a uint8 array from an array-type table at the top of the stack. Table values that are not numbers are converted to 0. See also <a href="#simGetStackTableInfo">simGetStackTableInfo</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetStackUInt8Table(simInt stackHandle,simUChar* array,simInt count)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>array</strong>: a pointer to a location receiving the uint8 values. Use <a href="#simGetStackTableInfo">simGetStackTableInfo</a> to determine the number of values the table contains.</div>
<div><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStringNamedParam" id="simGetStringNamedParam"></a>simGetStringNamedParam / sim.getStringNamedParam</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a named string or buffer value. See also <a href="#simSetStringNamedParam">sim.setStringNamedParam</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStringNamedParam(const simChar* paramName,simInt* paramLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramName</strong>: the key or name of the parameter</div>
<div><strong>paramLength</strong>: the size of the parameter</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or if such a parameter does not exist. Otherwise the parameter. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string stringParam=sim.getStringNamedParam(string paramName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStringParameter" id="simGetStringParameter"></a>simGetStringParameter / sim.getStringParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a string value. See the <a href="apiConstants.htm#stringParameters">string parameter identifiers</a>. See also <a href="#simGetBoolParameter">sim.getBoolParameter</a>, <a href="#simGetInt32Parameter">sim.getInt32Parameter</a>, <a href="#simGetArrayParameter">sim.getArrayParameter</a> and <a href="#simGetFloatParameter">sim.getFloatParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStringParameter(simInt parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#stringParameters">string parameter identifier</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful. Otherwise the string parameter. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string parameterValue=sim.getStringParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetStringParameter">simxGetStringParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetStringParameter">simxGetStringParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetStringSignal" id="simGetStringSignal"></a>simGetStringSignal / sim.getStringSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of a string signal. Signals are cleared at simulation start.  See also <a href="#simSetStringSignal">sim.setStringSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>  and <a href="#simPersistentDataRead">sim.persistentDataRead</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStringSignal(const simChar* signalName,simInt* stringLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>stringLength</strong>: the size of the returned string, since it may contain any data (also embedded zeros).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or signal does not exist, otherwise the value of the string signal (which may contain any value, including embedded zeros). In that case the returned buffer should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string signalValue=sim.getStringSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>

<div><strong>signalName</strong>: name of the signal</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal, or nil if operation was not successful or signal does not exist. The returned signal may contain any value, including embedded zeros.</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetStringSignal">simxGetStringSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetStringSignal">simxGetStringSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSystemTime" id="simGetSystemTime"></a>simGetSystemTime / sim.getSystemTime </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the system time. The system time is the time is seconds that elapsed since Windows or V-REP was started, depending on the system. See also <a href="#simGetSystemTimeInMs">sim.getSystemTimeInMs</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSystemTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>system time in seconds, or a negative value (-1.0) in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number systemTime=sim.getSystemTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetSystemTimeInMs" id="simGetSystemTimeInMs"></a>simGetSystemTimeInMs / sim.getSystemTimeInMs </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a time in milliseconds.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simUInt simGetSystemTimeInMs(simInt previousTime)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>previousTime</strong>: value that indicates how the command should operate:</div>
<div class=tabTab>&gt;=0: the function returns a time difference with previousTime. PreviousTime must have been previously retrieved with the -1 argument below.</div>
<div class=tabTab>-1: the function returns a time relative to an arbitrary time. Use this to measure time differences within V-REP</div>
<div class=tabTab>-2: the function returns a time as follows:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
// On Windows:
returnedValue=TimeGetTime();

// On MacOS / Linux:
struct timeval now;
gettimeofday(&now,NULL);
returnValue=now.tv_sec*1000+now.tv_usec/1000;
</pre>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a  time in milliseconds as described here above.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number systemTimeOrTimeDiff=sim.getSystemTimeInMs(number previousTime)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetTimeInMs">simxGetTimeInMs</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetTextureId" id="simGetTextureId"></a>simGetTextureId / sim.getTextureId </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the texture ID of a specific texture. See also <a href="#simReadTexture">sim.readTexture</a>,  <a href="#simWriteTexture">sim.writeTexture</a> and <a href="#simCreateTexture">sim.createTexture</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetTextureId(const simChar* textureName,simInt* resolution)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>textureName</strong>: the name of the texture ID to be retrieved.</div>
<div><strong>resolution</strong>: a pointer to 2 integer values representing the resolution of the texture. Can be NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The texture ID, or -1 if the texture does not exist or in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number textureId,table_2 resolution=sim.getTextureId(string textureName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetThreadAutomaticSwitch" id="simGetThreadAutomaticSwitch"></a>simGetThreadAutomaticSwitch / sim.getThreadAutomaticSwitch </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Queries whether the current thread will eventually automatically switch to another thread. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function always return false. See also <a href="#simSetThreadAutomaticSwitch">sim.setThreadAutomaticSwitch</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean result=sim.getThreadAutomaticSwitch()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: if true, the thread is able to automatically switch to another thread.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetThreadId" id="simGetThreadId"></a>simGetThreadId / sim.getThreadId </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns a thread id. See also <a href="#simLockResources">simLockResources</a> and <a href="#simUnlockResources">simUnlockResources</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetThreadId()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the thread id: 0 if the thread is the gui thread, 1 if the thread is the main simulation thread, n if the thread is an auxiliary simulation thread.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number threadId=sim.getThreadId()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetUInt64Parameter" id="simGetUInt64Parameter"></a>simGetUInt64Parameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an unsigned 64bit integer value. See the <a href="apiConstants.htm#uinteger64Parameters">uint64 parameter identifiers</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simUInt64 simGetUInt64Parameter(simInt parameter,simUInt64* intState)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#uinteger64Parameters">uint64 parameter identifier</a></div>
<div><strong>intState</strong>: value of the parameter</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet><div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetUserVariables" id="simGetUserVariables"></a>sim.getUserVariables</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns global variables that were allocated just after the script internal state got initialized and all default functions/variables were registered.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>table variables=sim.getUserVariables()</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>variables</strong>: a map-like table with all global user variables.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVelocity" id="simGetVelocity"></a>simGetVelocity / sim.getVelocity </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the linear and/or angular velocity of the center of mass of a non-static shape object. See also <a href="#simGetObjectVelocity">sim.getObjectVelocity</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetVelocity(simInt shapeHandle,simFloat* linearVelocity,simFloat* angularVelocity)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div><strong>linearVelocity</strong>: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULL</div>
<div><strong>angularVelocity</strong>: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 linearVelocity,table_3 angularVelocity=sim.getVelocity(number shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>linearVelocity</strong>: table containing 3 values that represent the linear velocity in absolute coordinates, or nil in case of an error<br>
</div>
<div><strong>angularVelocity</strong>: table containing 3 values that represent the angular velocity in absolute coordinates, or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVisionSensorCharImage" id="simGetVisionSensorCharImage"></a>simGetVisionSensorCharImage / sim.getVisionSensorCharImage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the rgb-image (or rgba, or a portion of it) of a vision sensor. The returned data doesn't make sense if <a href="#simHandleVisionSensor">sim.handleVisionSensor</a> wasn't called previously  (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as <em>explicit handling</em>). See also <a href="#simGetVisionSensorImage">sim.getVisionSensorImage</a>, <a href="#simSetVisionSensorCharImage">sim.setVisionSensorCharImage</a> and <a href="#simSaveImage">sim.saveImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simUChar* simGetVisionSensorCharImage(simInt sensorHandle,simInt* resolutionX,simInt* resolutionY)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor.  Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_greyscale</a> (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.</div>
<div><strong>resolutionX/resolutionY</strong>: the returned vision sensor resolution</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>image buffer (buffer size is resolutionX*resolution*3 or resolutionX*resolutionY in case of a grey scale image retrieval) or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Returned values are in the range of 0-255 (0=min. intensity, 255=max. intensity)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string imageBuffer,number resolutionX,number resolutionY=sim.getVisionSensorCharImage(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number rgbaCutOff=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor.   Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim.handleflag_greyscale</a> (simply add sim.handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.</div>
<div><strong>posX / posY</strong>: position of the image portion to retrieve. Zero by default.</div>
<div><strong>sizeX / sizeY</strong>: size of the image portion to retrieve. Zero by default, which means that the full image should be retrieved</div>
<div><strong>rgbaCutOff</strong>: when different from zero, then an RGBA image is returned, where the alpha component will be 255 for all depth values below <em>rgbaCutOff</em>, and 0 for all depth values above <em>rgbaCutOff</em>. 0 corresponds to the near clipping plane, 1 to the far clipping plane. Zero by default.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>imageBuffer</strong>: nil in case of an error. Otherwise a string containing rgb (or rgba) values (table size is sizeX*sizeY*3 (or sizeX*sizeY*4 in case of rgba), rgb(a) values in the range 0-255). In case of a grey scale image retrieval, the image buffer will contain grey values or grey+alpha values in the range 0-255.
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetVisionSensorImage">simxGetVisionSensorImage</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetVisionSensorImage">simxGetVisionSensorImage</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVisionSensorDepthBuffer" id="simGetVisionSensorDepthBuffer"></a>simGetVisionSensorDepthBuffer / sim.getVisionSensorDepthBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the depth buffer (or a portion of it) of a vision sensor. Use <a href="#simGetVisionSensorResolution">sim.getVisionSensorResolution</a> to know the resolution of the full depth buffer. The returned data doesn't make sense if <a href="#simHandleVisionSensor">sim.handleVisionSensor</a> wasn't called previously (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as <em>explicit handling</em>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGetVisionSensorDepthBuffer(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor. Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_depthbuffermeters</a> (simply add sim_handleflag_depthbuffermeters to sensorHandle), if you wish to retrieve values in meters.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>depth buffer (buffer size is resolutionX*resolutionY) or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Returned values are in the range of 0-1 (0=closest to sensor (i.e. close clipping plane), 1=farthest from sensor (i.e. far clipping plane)). If the sim_handleflag_depthbuffermeters was specified, then individual values are expressed as distances in terms of meters.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table depthBuffer=sim.getVisionSensorDepthBuffer(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: same as for the C function. Additionally, can also be combined with <a href="apiConstants.htm#specialHandleFlags">sim.handleflag_codedstring</a> (simply add sim.handleflag_codedstring to sensorHandle), if you wish to retrieve a string buffer (sim.buffer_float) instead of a table. In that case, refer also to <a href="#simTransformBuffer">sim.transformBuffer</a>.</div>
<div><strong>posX / posY</strong>: position of the depth buffer portion to retrieve. Zero by default.</div>
<div><strong>sizeX / sizeY</strong>: size of the depth buffer portion to retrieve. Zero by default, which means that the full depth buffer should be retrieved</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>depthBuffer</strong>: table containing depth values (table size is sizeX*sizeY), a string containing coded depth values, or nil in case of an error. Returned values are in the range of 0-1 (0=closest to sensor (i.e. close clipping plane), 1=farthest from sensor (i.e. far clipping plane)). If the sim_handleflag_depthbuffermeters was specified, then individual values are expressed as distances in terms of meters.<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetVisionSensorDepthBuffer">simxGetVisionSensorDepthBuffer</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetVisionSensorDepthBuffer">simxGetVisionSensorDepthBuffer</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVisionSensorFilter" id="simGetVisionSensorFilter"></a>simGetVisionSensorFilter / sim.getVisionSensorFilter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the parameters and settings of a specific <a href="visionSensorFilterComposition.htm">filter component</a> of a <a href="visionSensors.htm">vision sensor</a>. See also <a href="#simSetVisionSensorFilter">sim.setVisionSensorFilter</a> and the other <a href="apiFunctionListCategory.htm#visionSensor">vision sensor related API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetVisionSensorFilter(simInt visionSensorHandle,simInt filterIndex,simInt* options,simInt* pSizes,simUChar** bytes,simInt** ints,simFloat** floats,simUChar** custom)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>filterIndex</strong>: the zero-based index of the filter position.</div>
<div><strong>options</strong>: bit-coded return value:</div>
<div class=tab>bit 0 set (1): the component is enabled</div>
<div><strong>pSizes</strong>: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).</div>
<div><strong>bytes</strong>: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>ints</strong>: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>floats</strong>: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
<div><strong>custom</strong>: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>

<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
int options=0;
int sizes[4]={0,0,0,0};
unsigned char* bytes;
int* ints;
float* floats;
unsigned char* custom;
int filterType=simGetVisionSensorFilter(handle,index,&amp;options,sizes,&amp;bytes,&amp;ints,&amp;floats,&amp;custom);
if (filterType&gt;0)
{
    // Modify options, bytes, ints, floats and custom
    // ...
    // Now write back the updated values:
    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);
    // Destroy the buffers:
    simReleaseBuffer((simChar*)bytes);
    simReleaseBuffer((simChar*)ints);
    simReleaseBuffer((simChar*)floats);
    simReleaseBuffer((simChar*)custom);
}
</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the <em>filterIndex</em> is not valid, otherwise the <a href="apiConstants.htm#filterComponents">type of filter component</a> pointed by the <em>filterIndex</em>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number filterType,number options,table byteVals,table intVals,table floatVals,string customBuffer=sim.getVisionSensorFilter(number sensorHandle,number filterIndex)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightRedBoxNoMarginAndSmall>
local filterType,options,bytes,ints,floats,buffer=sim.getVisionSensorFilter(handle,index)
if filterType&gt;0 then
    -- Modify options, bytes, ints, floats and buffer
    -- ...
    -- Now write back the updated values:
    sim.setVisionSensorFilter(handle,index,options,bytes,ints,floats,buffer)
end
</pre>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVisionSensorImage" id="simGetVisionSensorImage"></a>simGetVisionSensorImage / sim.getVisionSensorImage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the rgb-image (or a portion of it) of a vision sensor. Use <a href="#simGetVisionSensorResolution">sim.getVisionSensorResolution</a> to know the resolution of the full image. The returned data doesn't make sense if <a href="#simHandleVisionSensor">sim.handleVisionSensor</a> wasn't called previously  (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as <em>explicit handling</em>). See also <a href="#simGetVisionSensorCharImage">sim.getVisionSensorCharImage</a> and <a href="#simSetVisionSensorImage">sim.setVisionSensorImage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGetVisionSensorImage(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor.   Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_greyscale</a> (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>image buffer (buffer size is resolutionX*resolutionY*3 or resolutionX*resolutionY in case of a grey scale image retrieval) or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Returned values are in the range of 0-1 (0=min. intensity, 1=max. intensity)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table/string imageBuffer=sim.getVisionSensorImage(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number returnType=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor.   Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim.handleflag_greyscale</a> (simply add sim.handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.</div>
<div><strong>posX / posY</strong>: position of the image portion to retrieve. Zero by default.</div>
<div><strong>sizeX / sizeY</strong>: size of the image portion to retrieve. Zero by default, which means that the full image should be retrieved</div>
<div><strong>returnType</strong>: the type of the returned buffer. 0 returns a table filled with rgb values in the range 0-1, 1 returns a string filled with rgb values in the range 0-255</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>imageBuffer</strong>: nil in case of an error. Otherwise a table containing rgb values (table size is sizeX*sizeY*3, rgb values in the range 0-1) or a string containing rgb values (table size is sizeX*sizeY*3, rgb values in the range 0-255). In case of a grey scale image retrieval, the image buffer will contain grey values or grey-alpha values.
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxGetVisionSensorImage">simxGetVisionSensorImage</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxGetVisionSensorImage">simxGetVisionSensorImage</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGetVisionSensorResolution" id="simGetVisionSensorResolution"></a>simGetVisionSensorResolution / sim.getVisionSensorResolution </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the resolution at which the given vision sensor operates (this might be different from what is indicated in the vision sensor dialog: should your graphic card model be rather old, then only resolutions a 2n will be supported). Useful in combination with <a href="#simGetVisionSensorImage">sim.getVisionSensorImage</a>/<a href="#simGetVisionSensorDepthBuffer">sim.getVisionSensorDepthBuffer</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetVisionSensorResolution(simInt sensorHandle,simInt* resolution)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div><strong>resolution</strong>: 2 values for the x and y component</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 resolution=sim.getVisionSensorResolution(number sensorHandle) <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resolution</strong>: table containing the x and y resolution, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simGroupShapes" id="simGroupShapes"></a>simGroupShapes / sim.groupShapes </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Groups (or merges) several shapes into a <a href="shapes.htm">compound shape</a> (or <a href="shapes.htm">simple shape</a>). See also <a href="#simUngroupShape">sim.ungroupShape</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGroupShapes(const simInt* shapeHandles,simInt shapeCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandles</strong>: the handles of the shapes you wish to group</div>
<div><strong>shapeCount</strong>: the size of the <strong>shapeHandles</strong> array. A negative number indicates that we want to merge the shapes instead of grouping them.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise the handle of the resulting compound shape.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=sim.groupShapes(table shapeHandles) <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleAddOnScripts" id="simHandleAddOnScripts"></a>sim.handleAddOnScripts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a specific function in <a href="addOns.htm">add-ons</a>.  sim.handleAddOnScripts should only be called from the <a href="mainScript.htm">main script</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number count=sim.handleAddOnScripts(number callType)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>callType</strong>: the desired system call type (e.g. <em>sysCall_actuation</em>).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>count: number of called add-on scripts</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleChildScript" id="simHandleChildScript"></a>simHandleChildScript (REPLACED)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>This function doesn't exist anymore since V-REP 3.1.3, and you should use <a href="#simHandleChildScripts">sim.handleChildScripts</a> instead. Scenes saved with V-REP versions prior to V-REP 3.1.3 are normally automatically adjusted.</td>
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleChildScripts" id="simHandleChildScripts"></a>sim.handleChildScripts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a specific function in  <a href="childScripts.htm#nonThreaded">non-threaded child scripts</a>.  Child scripts will be executed in a <a href="scriptExecution.htm">precise order</a>. sim.handleChildScripts should only be called from the <a href="mainScript.htm">main script</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number scriptCount=sim.handleChildScripts(number callType)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>callType</strong>: the desired system call type (e.g. <em>sysCall_actuation</em>).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>scriptCount: number of called non-threaded child scripts</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleCollision" id="simHandleCollision"></a>simHandleCollision / sim.handleCollision </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (check for collision, etc.) a registered collision object. Collision objects can be registered while editing a scene. See also <a href="#simReadCollision">sim.readCollision</a>, <a href="#simResetCollision">sim.resetCollision</a>, <a href="#simCheckCollision">sim.checkCollision</a> and <a href="#simCheckCollisionEx">sim.checkCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered collision objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of collisions or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionCount,table_2 collidingObjectHandles=sim.handleCollision(number collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>collisionCount</strong>: number of collisions or -1 if operation was not successful.</div>
<div><strong>collidingObjectHandles</strong>: handles of the two colliding objects. This return value is only available when a collision object handle is provided (i.e. explicit handling).</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleCustomizationScripts" id="simHandleCustomizationScripts"></a>sim.handleCustomizationScripts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a specific function in  <a href="customizationScripts.htm">customization scripts</a>.  Customization scripts will be executed in a <a href="scriptExecution.htm">precise order</a>. sim.handleCustomizationScripts should only be called from the <a href="mainScript.htm">main script</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number count=sim.handleCustomizationScripts(number callType)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>callType</strong>: the desired system call type (e.g. <em>sysCall_actuation</em>).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>count: number of called customization scripts</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleDistance" id="simHandleDistance"></a>simHandleDistance / sim.handleDistance </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (measures distances, etc.) a registered distance object. Distance objects can be registered while editing a scene. See also <a href="#simReadDistance">sim.readDistance</a>, <a href="#simResetDistance">sim.resetDistance</a> and <a href="#simCheckDistance">sim.checkDistance</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleDistance(simInt distanceObjectHandle,simFloat* smallestDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered distance objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>smallestDistance</strong>: smallest measured distance. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if at least one distance was measured, 0 if no distance was measured, -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number smallestDistance=sim.handleDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if at least one distance was measured, 0 if no distance was measured, -1 in case of an error</div>
<div><strong>smallestDistance</strong>: the smallest distance measured. Is nil if result is not 1</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleDynamics" id="simHandleDynamics"></a>simHandleDynamics / sim.handleDynamics </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles the dynamics functionality in a scene. This function is not available to <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleDynamics(simFloat deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>deltaTime</strong>: the time that passed since the command was called last. Typically <a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>()<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the sepcified physics engine could not be found, otherwise, the number of calculation steps performed by the physics engine.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.handleDynamics(number deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleGraph" id="simHandleGraph"></a>simHandleGraph / sim.handleGraph </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a graph object (i.e. records current values of registered data streams). Graphs and data streams can be added/registered while editing a scene. See also <a href="#simResetGraph">sim.resetGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleGraph(simInt graphHandle,simFloat simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all graph objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>simulationTime</strong>: simulation time. Usually you want to record data stream at the end of a simulation pass to record actualized value: then set simulationTime to <a href="#simGetSimulationTime">simGetSimulationTime</a>()+<a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>(). <br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.handleGraph(number graphHandle,number simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleIkGroup" id="simHandleIkGroup"></a>simHandleIkGroup / sim.handleIkGroup </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (solves) a registered IK group. IK groups can be registered while editing a scene. See also <a href="#simCheckIkGroup">sim.checkIkGroup</a>, <a href="#simComputeJacobian">sim.computeJacobian</a> and <a href="#simGenerateIkPath">sim.generateIkPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleIkGroup(simInt ikGroupHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all IK groups, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;). See also <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of performed calculations (i.e. IK group calculation results are different from sim_ikresult_not_performed) if no specific IK group was specified, or a value of type <a href="apiConstants.htm#ikCalculationResults">IK result</a> if a specific IK group was specified, -1 in case of an error (a failed IK group calculation is not considered as an error)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number calculationCountOrResult=sim.handleIkGroup(number ikGroupHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleMainScript" id="simHandleMainScript"></a>simHandleMainScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (executes) the main script, i.e. the main simulation loop.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMainScript()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A <a href="apiConstants.htm#mainScriptExecutionResults">main script execution result</a>. If the return value contains sim_script_main_script_not_called, then the main script was not called (e.g. because a plugin hindered it when it received the <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_mainscriptabouttobecalled</a> message). Otherwise, the main script was called and <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> should be executed. </div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleMechanism" id="simHandleMechanism"></a>simHandleMechanism / sim.handleMechanism </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a mechanism registered with the geometric constraint solver functionality. Mechanisms can be registered while editing a scene.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMechanism(simInt mechanismHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>mechanismHandle</strong>: handle of the mechanism or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered mechanisms, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.handleMechanism(number mechanismHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleMill" id="simHandleMill"></a>simHandleMill / sim.handleMill </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs cutting) a registered mill object. See also <a href="#simResetMill">sim.resetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMill(simInt millHandle,simFloat* removedSurfaceAndVolume)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>millHandle</strong>: handle of a mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all mill objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>removedSurfaceAndVolume</strong>: pointer to two floating point values indicating the total removed surface and volume by this call. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>total number of cut objects, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number cutCount,table_2 removedSurfaceAndVolume=sim.handleMill(number millHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>cutCount</strong>: total number of cut objects, or -1 in case of an error</div>
<div><strong>removedSurfaceAndVolume</strong>: table indicating the total removed surface and volume by this call</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleModule" id="simHandleModule"></a>simHandleModule / sim.handleModule </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a plugin. This function is only available from the Lua API. Plugins, next to their registered custom Lua functions, might need to perform operations on a regular basis and not when called from a threaded script (e.g. for synchronization purposes). They can do it when <a href="#simHandleModule">sim.handleModule</a> is called (<a href="#simOpenModule">sim.openModule</a> should however have been called previously). Refer to the <a href="apiConstants.htm#simulatorMessages">messages relayed to plugins</a> for more details. <a href="#simHandleModule">sim.handleModule</a> can only be called from the <a href="mainScript.htm">main script</a> and is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">sim.openModule</a>, <a href="#simHandleModule">sim.handleModule</a> and <a href="#simCloseModule">sim.closeModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=sim.handleModule(number sim.handle_all,boolean calledInSensingPart)</div>
<div>(2) number result=sim.handleModule(string moduleName,boolean calledInSensingPart)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sim.handle_all</strong>: indicates that all plugins should be handled (called)</div>
<div><strong>moduleName</strong>: the name of the plugin that should be handled (called)</div>
<div><strong>calledInSensingPart</strong>: set to false when called in the &quot;actuation part&quot;. Set to true when called in the &quot;sensing part&quot; <br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleProximitySensor" id="simHandleProximitySensor"></a>simHandleProximitySensor / sim.handleProximitySensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs sensing, etc. of) a registered proximity sensor object. See also <a href="#simReadProximitySensor">sim.readProximitySensor</a>, <a href="#simCheckProximitySensor">sim.checkProximitySensor</a>, <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a> and <a href="#simResetProximitySensor">sim.resetProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleProximitySensor(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* detectedSurfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be NULL<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULL<br>
</div>
<br>
<div>When several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distance</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 if nothing was detected, -1 in case of an error. In a future release, a more detailed return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 detectedSurfaceNormalVector=sim.handleProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object or sim.handle_all or sim_handle_all_except_explicit. (sim.handle_all will handle all proximity sensor objects, while sim.handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 0 if nothing was detected, -1 in case of an error. In a future release, a more detailed return value might be available<br>
</div>
<div><strong>distance</strong>: distance to the detected point if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedPoint</strong>: table of 3 numbers indicating the relative coordinates of the detected point if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Is nil if result is &lt;1<br>
</div>
<br>
<div>When several proximity sensors are handled at the same time (e.g. with the sim.handle_all argument), then the return values are relative to the closest detection distance<br>
</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleSandboxScript" id="simHandleSandboxScript"></a>sim.handleSandboxScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls a specific function in the <a href="sandboxScript.htm">sandbox script</a>.  sim.handleSandboxScript should only be called from the <a href="mainScript.htm">main script</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>sim.handleSandboxScript(number callType)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>callType</strong>: the desired system call type (e.g. <em>sysCall_actuation</em>).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleSensingChildScripts" id="simHandleSensingChildScripts"></a>simHandleSensingChildScripts (REPLACED)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>This function has been replaced with <a href="#simHandleChildScripts">sim.handleChildScripts</a>, and is not a valid API function anymore since V-REP 3.1.3</td>
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleSensingStart" id="simHandleSensingStart"></a>simHandleSensingStart / sim.handleSensingStart </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.). Should only be called from the <a href="mainScript.htm">main script</a>, as the first instruction in the <em>sensing</em> section. See also <a href="#simHandleSimulationStart">sim.handleSimulationStart</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.handleSensingStart()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>none</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-1 in case of an error.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleSimulationStart" id="simHandleSimulationStart"></a>simHandleSimulationStart / sim.handleSimulationStart </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Initializes various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.). Should only be called from the <a href="mainScript.htm">main script</a>, as the first instruction in the <em>initialization</em> section. See also <a href="#simHandleSensingStart">sim.handleSensingStart</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.handleSimulationStart()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>none</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-1 in case of an error.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simHandleVisionSensor" id="simHandleVisionSensor"></a>simHandleVisionSensor / sim.handleVisionSensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs sensing, etc. of) a registered vision sensor object. It will (1) clear previous computer filter data, (2) read an image and (3) compute filter data on the new image (if the vision sensor is using an <strong>external input</strong> only (1) will be performed).See also <a href="#simReadVisionSensor">sim.readVisionSensor</a>, <a href="#simCheckVisionSensor">sim.checkVisionSensor</a>, <a href="#simCheckVisionSensorEx">sim.checkVisionSensorEx</a> and <a href="#simResetVisionSensor">sim.resetVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleVisionSensor(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>auxValues</strong>: auxiliary values returned from the applied filters (refer to the <a href="visionSensorFilterComposition.htm">documentation</a> for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
float* auxValues=NULL;
int* auxValuesCount=NULL;
float averageColor[3]={0.0f,0.0f,0.0f};
if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0)
{
    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))
    {
        averageColor[0]=auxValues[11];
        averageColor[1]=auxValues[12];
        averageColor[2]=auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of detections (number of vision sensors that triggered a detection), -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number detectionCount,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=sim.handleVisionSensor(number visionSensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>detectionCount</strong>: number of detections (number of vision sensors that triggered a detection), -1 in case of an error<br>
</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simImportMesh" id="simImportMesh"></a>simImportMesh / sim.importMesh </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Imports a mesh from a file. See also <a href="#simExportMesh">sim.exportMesh</a>, <a href="#simImportShape">sim.importShape</a> and <a href="#simCreateMeshShape">sim.createMeshShape</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simImportMesh(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor,simFloat*** vertices,simInt** verticesSizes,simInt*** indices,simInt** indicesSizes,simFloat*** reserved,simChar*** names)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: set to 0. Fileformat is automatically detected</div>

<div><strong>pathAndFilename</strong>: the location of the file to import.<br>
</div>
<div><strong>options</strong>: bit-coded: bit0 set (1): keep identical vertices, bit7 set (128): ignore up-vector coded in fileformat</div>

<div><strong>identicalVerticeTolerance</strong>: has no effect. set to zero<br>
</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices<br>
</div>
<div><strong>vertices</strong>: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example below<br>
</div>
<div><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example below<br>
</div>
<div><strong>indices</strong>: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example below<br>
</div>
<div><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example below<br>
</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.<br>
</div>
<div><strong>names</strong>: not used anymore. Set to NULL<br>
</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
simFloat** vertices;
simInt* verticesSizes;
simInt** indices;
simInt* indicesSizes;
simInt elementCount=simImportMesh(1,"d:\\example.dxf",0,0.0001f,1.0f,&vertices,
                            &verticesSizes,&indices,&indicesSizes,NULL,NULL);
if (elementCount>0)
{
    const float grey[3]={0.5f,0.5f,0.5f};
    for (int i=0;i&#60;elementCount;i++)
    {
        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],
                               verticesSizes[i],indices[i],indicesSizes[i],NULL);
        simSetShapeColor(shapeHandle,"",sim_colorcomponent_ambient,grey);
        simReleaseBuffer((simChar*)indices[i]);
        simReleaseBuffer((simChar*)vertices[i]);
    }
    simReleaseBuffer((simChar*)indicesSizes);
    simReleaseBuffer((simChar*)indices);
    simReleaseBuffer((simChar*)verticesSizes);
    simReleaseBuffer((simChar*)vertices);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Number of imported meshes, or 0 or -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_of_table vertices,table_of_table indices=sim.importMesh(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>vertices</strong>: a table to vertice tables, or nil if operation was not successful. The import operation may generate several meshes depending on the fileformat. See the example below<br>
</div>
<div><strong>indices</strong>: a table to indice tables, or nil if operation was not successful. The import operation may generate several meshes depending on the fileformat. See the example below<br>
</div>
<br>
<div>USAGE EXAMPLE (e.g. in a <a href="customizationScripts.htm">customization script</a>):</div>
<pre class=lightRedBoxNoMarginAndSmall>
if (importButtonPressed) then
    vertices,indices,reserved,names=sim.importMesh(1,"d:\\example.dxf",0,0.0001,1)
    if (vertices) then
        for i=1,#vertices,1 do
            h=sim.createMeshShape(2,20*math.pi/180,vertices[i],indices[i])
            sim.setShapeColor(h,"",sim.colorcomponent_ambient,{0.5,0.5,0.5})
            sim.setObjectName(h,names[i])
        end
    end
end</pre>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simImportShape" id="simImportShape"></a>simImportShape / sim.importShape </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Imports a <a href="shapes.htm">shape</a> from a file (first imports meshes, then groups/merges them into a shape). See also <a href="#simImportMesh">sim.importMesh</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simImportShape(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: set to 0. Fileformat is automatically detected<br>
</div>
<div><strong>pathAndFilename</strong>: the location of the file to import.<br>
</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): keep identical vertices</div>
<div class=tab>bit1 set (2): reserced. keep at 0.</div>
<div class=tab>bit2 set (4): reserved. keep at 0.</div>
<div class=tab>bit3 set (8): do not preserve colors</div>
<div class=tab>bit4 set (16): tries to preserve textures.</div>
<div class=tab>bit5 set (32): realigns the shape's bounding box with the world.</div>
<div class=tab>bit7 set (128): ignore up-vector coded in fileformat.</div>
<div><strong>identicalVerticeTolerance</strong>: not used. Set to 0<br>
</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The handle of the imported shape, or -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=sim.importShape(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertDataIntoStackTable" id="simInsertDataIntoStackTable"></a>simInsertDataIntoStackTable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts data into a table on the stack. The function expects a <em>value</em> at the top of the stack, a <em>key</em> one position below, and a table below that. The value and its associated key will be inserted into the table and removed from the stack. If successive values are inserted with consecutive number keys starting at 1, then the table values can be accessed via number indices in a script, and the table can be seen as an array. Otherwise, the table can be seen as a map or associative array. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertDataIntoStackTable(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertObjectIntoOctree" id="simInsertObjectIntoOctree"></a>simInsertObjectIntoOctree / sim.insertObjectIntoOctree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts an object into an <a href="octrees.htm">octree</a>, as voxels. Each voxel will store a color and a tag value. See also <a href="#simSubtractObjectFromOctree">sim.subtractObjectFromOctree</a>, <a href="#simInsertVoxelsIntoOctree">sim.insertVoxelsIntoOctree</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertObjectIntoOctree(simInt octreeHandle,simInt objectHandle,simInt options,const simUChar* color,simUInt tag,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>objectHandle</strong>: the handle of the object to insert. Only potentially <a href="collidableObjects.htm">collidable objects</a> are supported</div>
<div><strong>options</strong>: reserved. Set to 0</div>
<div><strong>color</strong>: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.</div>
<div><strong>tag</strong>: a uint32 value, which is user-defined.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of voxels in the octree</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalVoxelCnt=sim.insertObjectIntoOctree(number octreeHandle,number objectHandle,number options,table color=nil,number tag=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertObjectIntoPointCloud" id="simInsertObjectIntoPointCloud"></a>simInsertObjectIntoPointCloud / sim.insertObjectIntoPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts an object into a <a href="pointClouds.htm">point cloud</a>, as points. See also <a href="#simInsertPointsIntoPointCloud">sim.insertPointsIntoPointCloud</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertObjectIntoPointCloud(simInt pointCloudHandle,simInt objectHandle,simInt options,simFloat gridSize,const simUChar* color,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>objectHandle</strong>: the handle of the object to insert. Only potentially <a href="collidableObjects.htm">collidable objects</a> are supported</div>
<div><strong>options</strong>: reserved. Set to 0</div>
<div><strong>gridSize</strong>: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.</div>
<div><strong>color</strong>: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.</div>
<div><strong>optionalValues</strong>: can be used to specify additional parameters, or set to NULL for default parameter values:</div>
<div class=tab>((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:</div>
<div class=tab>((simFloat*)optionalValues)[1]: <strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is &gt; then 0.0</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of points in the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalPointCnt=sim.insertObjectIntoPointCloud(number pointCloudHandle,number objectHandle,number options,number gridSize,table color=nil,number duplicateTolerance=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertPathCtrlPoints" id="simInsertPathCtrlPoints"></a>simInsertPathCtrlPoints / sim.insertPathCtrlPoints </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts one or several control points into a <a href="paths.htm">path object</a>. See also <a href="#simCutPathCtrlPoints">sim.cutPathCtrlPoints</a> and <a href="#simCreatePath">sim.createPath</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertPathCtrlPoints(simInt pathHandle,simInt options,simInt startIndex,simInt ptCnt,const simVoid* ptData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: the handle of the path. Refer also to <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0: if set (1), then the path will be closed (given that there are enough control points in the path)</div>
<div class=tab>bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)</div>
<div><strong>startIndex</strong>: the zero-based index where the first new control point should be inserted.</div>
<div><strong>ptCnt</strong>: the number of control points to insert.</div>
<div><strong>ptData (input)</strong>: a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:</div>
<div class=tab>ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path object</div>
<div class=tab>ptData[3]-ptData[5] (float values): the orientation of the control point in <a href="eulerAngles.htm">Euler angles</a> (alpha,beta,gamma), relative to the path object</div>
<div class=tab>ptData[6] (float value): the relative velocity at the control point</div>
<div class=tab>ptData[7] (float value): the virtual distance at the control point</div>
<div class=tab>ptData[8] (int value): the number of Bezier points at the control point</div>
<div class=tab>ptData[9] (float value): the Bezier interpolation factor 1 at the control point</div>
<div class=tab>ptData[10] (float value): the Bezier interpolation factor 2 at the control point</div>
<div class=tab>ptData[11] (int value): the auxiliary flags at the control point</div>
<div class=tab>ptData[12]-ptData[15] (float values): the 4 auxiliary values at the control point</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.insertPathCtrlPoints(number pathHandle,number options,number startIndex,number ptCnt,table ptData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertPointsIntoPointCloud" id="simInsertPointsIntoPointCloud"></a>simInsertPointsIntoPointCloud / sim.insertPointsIntoPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts points into a <a href="pointClouds.htm">point cloud</a>. See also <a href="#simRemovePointsFromPointCloud">sim.removePointsFromPointCloud</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertPointsIntoPointCloud(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,const simUChar* color,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</div>
<div class=tab>bit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triple</div>
<div><strong>pts</strong>: a pointer to the point positions specified as X/Y/Z coordinates</div>
<div><strong>ptCnt</strong>: the number of point coordinates contained in pts</div>
<div><strong>color</strong>: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.</div>
<div><strong>optionalValues</strong>: can be used to specify additional parameters, or set to NULL for default parameter values:</div>
<div class=tab>((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:</div>
<div class=tab>((simFloat*)optionalValues)[1]: <strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is &gt; then 0.0</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of points in the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalPointCnt=sim.insertPointsIntoPointCloud(number pointCloudHandle,number options,table points,table color=nil,number duplicateTolerance=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInsertVoxelsIntoOctree" id="simInsertVoxelsIntoOctree"></a>simInsertVoxelsIntoOctree / sim.insertVoxelsIntoOctree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts voxels into an <a href="octrees.htm">octree</a>. Each voxel will store a color and a tag value. See also <a href="#simRemoveVoxelsFromOctree">sim.removeVoxelsFromOctree</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInsertVoxelsIntoOctree(simInt octreeHandle,simInt options,const simFloat* pts,simInt ptCnt,const simUChar* color,const simUInt* tag,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference frame</div>
<div class=tab>bit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.</div>
<div><strong>pts</strong>: a pointer to the voxel positions specified as X/Y/Z coordinates</div>
<div><strong>ptCnt</strong>: the number of point coordinates contained in pts</div>
<div><strong>color</strong>: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.</div>
<div><strong>tag</strong>: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if <em>color</em> is NULL.</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of voxels in the octree</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalVoxelCnt=sim.insertVoxelsIntoOctree(number octreeHandle,number options,table points,table color=nil,table tag=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInterpolateMatrices" id="simInterpolateMatrices"></a>simInterpolateMatrices / sim.interpolateMatrices </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Computes the interpolated transformation matrix between matrixIn1 and matrixIn2. Quaternions are used internally. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInterpolateMatrices(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat interpolFactor,simFloat* matrixOut)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn1</strong>: the first input matrix</div>
<div><strong>matrixIn2</strong>: the second input matrix</div>
<div><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; matrixOut=matrixIn1, 1.0--&gt; matrixOut=matrixIn2)<br>
</div>
<div><strong>matrixOut</strong>: the output matrix (the result of the interpolation).</div>
<div>A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 resultMatrix=sim.interpolateMatrices(table_12 matrixIn1,table_12 matrixIn2,number interpolFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>matrixIn1</strong>: the first input matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>matrixIn2</strong>: the second input matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; resultMatrix=matrixIn1, 1.0--&gt; resultMatrix=matrixIn2)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultMatrix</strong>: the result matrix (a table containing 12 values (the last row (0,0,0,1) is omitted)). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIntersectPointsWithPointCloud" id="simIntersectPointsWithPointCloud"></a>simIntersectPointsWithPointCloud / sim.intersectPointsWithPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes points from a <a href="pointClouds.htm">point cloud</a>, that do not intersect with the provided points (i.e. the result in the point cloud will be the intersection between the two sets of points). When a point cloud doesn't use an octree calculation structure, then this operation cannot be performed. See also <a href="#simInsertPointsIntoPointCloud">sim.insertPointsIntoPointCloud</a>, <a href="#simSetPointCloudOptions">sim.setPointCloudOptions</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIntersectPointsWithPointCloud(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,simFloat tolerance,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</div>
<div><strong>pts</strong>: a pointer to the point positions specified as X/Y/Z coordinates. </div>
<div><strong>ptCnt</strong>: the number of point coordinates contained in pts</div>
<div><strong>tolerance</strong>: a distance used as a tolerance value</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of points in the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalPointCnt=sim.intersectPointsWithPointCloud(number pointCloudHandle,number options,table points,number tolerance)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simInvertMatrix" id="simInvertMatrix"></a>simInvertMatrix / sim.invertMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inverts a transformation matrix. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInvertMatrix(simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)
</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.invertMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIsHandleValid" id="simIsHandleValid"></a>simIsHandleValid / sim.isHandleValid </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether a general object handle is still valid. When a general object is destroyed (e.g. programmatically or via the user interface), then its related handle is not valid anymore and will trigger an error when used. Use this function to avoid triggering an error. See also <a href="#simGetObjectHandle">sim.getObjectHandle</a>, <a href="#simGetCollectionHandle">sim.getCollectionHandle</a>, <a href="#simGetCollisionHandle">sim.getCollisionHandle</a>, <a href="#simGetDistanceHandle">sim.getDistanceHandle</a>, <a href="#simGetIkGroupHandle">sim.getIkGroupHandle</a>, <a href="#simGetScriptHandle">sim.getScriptHandle</a> and <a href="#simGetObjectUniqueIdentifier">sim.getObjectUniqueIdentifier</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsHandleValid(simInt generalObjectHandle,simInt generalObjectType)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalOjectHandle</strong>: handle of a general-type object (e.g. scene object, collision object, distance object, etc.)</div>
<div><strong>generalOjectType</strong>: type of the general object. Refer to the <a href="apiConstants.htm#generalObjectTypes">general object types</a>. Can be -1, in which case the specified handle is checked for validity in all types (handles of different types never overlap)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if the handle is not valid anymore, or 1 if the handle is still valid.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.isHandleValid(number generalObjectHandle,number generalObjectType=-1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIsObjectInSelection" id="simIsObjectInSelection"></a>simIsObjectInSelection / sim.isObjectInSelection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether an object is selected. See also <a href="#simGetObjectSelection">sim.getObjectSelection</a>, <a href="#simRemoveObjectFromSelection">sim.removeObjectFromSelection</a> and <a href="#simAddObjectToSelection">sim.addObjectToSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsObjectInSelection(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>3 if object is the last selection,1 if object is in selection, 0 if not, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number selectionState=sim.isObjectInSelection(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIsRealTimeSimulationStepNeeded" id="simIsRealTimeSimulationStepNeeded"></a>simIsRealTimeSimulationStepNeeded</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether a call to <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> is needed (only useful during real-time simulations).</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsRealTimeSimulationStepNeeded()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if call is needed, 0 if not needed, and -1 if the operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIsScriptExecutionThreaded" id="simIsScriptExecutionThreaded"></a>simIsScriptExecutionThreaded / sim.isScriptExecutionThreaded </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the current script runs threaded</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.isScriptExecutionThreaded()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful, 0 if script execution is not threaded, &gt;0 if script execution is threaded<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simIsStackValueNull" id="simIsStackValueNull"></a>simIsStackValueNull</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Tests whether the value at the top of the stack is Null. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsStackValueNull(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the value is not null, 1 otherwise.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLaunchExecutable" id="simLaunchExecutable"></a>simLaunchExecutable / sim.launchExecutable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Launches an executable. Similar to os.execute or io.popen, but is system independent.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.launchExecutable(string filename,string parameters='',number showStatus=1)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>filename</strong>: file name of the executable. If the filename starts with '@', then it will be considered as a system command, otherwise the current directory might be automatically prepended to the filename if it makes sense.</div>
<div><strong>parameters</strong>: optional input arguments</div>
<div><strong>showStatus</strong>: 0 to hide the application's window, 1 to show it. Works only with Windows OS.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful. Under Windows OS, if the application could not be launched, return value is -1. Under Mac OS or Linux, return value might be different from -1 even if the application could not be launched.<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLaunchThreadedChildScripts" id="simLaunchThreadedChildScripts"></a>simLaunchThreadedChildScripts / sim.launchThreadedChildScripts </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Starts or restarts (if appropriately flagged) all <a href="childScripts.htm#threaded">threaded child scripts</a>. This command should only be called from the <a href="mainScript.htm">main script</a>. Refer also to following related functions: <a href="#simSwitchThread">sim.switchThread</a>, <a href="#simSetThreadSwitchTiming">sim.setThreadSwitchTiming</a>, <a href="#simSetThreadAutomaticSwitch">sim.setThreadAutomaticSwitch</a>, <a href="#simSetThreadIsFree">sim.setThreadIsFree</a>, <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a> and <a href="#simResumeThreads">sim.resumeThreads</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number launchCount=sim.launchThreadedChildScripts()</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>launchCount: number of launched threaded child scripts</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLoadImage" id="simLoadImage"></a>simLoadImage / sim.loadImage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads an image from file or memory. See also <a href="#simSaveImage">sim.saveImage</a>, <a href="#simGetScaledImage">sim.getScaledImage</a>, <a href="#simTransformImage">sim.transformImage</a> and <a href="#simSetVisionSensorCharImage">sim.setVisionSensorCharImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simUChar* simLoadImage(simInt* resolution,simInt options,const simChar* filenameOrBuffer,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>resolution</strong>: a pointer that will accept the image resolution.</div>
<div><strong>options</strong>: bit-coded. If bit0 is set (1), then the returned image is rgba, otherwise it is rgb.</div>
<div><strong>filename</strong>: the name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.</div>
<div><strong>reserved</strong>: Set to NULL if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful, otherwise a buffer containing the image data. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string image,table_2 resolution=sim.loadImage(number options,string filenameOrBuffer)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function. To load an image from a string buffer, simply prefix the buffer with &quot;@mem&quot;.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLoadModel" id="simLoadModel"></a>simLoadModel / sim.loadModel</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a previously saved model, and selects it. See also <a href="#simSaveModel">sim.saveModel</a>, <a href="#simLoadScene">sim.loadScene</a>, and <a href="#simSetBoolParameter">sim.setBoolParameter</a> with <a href="apiConstants.htm#booleanParameters">sim.boolparam_scene_and_model_load_messages</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadModel(const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;). An optional &quot;@copy&quot; can be appended to the filename, in which case the model's objects will be named/renamed as if an associated script was attached to the model.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise the handle of the model base object.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>a) number objectHandle=sim.loadModel(string filename)</div>
<div>b) number objectHandle=sim.loadModel(string buffer)</div>
<div>c) string rgbaImage=sim.loadModel(string filename,bool onlyThumbnail)</div>
<div>d) string rgbaImage=sim.loadModel(string buffer,bool onlyThumbnail)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>a) <strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;). An optional &quot;@copy&quot; can be appended to the filename, in which case the model's objects will be named/renamed as if an associated script was attached to the model.</div>
<div>b) <strong>buffer</strong>: a buffer containing the model</div>
<div>c)&amp;d) <strong>onlyThumbnail</strong>: when true, then only the thumbnail image of the model will be loaded and returned</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>a)&amp;b) -1 if operation was not successful. Otherwise the handle of the model base object.</div>
<div>c)&amp;d) nil if operation was not successful. Otherwise the model thumbnail image (128x128x4, rgba).</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxLoadModelFromBuffer">simxLoadModelFromBuffer</a>, <a href="b0RemoteApi-cpp.htm#simxLoadModelFromFile">simxLoadModelFromFile</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxLoadModel">simxLoadModel</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLoadModule" id="simLoadModule"></a>simLoadModule / sim.loadModule </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a V-REP <a href="plugins.htm">plugin</a>. This should usually be done in the <a href="mainClientApplication.htm">main client application</a>, just after <a href="#simRunSimulator">simRunSimulator</a> was called. Alternatively, you can also dynamically load/unload a plugin, but depending on the plugin function, this might not work/lead to a crash. In case the dynamically loaded plugin registers custom Lua functions, those functions cannot be used in scripts that were already initialized (except for the script that called <em>sim.loadModule</em>). Normally, all plugins of type <em>v_repExtXXX.dll</em> (or <em>libv_repExtXXX.so</em> or<em> libv_repExtXXX.dylib</em>) in the V-REP directory are loaded at application start. Plugins that are meant to be dynamically loaded should use a different name, or a different directory. See also <a href="#simSendModuleMessage">simSendModuleMessage</a> and <a href="#simUnloadModule">sim.unloadModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadModule(const simChar* filenameAndPath,const simChar* pluginName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><span class="apiTableRightCSyn"><strong>filenameAndPath</strong></span>: file name and path of the plugin</div>
<div><span class="apiTableRightCSyn"><strong>pluginName</strong></span>: name of the plugin. If the file name is <em>v_repExtXXX.dll</em>, then the name should be <em>XXX</em></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the plugin if value is 0 or positive. otherwise:</div>
<div class=tab>-3: plugin could not be loaded</div>
<div class=tab>-2: plugin is missing entry points</div>
<div class=tab>-1: plugin could not initialize</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number pluginHandle=sim.loadModule(string filenameAndPath,string pluginName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLoadScene" id="simLoadScene"></a>simLoadScene / sim.loadScene</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a previously saved scene.See also <a href="#simSaveScene">sim.saveScene</a>, <a href="#simLoadModel">sim.loadModel</a>, <a href="#simCloseScene">simCloseScene</a> and <a href="#simSetBoolParameter">sim.setBoolParameter</a> with <a href="apiConstants.htm#booleanParameters">sim.boolparam_scene_and_model_load_messages</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadScene(const simChar* filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: scene filename. The filename extension is required (&quot;ttt&quot;). By default, the current scene will be removed. Append &quot;@keepCurrent&quot; to the filename if the current scene should be preserved.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.loadScene(string filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxLoadScene">simxLoadScene</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxLoadScene">simxLoadScene</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simLockResources" id="simLockResources"></a>simLockResources</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Prepares V-REP for access to resources. The V-REP API functions normally automatically protect resources appropriately: when the non-GUI thread reads from or writes to resources, they will be protected (the lock always succeeds). When the GUI thread reads from or writes to resources, the protection might fail (i.e the lock will fail if the non-GUI thread has already locked resources for a longer time), in which case the API function will return with a fail error code. This can be troublesome in case a long succession of API calls is planned. In that case, you should additionally protect the API function calls with one initial call to simLockResources. See also <a href="#simUnlockResources">simUnlockResources</a> and <a href="#simGetThreadId">sim.getThreadId</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLockResources(simInt lockType,simInt reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>lockType</strong>: the <a href="apiConstants.htm#resourceLockTypes">lock type</a>.</div>
<div><strong>reserved</strong>: reserved. Set to -1.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if the lock has failed. Otherwise a lock handle. A locked should always eventually be released, otherwise you will experience a dead-lock or crash.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simModifyGhost" id="simModifyGhost"></a>simModifyGhost / sim.modifyGhost </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Modifies or removes a ghost object previously added with <a href="#simAddGhost">sim.addGhost</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simModifyGhost(simInt ghostGroup,simInt ghostId,simInt operation,simFloat floatValue,simInt options,simInt optionsMask,const simFloat* colorOrTransformation)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ghostGroup</strong>: an identifier that allows, together with <strong>ghostId</strong>, identifying which ghosts to modify.</div>
<div><strong>ghostId</strong>: an identifier that allows, together with <strong>ghostGroup</strong>, identifying which ghosts to modify. If -1, then all ghosts that match <strong>ghostGroup</strong> will be modified.</div>
<div><strong>operation</strong>: a value indicating the operation to perform:</div>
<div class=tab><strong>0</strong>: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.</div>
<div class=tab><strong>1</strong>: removes the specified ghosts. The return value indicates the number of removed ghosts.</div>
<div class=tab><strong>2</strong>: sets the start time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>3</strong>: sets the end time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>4</strong>: shifts the start time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>5</strong>: shifts the end time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>6</strong>: shifts the start and end times (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>7</strong>: scales the start time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>8</strong>: scales the end time (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>9</strong>: scales the start and end times (via <strong>floatValue</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>10</strong>: modifies the attributes (via <strong>options</strong> and <strong>optionsMask</strong>) of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>11</strong>: pre-multiplies (via <strong>colorOrTransformation</strong>) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>12</strong>: post-multiplies (via <strong>colorOrTransformation</strong>) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>13</strong>: modifies (via <strong>colorOrTransformation</strong>) the color of the specified ghosts. The return value indicates the number of modified ghosts.</div>
<div class=tab><strong>14</strong>: sets the transparency factor (via <strong>floatValue</strong>) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.</div>

<div><strong>floatValue</strong>: a floating point value that is used to modify the specified ghosts. See <strong>operation</strong> here above.</div>
<div><strong>options</strong>: the attributes used to modify the specified ghosts (see <strong>operation</strong> here above). Attributes are bit-coded:</div>
<div class=tab><strong>bit0</strong> reserved
<div class=tab><strong>bit1</strong> set (2)=the provided start- and end-times will be played-back in real-time</div>
<div class=tab><strong>bit2</strong> set (4)=preserve the original colors</div>
<div class=tab><strong>bit3</strong> reserved</div>
<div class=tab><strong>bit4</strong> set (16)=create an invisible ghost</div>
<div class=tab><strong>bit5</strong> set (32)=backface culling for the ghost (only when using custom colors)</div>

<div><strong>optionsMask</strong>: a mask allowing to select options to set.</div>
<div><strong>colorOrTransformation</strong>: a pointer to 7 or 12 float values: when <strong>operation</strong> is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when <strong>operation</strong> is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise a value depending on the <strong>operation</strong> performed.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.modifyGhost(number ghostGroup,number ghostId,number operation,number floatValue,number options=nil,number optionsMask=nil,table colorOrTransformation=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simMoveStackItemToTop" id="simMoveStackItemToTop"></a>simMoveStackItemToTop</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes the top item in the stack, effectively reducing the stack size by one. See also <a href="#simPopStackItem">simPopStackItem</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simMoveStackItemToTop(simInt stackHandle,simInt cIndex)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>cIndex</strong>: the zero-based index of the item to move.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simMoveToObject" id="simMoveToObject"></a>simMoveToObject / sim.moveToObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object to the position/orientation of another moving object (target object) by performing interpolations (i.e. the object will effectiviely follow the target object). If the target object is a path, a position on the path can be specified. If the target object is not moving, use rather <a href="#simGetObjectPosition">sim.getObjectPosition</a>, <a href="#simGetObjectOrientation">sim.getObjectOrientation</a> or <a href="#simGetPositionOnPath">sim.getPositionOnPath</a>, <a href="#simGetOrientationOnPath">sim.getOrientationOnPath</a> in conjunction with <a href="#simRMLMoveToPosition">sim.rmlMoveToPosition</a>. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simFollowPath">sim.followPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=sim.moveToObject(number objectHandle,number targetObjectHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number acceleration)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object to be moved</div>
<div><strong>targetObjectHandle</strong>: handle of the object to be followed</div>
<div><strong>positionAndOrOrientation</strong>: a value between 1 and 3 (1: only position is modified, 2: only orientation is modified, 3: position and orientation is modified). Can be nil in which case 3 is applied.<br>
</div>
<div><strong>relativeDistanceOnPath</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. Can be nil in which case the path object is treated as a regular object.<br>
</div>
<div><strong>velocity</strong>: movement velocity expressed in 1/s (i.e. the inverse of the velocity indicates the time that will be taken to reach the target object)<br>
</div>
<div><strong>acceleration</strong>: the acceleration/deceleration expressed in 1/s^2. Can be nil in which case an infinite acceleration is applied.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to reach the target object is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simMsgBox" id="simMsgBox"></a>simMsgBox / sim.msgBox </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a modal message box for interaction with the user.  See also <a href="#simFileDialog">sim.fileDialog</a> and <a href="#simDisplayDialog">sim.displayDialog</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simMsgBox(simInt dlgType,simInt buttons,const simChar* title,const simChar* message)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dlgType</strong>: the <a href="apiConstants.htm#msgBoxTypes">message box type</a>.</div>
<div><strong>buttons</strong>: the <a href="apiConstants.htm#msgBoxButtons">buttons to display</a>.</div>
<div><strong>title</strong>: title of the dialog</div>
<div><strong>message</strong>: the message to display</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a <a href="apiConstants.htm#msgBoxReturn">message box return value</a>. When the &lt;esc&gt; key, or the dialog close button was pressed, then the return value is:</div>
<div class=tab>yes/no dialog: sim.msgbox_return_no</div>
<div class=tab>ok dialog: sim.msgbox_return_ok</div>
<div class=tab>ok/cancel dialog: sim.msgbox_return_cancel</div>
<div class=tab>yes/no/cancel dialog: sim.msgbox_return_cancel</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number returnValue=sim.msgBox(number dlgType,number buttons,string title,string message)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simMultiplyMatrices" id="simMultiplyMatrices"></a>simMultiplyMatrices / sim.multiplyMatrices </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies two transformation matrices. See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simMultiplyMatrices(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat* matrixOut)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn1</strong>: the first input matrix</div>
<div><strong>matrixIn2</strong>: the second input matrix</div>
<div><strong>matrixOut</strong>: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).</div>
<div class=tab>A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 resultMatrix=sim.multiplyMatrices(table_12 matrixIn1,table_12 matrixIn2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultMatrix</strong>: the result matrix (a table containing 12 values (the last row (0,0,0,1) is omitted)). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simMultiplyVector" id="simMultiplyVector"></a>simMultiplyVector / sim.multiplyVector </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies a vector with a transformation matrix (v=m*v). See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>See <a href="#simTransformVector">simTransformVector</a></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 resultVector=sim.multiplyVector(table_12 matrix,table_3 vector)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: the transformation matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>vector</strong>: the original vector (a table containing 3 values (the last element (1) of the homogeneous coordinates is not required)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultVector</strong>: the result vector (a table containing 3 values (the last element (1) of the homogeneous coordinates is omitted))<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simOpenModule" id="simOpenModule"></a>simOpenModule / sim.openModule </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>&quot;Opens&quot; a plugin (allowing it to reserve resources at the start of a simulation). This command can only be called from the main script. Call it from the <a href="mainScript.htm">main script</a> in the first simulation pass (usually with sim.handle_all argument). <a href="#simOpenModule">sim.openModule</a> is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">sim.openModule</a>, <a href="#simHandleModule">sim.handleModule</a> and <a href="#simCloseModule">sim.closeModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=sim.openModule(number sim.handle_all)</div>
<div>(2) number result=sim.openModule(string moduleName)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>sim.handle_all: indicates that all plugins should be opened</div>
<div>moduleName: the name of the plugin that should be opened</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simOpenTextEditor" id="simOpenTextEditor"></a>simOpenTextEditor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a text edition window. The C version of this function opens a modal window, see <a href="#simTextEditorOpen">sim.textEditorOpen</a> for the Lua version of this function.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simOpenTextEditor(const simChar* initText,const simChar* xml,simInt* various)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>initText</strong>: a pointer to the initial text to be displayed.</div>
<div><strong>xml</strong>: a pointer to an XML description of the text editor's properties. Can be NULL for default properties. Following is a valid content:</div><br>

<pre class=lightRedBoxNoMarginAndSmall>&lt;editor title=&quot;Window title&quot; editable=&quot;true&quot; searchable=&quot;true&quot;
  tabWidth=&quot;4&quot; textColor=&quot;50 50 50&quot; backgroundColor=&quot;190 190 190&quot;
  selectionColor=&quot;128 128 255&quot; size=&quot;800 600&quot; position=&quot;100 100&quot; &gt;

  &lt;keywords1 color=&quot;152 0 0&quot; &gt;
    &lt;item word=&quot;sim.getObjectHandle&quot; autocomplete=&quot;true&quot;
      calltip=&quot;number handle=sim.getObjectHandle(number objectName)&quot; /&gt;
    &lt;item word=&quot;sim.getObjectPosition&quot; autocomplete=&quot;true&quot;
      calltip=&quot;table_3 pos=sim.getObjectPosition(number handle,
        number relHandle)&quot; /&gt;
  &lt;/keywords1&gt;
  &lt;keywords2 color=&quot;220 80 20&quot; &gt;
    &lt;item word=&quot;sim.getObjectOrientation&quot; autocomplete=&quot;true&quot;
      calltip=&quot;table_3 euler=sim.getObjectOrientation(number handle,
        number relHandle)&quot; /&gt;
  &lt;/keywords2&gt;
&lt;/editor&gt;</pre>

Other <em>editor</em> attributes with their default values are:

<pre class=lightRedBoxNoMarginAndSmall>isLua=&quot;false&quot;
useVrepKeywords=&quot;false&quot;
commentColor=&quot;0 140 0&quot;
numberColor=&quot;220 0 220&quot;
stringColor=&quot;255 255 0&quot;
characterColor=&quot;255 255 0&quot;
operatorColor=&quot;0 0 0&quot;
preprocessorColor=&quot;0 128 128&quot;
identifierColor=&quot;64 64 64&quot;
wordColor=&quot;0 0 255&quot;
word4Color=&quot;152 64 0&quot;</pre>

<div><strong>various</strong>: optional pointer holding the window size (various[0]-various[1]) and position (various[2],various[3]).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL in case of an error. Otherwise a pointer to the text. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>DEPRECATED. See <a href="#simTextEditorOpen">sim.textEditorOpen</a> instead.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackDoubleTable" id="simPackDoubleTable"></a>simPackDoubleTable / sim.packDoubleTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Packs a table of double floating-point numbers into a string. See also <a href="#simUnpackDoubleTable">sim.unpackDoubleTable</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packDoubleTable(table doubleNumbers,number startDoubleIndex=0,number doubleCount=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>doubleNumbers</strong>: a table containing double floating-point numbers. Non-numbers will be packed as zero values</div>
<div><strong>startDoubleIndex</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>doubleCount</strong>: the amount of doubles that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available doubles should be packed from the indicated startDoubleIndex)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed double floating-point numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackFloatTable" id="simPackFloatTable"></a>simPackFloatTable / sim.packFloatTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Packs a table of floating-point numbers into a string. See also <a href="#simUnpackFloatTable">sim.unpackFloatTable</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packFloatTable(table floatingNumbers,number startFloatIndex=0,number floatCount=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>floatingNumbers</strong>: a table containing floating-point numbers. Non-numbers will be packed as zero values</div>
<div><strong>startFloatIndex</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>floatCount</strong>: the amount of floats that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available floats should be packed from the indicated startFloatIndex)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed floating-point numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackInt32Table" id="simPackInt32Table"></a>simPackInt32Table / sim.packInt32Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Packs a table of int32 numbers into a string. See also <a href="#simUnpackInt32Table">sim.unpackInt32Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packInt32Table(table int32Numbers,number startInt32Index=0,number int32Count=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>int32Numbers</strong>: a table containing int32 numbers. Non-numbers will be packed as zero values</div>
<div><strong>startInt32Index</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>int32Count</strong>: the amount of int32s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available int32s should be packed from the indicated startInt32Index)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed int32 numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackTable" id="simPackTable"></a>simPackTable / sim.packTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Packs a table into a buffer. The table may contain other nested tables, nil, boolean, number or string values. All other types (e.g. functions) will be considered as string or nil values. You can also use sim.packTable to quickly compare two tables or to perform a deep copy of a table. See also <a href="#simUnpackTable">sim.unpackTable</a>, the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>  and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simPackTable(simInt stackHandle,simInt* bufferSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>. There must be a table located at the top of the stack.</div>
<div><strong>bufferSize</strong>: the size of the returned buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL in case of an error, otherwise a data buffer. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string buffer=sim.packTable(table aTable)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>aTable</strong>: a script table.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>buffer</strong>: a string buffer.</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackUInt16Table" id="simPackUInt16Table"></a>simPackUInt16Table / sim.packUInt16Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Packs a table of uint16 numbers into a string. See also <a href="#simUnpackUInt16Table">sim.unpackUInt16Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packUInt16Table(table uint16Numbers,number startUint16Index=0,number uint16Count=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>uint16Numbers</strong>: a table containing uint16 numbers. Invalid uint16 numbers will be packed in an undefined manner.</div>
<div><strong>startUint16Index</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>uint16Count</strong>: the amount of uint16s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint16s should be packed from the indicated startUint16Index)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed uint16 numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackUInt32Table" id="simPackUInt32Table"></a>simPackUInt32Table / sim.packUInt32Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Packs a table of uint32 numbers into a string. See also <a href="#simUnpackUInt32Table">sim.unpackUInt32Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packUInt32Table(table uint32Numbers,number startUint32Index=0,number uint32Count=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>uint32Numbers</strong>: a table containing uint32 numbers. Non-numbers will be packed as zero values</div>
<div><strong>startUint32Index</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>uint32Count</strong>: the amount of uint32s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint32s should be packed from the indicated startUint32Index)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed uint32 numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPackUInt8Table" id="simPackUInt8Table"></a>simPackUInt8Table / sim.packUInt8Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Packs a table of uint8 numbers into a string. See also <a href="#simUnpackUInt8Table">sim.unpackUInt8Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.packUInt8Table(table uint8Numbers,number startUint8Index=0,number uint8count=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>uint8Numbers</strong>: a table containing uint8 numbers. Invalid byte number will be packed in an undefined manner.</div>
<div><strong>startUint8Index</strong>: the zero-based index from which on data should be packed. Can be omitted in which case 0 is used</div>
<div><strong>uint8count</strong>: the amount of uint8s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint8s should be packed from the indicated startUint8Index)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains the uint8 numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPauseSimulation" id="simPauseSimulation"></a>simPauseSimulation / sim.pauseSimulation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a pause of a simulation. See also <a href="#simStartSimulation">sim.startSimulation</a>, <a href="#simStopSimulation">sim.stopSimulation</a> and <a href="#simGetSimulationState">sim.getSimulationState</a>. See also the <a href="simulation.htm">simulation state diagram</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPauseSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.pauseSimulation()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxPauseSimulation">simxPauseSimulation</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxPauseSimulation">simxPauseSimulation</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPersistentDataRead" id="simPersistentDataRead"></a>simPersistentDataRead / sim.persistentDataRead </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads a block of persistent data. See also <a href="#simPersistentDataWrite">sim.persistentDataWrite</a>, <a href="#simGetPersistentDataTags">sim.getPersistentDataTags</a>, <a href="#simGetStringSignal">sim.getStringSignal</a>, <a href="#simGetIntegerSignal">sim.getIntegerSignal</a>,  <a href="#simGetDoubleSignal">sim.getDoubleSignal</a> and <a href="#simReadCustomDataBlock">sim.readCustomDataBlock</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simPersistentDataRead(const simChar* dataTag,simInt* dataLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataTag</strong>: name of the data block</div>
<div><strong>dataLength</strong>: the size of the returned data block, since it may contain any data (also embedded zeros).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or data block does not exist, otherwise the data block (which may contain any value, including embedded zeros). In that case the returned buffer should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string dataValue=sim.persistentDataRead(string dataTag)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>

<div><strong>dataTag</strong>: name of the data block</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>dataValue</strong>: value of the data block, or nil if operation was not successful or data block does not exist. The returned data block may contain any value, including embedded zeros.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPersistentDataWrite" id="simPersistentDataWrite"></a>simPersistentDataWrite / sim.persistentDataWrite </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Writes a persistent data block. Persistent data, valid across all opened simulator scenes, remains until the simulator ends, or until it is cleared by writing an empty data block. If the options flag is set appropriately, then persistent data can also be stored on file, and be automatically reloaded next time V-REP starts. See also <a href="#simPersistentDataRead">sim.persistentDataRead</a>, <a href="#simSetStringSignal">sim.setStringSignal</a>, <a href="#simSetIntegerSignal">sim.setIntegerSignal</a>, <a href="#simSetDoubleSignal">sim.setDoubleSignal</a> and <a href="#simWriteCustomDataBlock">sim.writeCustomDataBlock</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPersistentDataWrite(const simChar* dataTag,const simChar* dataValue,simInt dataLength,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataTag</strong>: name of the data block</div>
<div><strong>dataValue</strong>: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).</div>
<div><strong>dataLength</strong>: the size of the data block.</div>
<div><strong>options</strong>: bit-coded. If bit 0 is set (1), then the data is also stored on file ("system/persistentData.dat"), and automatically reloaded next time V-REP start.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.persistentDataWrite(string dataTag,string dataValue,number options=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPopStackItem" id="simPopStackItem"></a>simPopStackItem</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes the top item in the stack, effectively reducing the stack size by one. See also <a href="#simMoveStackItemToTop">simMoveStackItemToTop</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPopStackItem(simInt stackHandle,simInt count)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>count</strong>: the number of items to pop, or 0 to clear the stack.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the new size of the stack.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushBoolOntoStack" id="simPushBoolOntoStack"></a>simPushBoolOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a Boolean value onto the stack. The value will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushBoolOntoStack(simInt stackHandle,simBool value)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>value</strong>: the value to push.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushDoubleOntoStack" id="simPushDoubleOntoStack"></a>simPushDoubleOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a double precision value (i.e. a Lua number) onto the stack. The value will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushDoubleOntoStack(simInt stackHandle,simDouble value)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>value</strong>: the value to push.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushDoubleTableOntoStack" id="simPushDoubleTableOntoStack"></a>simPushDoubleTableOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a double-precision array onto the stack, as a table filled with Lua numbers. The table will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushDoubleTableOntoStack(simInt stackHandle,const simDouble* values,simInt valueCnt)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>values</strong>: a double-precision array.</div>
<div><strong>valueCnt</strong>: the size of the array.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushFloatOntoStack" id="simPushFloatOntoStack"></a>simPushFloatOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a float value (i.e. a Lua number) onto the stack. The value will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushFloatOntoStack(simInt stackHandle,simFloat value)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>value</strong>: the value to push.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushFloatTableOntoStack" id="simPushFloatTableOntoStack"></a>simPushFloatTableOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a float array onto the stack, as a table filled with Lua numbers. The table will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushFloatTableOntoStack(simInt stackHandle,const simFloat* values,simInt valueCnt)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>values</strong>: a float array.</div>
<div><strong>valueCnt</strong>: the size of the array.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushInt32OntoStack" id="simPushInt32OntoStack"></a>simPushInt32OntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes an int32 value (i.e. a Lua number) onto the stack. The value will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushInt32OntoStack(simInt stackHandle,simInt value)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>value</strong>: the value to push.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushInt32TableOntoStack" id="simPushInt32TableOntoStack"></a>simPushInt32TableOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes an int32 array onto the stack, as a table filled with Lua numbers. The table will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushInt32TableOntoStack(simInt stackHandle,const simInt* values,simInt valueCnt)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>values</strong>: an int32 array.</div>
<div><strong>valueCnt</strong>: the size of the array.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushNullOntoStack" id="simPushNullOntoStack"></a>simPushNullOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes the value Null (or nil) onto the stack. The value will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushNullOntoStack(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushStringOntoStack" id="simPushStringOntoStack"></a>simPushStringOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a string onto the stack. The string may contain any values, including embedded zeros. The string will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushStringOntoStack(simInt stackHandle,const simChar* value,simInt stringSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>value</strong>: the string.</div>
<div><strong>stringSize</strong>: the length of the string. If you specify 0, the string is a text string and its length will be automatically determined.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushTableOntoStack" id="simPushTableOntoStack"></a>simPushTableOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes an empty table onto the stack. The table will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushTableOntoStack(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simPushUInt8TableOntoStack" id="simPushUInt8TableOntoStack"></a>simPushUInt8TableOntoStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Pushes a uint8 array onto the stack, as a table filled with Lua numbers. The table will then be located at the top of the stack. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPushUInt8TableOntoStack(simInt stackHandle,const simUChar* values,simInt valueCnt)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
<div><strong>values</strong>: a uint8 array.</div>
<div><strong>valueCnt</strong>: the size of the array.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simQuitSimulator" id="simQuitSimulator"></a>simQuitSimulator / sim.quitSimulator </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Triggers a quit signal that will eventually quits the application. See also <a href="#simRunSimulator">simRunSimulator</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid simQuitSimulator(simBool doNotDisplayMessages)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>doNotDisplayMessages</strong>: when true, will force quit.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>sim.quitSimulator(boolean doNotDisplayMessages)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLMoveToJointPositions" id="simRMLMoveToJointPositions"></a>simRMLMoveToJointPositions / sim.rmlMoveToJointPositions 
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves (actuates) several joints at the same time using the <a href="http://www.reflexxes.com">Reflexxes Motion Library type II or IV</a>. This function   can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is   a blocking operation) and is not available from the C-API.  See also <a href="#simRMLMoveToPosition">sim.rmlMoveToPosition</a>, and <a href="#simRMLPos">sim.rmlPos</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table newPos,table newVel,table newAccel,number timeLeft=sim.rmlMoveToJointPositions(table jointHandles,number flags,table currentVel,table currentAccel,table maxVel,table maxAccel,table maxJerk,table targetPos,table targetVel,table direction)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>jointHandles</strong>: handles of the joints to actuate</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentVel</strong>: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.</div>
<div><strong>currentAccel</strong>: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.</div>
<div><strong>maxVel</strong>: the maximum allowed velocity  of the joints</div>
<div><strong>maxAccel</strong>: the maximum allowed acceleration  of the joints</div>
<div><strong>maxJerk</strong>: the maximum allowed jerk  of the joints. With the RML type II plugin, the max. jerk will however always be infinite.</div>
<div><strong>targetPos</strong>: the desired target positions of the joints</div>
<div><strong>targetVel</strong>: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.</div>
<div><strong>direction</strong>: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the function call was successful</div>
<div><strong>newPos</strong>: the new positions of the joints</div>
<div><strong>newVel</strong>: the new velocities of the joints</div>
<div><strong>newAccel</strong>: the new accelerations of the joints</div>
<div><strong>timeLeft</strong>: the time left for additional calculations in current simulation time step</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLMoveToPosition" id="simRMLMoveToPosition"></a>simRMLMoveToPosition / sim.rmlMoveToPosition 
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object to a given position and/or orientation using the <a href="http://www.reflexxes.com">Reflexxes Motion Library type II or IV</a>. This function   can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is   a blocking operation) and is not available from the C-API.  See also <a href="#simRMLMoveToJointPositions">sim.rmlMoveToJointPositions</a>, <a href="#simRMLPos">sim.rmlPos</a>, <a href="#simMoveToObject">sim.moveToObject</a> and <a href="#simFollowPath">sim.followPath</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_3 newPos,table_4 newQuaternion,table_4 newVel,table_4 newAccel,number timeLeft=sim.rmlMoveToPosition(number objectHandle,number relativeToObjectHandle,number flags,table_4 currentVel,table_4 currentAccel,table_4 maxVel,table_4 maxAccel,table_4 maxJerk,table_3 targetPosition,table_4 targetQuaternion,table_4 targetVel)

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of the object to be moved</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the movement data is specified. Specify -1 for a movement relative to the absolute reference   frame, sim.handle_parent for a movement relative to the object's parent   frame, or an object handle relative to whose reference frame the   movement should be performed.</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentVel</strong>: the current velocity of the object (velX, velY, velZ, velAngle). Can be nil in which case a velocity vector of 0 is used.</div>
<div><strong>currentAccel</strong>: the current acceleration of the object (accelX, accelY, accelZ, accelAngle). Can be nil in which case an acceleration vector of 0 is used.</div>
<div><strong>maxVel</strong>: the maximum allowed velocity  of the object (maxVelX, maxVelY, maxVelZ, maxVelAngle)</div>
<div><strong>maxAccel</strong>: the maximum allowed acceleration  of the object (maxAccelX, maxAccelY, maxAccelZ, maxAccelAngle)</div>
<div><strong>maxJerk</strong>: the maximum allowed jerk  of the object (maxJerkX, maxJerkY, maxJerkZ, maxJerkAngle). With the RML type II plugin, the max. jerk will however always be infinite.</div>
<div><strong>targetPosition</strong>: the desired target position of the object (expressed relative to <em>relativeToObjectHandle</em>). Can be nil, in which case the position of the object will stay constant</div>
<div><strong>targetQuaternion</strong>: the desired target orientation of the object (expressed relative to <em>relativeToObjectHandle</em>). Can be nil, in which case the orientation of the object will stay constant</div>
<div><strong>targetVel</strong>: the desired velocity of the object at the target (targetVelX, targetVelY, targetVelZ, targetVelAngle). Can be nil in which case a velocity vector of 0 is used.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the function call was successful</div>
<div><strong>newPos</strong>: the new relative position of the object</div>
<div><strong>newQuaternion</strong>: the new relative orientation of the object</div>
<div><strong>newVel</strong>: the new velocity vector (velX, velY, velZ, velAngle)</div>
<div><strong>newAccel</strong>: the new acceleration vector (accelX, accelY, accelZ, accelAngle)</div>
<div><strong>timeLeft</strong>: the time left for additional calculations in current simulation time step</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLPos" id="simRMLPos"></a>simRMLPos / sim.rmlPos </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes a call to the <a href="http://www.reflexxes.com">Reflexxes Motion Library type II or IV</a>. The Reflexxes Motion Library provides instantaneous trajectory generation capabilities for motion control systems. This function prepares a  position-based trajectory generation object, that can then be calculated with <a href="#simRMLStep">sim.rmlStep</a>. When this object is not needed anymore, remove it with <a href="#simRMLRemove">sim.rmlRemove</a>. See also <a href="#simRMLVel">sim.rmlVel</a>, <a href="#simRMLMoveToPosition">sim.rmlMoveToPosition</a> and <a href="#simRMLMoveToJointPositions">sim.rmlMoveToJointPositions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLPos(simInt dofs,simDouble smallestTimeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxVelAccelJerk,const simBool* selection,const simDouble* targetPosVel,simVoid* auxData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dofs</strong>: the number of degrees of freedom (N).</div>
<div><strong>smallestTimeStep</strong>: the smallest expected cycle time. Use a value of 0.0001 (0.1ms).</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentPosVelAccel</strong>: the current position, velocity and acceleration. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>

<div><strong>maxVelAccelJerk</strong>: the maximum allowed velocity, acceleration and jerk. Arrange values as {vel1,vel2,..,velN,accel1,accel2,..,accelN,jerk1,jerk2,..,jerkN}. With the RML type II plugin, the max. jerk will however always be infinite.</div>
<div><strong>selection</strong>: the selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</div>

<div><strong>targetPosVel</strong>: the  target position and velocity. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN}</div>
<div><strong>auxData</strong>: can be NULL. Otherwise in/out extension data. The first byte indicates how many additional in/out values we wish to set/get. Following  auxiliary values can be set/get:</div>
<div class=tab>value 1 (input): Bytes 2-5 (int):  set to 1 if you wish this object to be automatically destroyed at simulation end (which is the default case when called from the main script or a child script).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the handle of the created object.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number handle=sim.rmlPos(number dofs,number smallestTimeStep,number flags,table currentPosVelAccel,table maxVelAccelJerk,table selection,table targetPosVel)
<br>
<br>

<div>If you wish to use this function in a blocking mode, consider using <a href="#simRMLMoveToPosition">sim.rmlMoveToPosition</a> or <a href="#simRMLMoveToJointPositions">sim.rmlMoveToJointPositions</a> instead.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLRemove" id="simRMLRemove"></a>simRMLRemove / sim.rmlRemove </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object previously created via <a href="#simRMLPos">sim.rmlPos</a> or <a href="#simRMLVel">sim.rmlVel</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLRemove(simInt handle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>handle</strong>: the handle of the object created via <a href="#simRMLPos">simRMLPos</a> or <a href="#simRMLVel">simRMLVel</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 in case of success</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.rmlRemove(number handle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLStep" id="simRMLStep"></a>simRMLStep / sim.rmlStep </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes a call to the <a href="http://www.reflexxes.com">Reflexxes Motion Library type II or IV</a>. The Reflexxes Motion Library provides instantaneous trajectory generation capabilities for motion control systems. This function steps forward a trajectory generation algorithm previously prepared via <a href="#simRMLPos">sim.rmlPos</a> or <a href="#simRMLVel">sim.rmlVel</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLStep(simInt handle,simDouble timeStep,simDouble* newPosVelAccel,simVoid* auxData,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>handle</strong>: the handle of the object created via <a href="#simRMLPos">simRMLPos</a> or <a href="#simRMLVel">simRMLVel</a>.</div>
<div><strong>timeStep</strong>: the cycle time</div>
<div><strong>newPosVelAccl</strong>: the new position, velocity and acceleration (output values). Values are arranged as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>
<div><strong>auxData</strong>: can be NULL. Otherwise in/out extension data. The first byte indicates how many additional in/out values we wish to set/get. Following  auxiliary values can be set/get:</div>
<div class=tab>value 1 (output): Bytes 2-9 (double):  returns the <strong>synchronization time</strong> (the time needed to reach the desired state. This time does not include the cycle time of the current call to simRMLStep)</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the return value of function RMLPosition or RMLVelocity in the Reflexxes Motion Library:</div>
<div class=tab>1: final state reached</div>
<div class=tab>0: final state not yet reached</div>
<div class=tab>-100: RML_ERROR_INVALID_INPUT_VALUES</div>
<div class=tab>-101: RML_ERROR_EXECUTION_TIME_CALCULATION</div>
<div class=tab>-102: RML_ERROR_SYNCHRONIZATION</div>
<div class=tab>-103: RML_ERROR_NUMBER_OF_DOFS</div>
<div class=tab>-104: RML_ERROR_NO_PHASE_SYNCHRONIZATION</div>
<div class=tab>-105: RML_ERROR_NULL_POINTER</div>
<div class=tab>-106: RML_ERROR_EXECUTION_TIME_TOO_BIG</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table newPosVelAccel,number synchronizationTime=sim.rmlStep(number handle,number timeStep)
<br>
<br>

<div>If you wish to use this function in a blocking mode, consider using <a href="#simRMLMoveToPosition">sim.rmlMoveToPosition</a> or <a href="#simRMLMoveToJointPositions">sim.rmlMoveToJointPositions</a> instead.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRMLVel" id="simRMLVel"></a>simRMLVel / sim.rmlVel </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes a call to the <a href="http://www.reflexxes.com">Reflexxes Motion Library type II or IV</a>. The Reflexxes Motion Library provides instantaneous trajectory generation capabilities for motion control systems. This function prepares a  velocity-based trajectory generation object, that can then be calculated with <a href="#simRMLStep">sim.rmlStep</a>. When this object is not needed anymore, remove it with <a href="#simRMLRemove">sim.rmlRemove</a>. See also <a href="#simRMLPos">sim.rmlPos</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLVel(simInt dofs,simDouble smallestTimeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxAccelJerk,const simBool* selection,const simDouble* targetVel,simVoid* auxData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dofs</strong>: the number of degrees of freedom (N).</div>
<div><strong>smallestTimeStep</strong>: the smallest expected cycle time. Use a value of 0.0001 (0.1ms).</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentPosVelAccel</strong>: the current position, velocity and acceleration. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>

<div><strong>maxAccelJerk</strong>: the maximum allowed acceleration and jerk. Arrange values as {accel1,accel2,..,accelN,jerk1,jerk2,..,jerkN}. With the RML type II plugin, the max. jerk will however always be infinite.</div>
<div><strong>selection</strong>: the selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</div>

<div><strong>targetVel</strong>: the  target velocity (one value for each DoF)</div>
<div><strong>auxData</strong>: can be NULL. Otherwise in/out extension data. The first byte indicates how many additional in/out values we wish to set/get. Following  auxiliary values can be set/get:</div>
<div class=tab>value 1 (input): Bytes 2-5 (int):  set to 1 if you wish this object to be automatically destroyed at simulation end (which is the default case when called from the main script or a child script).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the handle of the created object.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number handle=sim.rmlVel(number dofs,number smallestTimeStep,number flags,table currentPosVelAccel,table maxAccelJerk,table selection,table targetVel)
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadCollision" id="simReadCollision"></a>simReadCollision / sim.readCollision</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the collision state of a registered collision object. This function doesn't perform collision detection, it merely reads the result from a previous call to <a href="#simHandleCollision">sim.handleCollision</a> (sim.handleCollision is called in the default main script). See also <a href="#simResetCollision">sim.resetCollision</a>, <a href="#simCheckCollision">sim.checkCollision</a> and <a href="#simCheckCollisionEx">sim.checkCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>collision state (0 or 1), or -1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionState, table_2 collidingObjectHandles=sim.readCollision(number collisionObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>collisionState</strong>: collision state (0 or 1), or -1 if operation was not successful.</div>
<div><strong>collidingObjectHandles</strong>: handles of the two colliding objects.</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxReadCollision">simxReadCollision</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxReadCollision">simxReadCollision</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadCustomDataBlock" id="simReadCustomDataBlock"></a>simReadCustomDataBlock / sim.readCustomDataBlock </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads custom data that is stored inside of an object, a script or a scene (i.e. the data is part of the object, the script or the scene).  Reads also custom data for the application's currrent session. See also <a href="#simWriteCustomDataBlock">sim.writeCustomDataBlock</a>, <a href="#simReadCustomDataBlockTags">sim.readCustomDataBlockTags</a> and the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simReadCustomDataBlock(simInt objectHandle,const simChar* tagName,simInt* dataSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.</div>
<div><strong>tagName</strong>: a string that identifies the data. <br>
</div>
<div><strong>dataSize</strong>: a pointer to an integer receiving the size of the returned buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>the custom data block, or nil in case of an error (or if the data is not present). The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string customDataBlock=sim.readCustomDataBlock(number objectHandle,string tagName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. In addition, you can specify sim.handle_self for the <strong>objectHandle</strong> argument, if your target is the current script.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadCustomDataBlockTags" id="simReadCustomDataBlockTags"></a>simReadCustomDataBlockTags / sim.readCustomDataBlockTags </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the tags of all custom data that is stored inside of an object, a script or a scene (i.e. the data is part of the object, the script or the scene).  Reads also all custom data that is stored inside of the application's current session. See also <a href="#simReadCustomDataBlock">sim.readCustomDataBlock</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simReadCustomDataBlockTags(simInt objectHandle,simInt* tagCount)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.</div>
<div><strong>tagCount</strong>: a pointer to an integer receiving the number of tag strings contained in the returned buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>the tags (each followed by the zero-char) or nil in case of an error (or if no tags are present). The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table tags=sim.readCustomDataBlockTags(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. In addition, you can specify sim.handle_self for the <strong>objectHandle</strong> argument, if your target is the current script.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadDistance" id="simReadDistance"></a>simReadDistance / sim.readDistance</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the distance of a registered distance object. This function doesn't perform distance measurement, it merely reads the result from a previous call to <a href="#simHandleDistance">sim.handleDistance</a> (sim.handleDistance is called in the default main script). See also <a href="#simResetDistance">sim.resetDistance</a> and <a href="#simCheckDistance">sim.checkDistance</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadDistance(simInt distanceObjectHandle,simFloat* smallestDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object</div>
<div><strong>smallestDistance</strong>: smallest distance (valid only if return value is different from -1)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>different from -1 if distance was read, -1 in case of an error.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number smallestDistance=sim.readDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if distance was read, -1 in case of an error, and 0 if <a href="#simHandleDistance">sim.handleDistance</a> was never called, or if <a href="#simResetDistance">sim.resetDistance</a> was previously called.<br>
</div>
<div><strong>smallestDistance</strong>: the smallest distance. Is nil if result is not 1</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxReadDistance">simxReadDistance</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxReadDistance">simxReadDistance</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadForceSensor" id="simReadForceSensor"></a>simReadForceSensor / sim.readForceSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the force and torque applied to a force sensor (filtered values are read), and its current state ('unbroken' or 'broken'). See also <a href="#simBreakForceSensor">sim.breakForceSensor</a> and <a href="#simGetJointForce">sim.getJointForce</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadForceSensor(simInt objectHandle,simFloat* forceVector,simFloat* torqueVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object (must be a force sensor). Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_rawvalue</a> (simply add sim_handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="callbackFunctions.htm">callback function</a> triggered by the physics engine.</div>
<div><strong>forceVector</strong>: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULL</div>
<div><strong>torqueVector</strong>: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise bit-coded:</div>
<div class=tab>bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)<br>
</div>
<div class=tab>bit 1 set (2): force sensor is broken, otherwise it is still intact ('unbroken')<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result, table_3 forceVector,table_3 torqueVector=sim.readForceSensor(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise bit-coded (same as for the C-function return value)</div>
<div><strong>forceVector</strong>: table holding 3 values (applied forces along the sensor's x, y and z-axes)</div>
<div><strong>torqueVector</strong>: table holding 3 values (applied torques about the sensor's x, y and z-axes)</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxReadForceSensor">simxReadForceSensor</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxReadForceSensor">simxReadForceSensor</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadProximitySensor" id="simReadProximitySensor"></a>simReadProximitySensor / sim.readProximitySensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the state of a proximity sensor. This function doesn't perform detection, it merely reads the result from a previous call to <a href="#simHandleProximitySensor">sim.handleProximitySensor</a> (sim.handleProximitySensor is called in the default main script). See also <a href="#simCheckProximitySensor">sim.checkProximitySensor</a>, <a href="#simCheckProximitySensorEx">sim.checkProximitySensorEx</a> and <a href="#simResetProximitySensor">sim.resetProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadProximitySensor(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* detectedSurfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object</div>
<div><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be NULL<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleProximitySensor">simHandleProximitySensor</a> was never called, or if <a href="#simResetProximitySensor">simResetProximitySensor</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 detectedSurfaceNormalVector=sim.readProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleProximitySensor">sim.handleProximitySensor</a> was never called, or if <a href="#simResetProximitySensor">sim.resetProximitySensor</a> was previously called.<br>
</div>
<div><strong>distance</strong>: distance to the detected point if result is 1, nil otherwise<br>
</div>
<div><strong>detectedPoint</strong>: table of 3 numbers indicating the relative coordinates of the detected point if result is 1, nil otherwise<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected if result is 1, nil otherwise<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxReadProximitySensor">simxReadProximitySensor</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxReadProximitySensor">simxReadProximitySensor</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadTexture" id="simReadTexture"></a>simReadTexture / sim.readTexture </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the RGB data (or a portion of it) related to a specific texture. See also <a href="#simGetTextureId">sim.getTextureId</a>, <a href="#simWriteTexture">sim.writeTexture</a> and <a href="#simCreateTexture">sim.createTexture</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simReadTexture(simInt textureId,simInt options,simInt posX,simInt posY,simInt sizeX,simInt sizeY)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>textureId</strong>: the ID of the texture. See also <a href="#simGetTextureId">simGetTextureId</a>.</div>
<div><strong>options</strong>: reserved for future functionality. Set to zero.</div>
<div><strong>posX / posY</strong>: the x/y position of the texture portion to retrieve. Set to 0/0 to retrieve the full texture</div>
<div><strong>sizeX / sizeY</strong>: the x/y size of the texture portion to retrieve. Set to 0/0 to retrieve the full texture</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The texture data, or NULL in case of an error. The texture data contains RGB values between 0-255 (3 bytes per pixel). The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string textureData=sim.readTexture(number textureId,number options,number posX=0,number posY=0,number sizeX=0,number sizeY=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReadVisionSensor" id="simReadVisionSensor"></a>simReadVisionSensor / sim.readVisionSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the state of a vision sensor. This function doesn't perform detection, it merely reads the result from a previous call to <a href="#simHandleVisionSensor">sim.handleVisionSensor</a> (sim.handleVisionSensor is called in the default main script). See also <a href="#simCheckVisionSensor">sim.checkVisionSensor</a>, <a href="#simCheckVisionSensorEx">sim.checkVisionSensorEx</a> and <a href="#simResetVisionSensor">sim.resetVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadVisionSensor(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object</div>
<div><strong>auxValues</strong>: auxiliary values returned from the <a href="visionSensorFilterComposition.htm">applied filters</a>. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues).<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>See <a href="#simHandleVisionSensor">simHandleVisionSensor</a> for a usage example</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleVisionSensor">simHandleVisionSensor</a> was never called, or if <a href="#simResetVisionSensor">simResetVisionSensor</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=sim.readVisionSensor(number visionSensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleVisionSensor">sim.handleVisionSensor</a> was never called, or if <a href="#simResetVisionSensor">sim.resetVisionSensor</a> was previously called.<br>
</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxReadVisionSensor">simxReadVisionSensor</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxReadVisionSensor">simxReadVisionSensor</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReceiveData" id="simReceiveData"></a>simReceiveData / sim.receiveData </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Receives wireless data (in a simulation). See also <a href="#simSendData">sim.sendData</a> and <a href="#simTubeOpen">sim.tubeOpen</a>. Cannot be called from <a href="addOns.htm">add-ons</a>.<br>
<br>
Wireless receptions can be visualized globally via the <a href="environmentPropertiesDialog.htm">environment dialog</a>, or individually as in following example:
<pre class=lightRedBoxNoMarginAndSmall>
sim.setBoolParameter(sim.boolparam_force_show_wireless_reception,true)
data=sim.receiveData(...)
sim.setBoolParameter(sim.boolparam_force_show_wireless_reception,false)</pre></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simReceiveData(simInt dataHeader,const simChar* dataName,simInt antennaHandle,simInt index,simInt* dataLength,simInt* senderID,simInt* dataHeaderR,simChar** dataNameR)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). </div>
<div><strong>dataName</strong>: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)<br>
</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.<br>
</div>
<div><strong>index</strong>: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.<br>
</div>
<div><strong>dataLength</strong>: length of the received data (if returned pointer is not NULL)<br>
</div>
<div><strong>senderID</strong>: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.<br>
</div>
<div><strong>dataHeaderR</strong>: dataHeader of the data that was read. Can be NULL.</div>
<div><strong>dataNameR</strong>: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*dataNameR).<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the received data, or NULL if no data is available or in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data,number senderID,number dataHeader,string dataName=sim.receiveData(number dataHeader=-1,string dataName=nil,number antennaHandle=sim.handle_self,number index=-1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). This value can be omitted (-1 will be used).</div>
<div><strong>dataName</strong>: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1). This value can be omitted (nill will be used)<br>
</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this reception. If sim.handle_default is specified, a reception antenna at (0,0,0) is simulated. If sim.handle_self is specified, the object associated with the current child script is used as the antenna. This value can be omitted (sim.handle_self will be used)<br>
</div>
<div><strong>index</strong>: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read. This value can be omitted (-1 will be used)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: string containing the received data, or nil in case of an error or if no data is present. If received data is packed, see also the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a></div>
<div><strong>senderID</strong>: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API.<br>
</div>
<div><strong>dataHeader</strong>: dataHeader of the data that was read.<br>
</div>
<div><strong>dataName</strong>: dataName of the data that was read.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRefreshDialogs" id="simRefreshDialogs"></a>simRefreshDialogs / sim.refreshDialogs </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Refreshes V-REP's internal dialogs. Calling <a href="#simRefreshDialogs">sim.refreshDialogs</a> will not trigger a <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_refreshdialogs</a> message<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRefreshDialogs(simInt refreshDegree)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>refreshDegree</strong>: refresh degree (0=light, 1=medium, 2=full)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.refreshDialogs(number refreshDegree)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRegisterScriptCallbackFunction" id="simRegisterScriptCallbackFunction"></a>simRegisterScriptCallbackFunction</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Registers a custom script function, that calls back a c/c++ function. This function is useful for plugins that wish to provide their own or customized script functions. See also <a href="#simRegisterScriptVariable">simRegisterScriptVariable</a>.
<br><br>
<div>Data exchange between a script and the plugin happens via a <a href="apiFunctionListCategory.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious, if your data structures are anyway relatively simple. In that case you can use the helper classes <em>CScriptFunctionData</em> and <em>CScriptFunctionDataItem</em> located in <em>programming/common</em> and <em>programming/include</em>: they will greatly simplify the task.</div>
<br>
<div>Use following 4 functions in the helper class: <em>readDataFromStack</em>, <em>getInDataPtr</em>, <em>pushOutData</em> and <em>writeDataToStack</em>.</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRegisterScriptCallbackFunction(const simChar* funcNameAtPluginName,const simChar* callTips,simVoid(*callBack)(struct SScriptCallBack* cb))<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>functNameAtPluginName</strong>: name of the function, combined with the plugin name: functionName@pluginName. Avoid using too simple function names, otherwise they might clash with other plugins. Also, always use the <em>simXX.</em> prefix (e.g. <em>simMyPlugin.myCustomFunction</em>) for the function name. The plugin name should be the exact same name used while loading the plugin via <a href="#simLoadModule">simLoadModule</a> (if the plugin name is <em>v_repExtMyPlugin.dll</em>, this should be <em>MyPlugin</em>).<br>
</div>
<div><strong>callTips</strong>: call tips: string (or several strings separated by '@') that indicates the input/output argument type/size. Call tips appear in the script editor when the function was typed followed by &quot;(&quot;. callTips Can be NULL, in which case no call tips will be displayed, nor syntax highlighting used.<br>
</div>
<div><strong>callback</strong>: callback address that is called when the &quot;functName&quot; function is called from Lua. Can be NULL, in which case the command will only register the function for call tips and syntax highlighting. See further down for a simple way to call above function, using a helper class. The callback's first argument is a SScriptCallBack structure that holds:<br>
</div>
<br>
<div><strong>simInt objectID</strong>: handle of the object that the calling script is attached to, or -1 if the calling script is not a child script<br>
</div>
<div><strong>simInt scriptID</strong>: handle of the calling script<br>
</div>
<div><strong>simInt stackID</strong>: a <a href="#simCreateStack">stack handle</a>. The stack is used to read arguments from the script, and to return data to the script.  See also the <a href="apiFunctionListCategory.htm#stacks">available stack functions</a>.<br>
</div>
<div><strong>simChar waitUntilZero</strong>: this value can be used when threaded scripts call a custom Lua function in a plugin that shouldn't return until a condition is met (e.g. until the robot movement finished). For that purpose, the plugin should write a value different from zero to indicate a &quot;wait&quot; state. When the callback returns, the control is not given back to the script until some other thread calling the plugin writes zero to that location. Once zero was written, the memory location should not be used anymore (because it might be released anytime by the simulator). Also, when the user stops a simulation before zero was written to that location, the wait state is aborted. In that case however the memory location stays valid (i.e. writing zero will not result in a crash) until the simulation ended.<br>
</div>
<div><strong>simChar* raiseErrorWithMessage</strong>: max. 256 bytes are available here for an error message. This buffer is allocated by V-REP and initially contains a zero length string. If the length of the string is not zero, a script error will be raised and the message displayed in the status bar.
</div>
<br>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if function was registered, 0 if function was replaced (when that function name already existed), -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>see <a href="#simRegisterScriptFunction">sim.registerScriptFunction</a> instead.</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRegisterScriptFunction" id="simRegisterScriptFunction"></a>sim.registerScriptFunction</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr><div>Registers a script function for auto-completion, syntax highlighting and call-tip display (in the V-REP internal code editor). Useful for script function definitions inside of a Lua file, loaded by a plugin.</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>See <a href="#simRegisterScriptCallbackFunction">simRegisterScriptCallbackFunction</a> instead that allows to register C/C++ function callbacks</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>number result=sim.registerScriptFunction(string funcNameAtPluginName,string callTips)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>functNameAtPluginName</strong>: name of the function, combined with the plugin name it is associated with: functionName@pluginName. Avoid using too simple function names, otherwise they might clash with other plugins. Also, always use the <em>simXX.</em> prefix (e.g. <em>simMyPlugin.myCustomFunction</em>) for the function name. The plugin name should be the exact same name used while loading the plugin via <a href="#simLoadModule">simLoadModule</a> (if the plugin name is <em>v_repExtMyPlugin.dll</em>, this should be <em>MyPlugin</em>).</div>
<div><strong>callTips</strong>: call tips: string (or several strings separated by '@') that indicates the input/output argument type/size. Call tips appear in the script editor when the function was typed followed by &quot;(&quot;.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if function was registered, 0 if function was replaced (when that function name already existed), -1 in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRegisterScriptVariable" id="simRegisterScriptVariable"></a>simRegisterScriptVariable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr><div>Registers a script variable. Each time a script is run for the first time, registered variables will be set. Can also be used for more complex operations as in following example:</div>
<div></div>
<div>simRegisterScriptVariable(&quot;simUi&quot;,&quot;require('customUi')&quot;,0);</div>
<div>which is equivalent with an implicit simUi=require('customUi') command in the initialization phase of every script.</div>
<div>The Lua counterpart is just used for syntax highlighting and auto-completion purpose in the V-REP internal code editor.</div>
<div>See also <a href="#simRegisterScriptCallbackFunction">simRegisterScriptCallbackFunction</a> and <a href="#simSetScriptVariable">sim.setScriptVariable</a>.</div></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRegisterScriptVariable(const simChar* varNameAtPluginName,const simChar* varValue,int stackhandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>varNameAtPluginName</strong>: name of the variable, combined with the plugin name: variableName@pluginName. Avoid using too simple variable names, otherwise they might clash with other plugins. Also, always use the <em>simXX.</em> prefix (e.g. <em>simMyPlugin.myCustomVariable</em>) for the variable name. The plugin name should be the exact same name used while loading the plugin via <a href="#simLoadModule">simLoadModule</a> (if the plugin name is <em>v_repExtMyPlugin.dll</em>, this should be <em>MyPlugin</em>).</div>
<div><strong>varValue</strong>: value of the variable. Can be NULL, in which case the value of the variable will be the top item of the provided stack (or, if <em>stackHandle</em> is 0, <em>varName</em> will only be used for code auto-completion purpose).</div>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>. Set to 0 if <em>varValue</em> is not NULL. Set to -1 if <em>varValue</em> is not NULL and you do not want the variable to appear in the script editor auto-completion list. If a stack is provided, it will be released at a later point by V-REP.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the variable was registered, 0 if the variable was replaced because it already existed, -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>number result=sim.registerScriptVariable(string varNameAtPluginName)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>varNameAtPluginName</strong>: name of the variable, combined with the plugin name: variableName@pluginName. Avoid using too simple variable names, otherwise they might clash with other plugins. Also, always use the <em>simXX.</em> prefix (e.g. <em>simMyPlugin.myCustomVariable</em>) for the variable name. The plugin name should be the exact same name used while loading the plugin via <a href="#simLoadModule">simLoadModule</a> (if the plugin name is <em>v_repExtMyPlugin.dll</em>, this should be <em>MyPlugin</em>).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the variable was registered, 0 if the variable was replaced because it already existed, -1 in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReleaseBuffer" id="simReleaseBuffer"></a>simReleaseBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Releases a buffer previously created with <a href="#simCreateBuffer">simCreateBuffer</a> or a buffer returned by the simulator. You will have to cast some buffer pointers to (simChar*).</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReleaseBuffer(simChar* buffer)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>buffer</strong>: buffer to be released</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReleaseScriptRawBuffer" id="simReleaseScriptRawBuffer"></a>simReleaseScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes (destroys) a script's raw buffer. All raw buffers are automatically released at the end of a simulation, but depending on the extent of use of the raw buffers, it might be a good idea to release them when not needed anymore. See also <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a> and <a href="#simSetScriptRawBuffer">simSetScriptRawBuffer</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReleaseScriptRawBuffer(simInt scriptHandle,simInt bufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script. Can be sim_handle_main_script or sim_handle_all (in that case the bufferHandle is automatically also sim_handle_all)<br>
</div>
<div><strong>bufferHandle</strong>: handle of the raw buffer or sim_handle_all to release all raw buffers of the given script<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful (an unexisting buffer will not trigger an error). In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReleaseStack" id="simReleaseStack"></a>simReleaseStack</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Releases a stack object. See also the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReleaseStack(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>:  a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 in case of success.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveBanner" id="simRemoveBanner"></a>simRemoveBanner / sim.removeBanner </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Removes a previously added banner. See also <a href="#simAddBanner">sim.addBanner</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveBanner(simInt bannerID)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>bannerID</strong>: handle of a previously added banner. <em>sim_handle_all</em> removes all banners from the scene. If you or-combine the bannerID with <em>sim_handleflag_togglevisibility</em>, then you can toggle the banner's visibility without removing it: in that case, the return value is the new visibility stae of the banner.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeBanner(number bannerID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>bannerID</strong>: handle of a previously added banner. sim.handle_all removes all banners from the scene, that were created in a script (banners created from the C interface are not removed)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveCollection" id="simRemoveCollection"></a>simRemoveCollection / sim.removeCollection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Removes a collection from the scene, including the objects it contains. If you just want to remove the collection, but not the objects it contains, call <a href="#simEmptyCollection">sim.emptyCollection</a> beforehand. See also <a href="#simCreateCollection">sim.createCollection</a> and <a href="#simAddObjectToCollection">sim.addObjectToCollection</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveCollection(simInt collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection to remove. sim_handle_all removes all collections from the scene</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeCollection(number collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveDrawingObject" id="simRemoveDrawingObject"></a>simRemoveDrawingObject / sim.removeDrawingObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a previously added drawing object. See also <a href="#simAddDrawingObject">sim.addDrawingObject</a> and <a href="#simAddDrawingObjectItem">sim.addDrawingObjectItem</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveDrawingObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object. sim_handle_all removes all drawing objects from the scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeDrawingObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object. sim.handle_all removes all drawing objects from the scene, that were created in a script (drawing objects created from the C interface are not removed)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxRemoveDrawingObject">simxRemoveDrawingObject</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveIkGroup" id="simRemoveIkGroup"></a>simRemoveIkGroup / sim.removeIkGroup </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an <a href="basicsOnIkGroupsAndIkElements.htm">IK group</a>. See also <a href="#simGetIkGroupHandle">sim.getIkGroupHandle</a> and <a href="#simCreateIkGroup">sim.createIkGroup</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveIkGroup(simInt ikGroupHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of an IK group.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeIkGroup(number ikGroupHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveModel" id="simRemoveModel"></a>simRemoveModel / sim.removeModel</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr><div>Removes a model from the scene. See also <a href="#simRemoveObject">sim.removeObject</a>.</div>
<div>Threaded child scripts can only destroy models that do not contain other scripts attached than itself.</div>
<div>Object destruction always tries to destroy attached scripts before destroying the object itself. If a script tries to destroy the object it is attached to, then the object will first be destroyed, and the script destruction will be delayed.</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveModel(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the model (i.e. object tagged as model) to remove.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of removed objects (a model might contain several objects)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number removedCnt=sim.removeModel(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxRemoveObjects">simxRemoveObjects</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxRemoveModel">simxRemoveModel</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveObject" id="simRemoveObject"></a>simRemoveObject / sim.removeObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr><div>Removes an object from the scene. See also <a href="#simRemoveModel">sim.removeModel</a>.</div>
<div>Threaded child scripts can only destroy objects that do not contain other scripts attached than itself.</div>
<div>Object destruction always tries to destroy attached scripts before destroying the object itself. If a script tries to destroy the object it is attached to, then the object will first be destroyed, and the script destruction will be delayed.</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object to remove. sim_handle_all removes all objects from the scene</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxRemoveObjects">simxRemoveObjects</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxRemoveObject">simxRemoveObject</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveObjectFromSelection" id="simRemoveObjectFromSelection"></a>simRemoveObjectFromSelection / sim.removeObjectFromSelection </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object from the selection. See also <a href="#simAddObjectToSelection">sim.addObjectToSelection</a>,  <a href="#simIsObjectInSelection">sim.isObjectInSelection </a>and <a href="#simGetObjectSelection">sim.getObjectSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveObjectFromSelection(simInt what,simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>What</strong>: indicates what we wish to remove from the selection. Valid values are sim_handle_single (removes one object from the selection), sim_handle_all (removes all objects from the selection), sim_handle_tree (removes the tree with base objectHandle (inclusive) from the selection, sim_handle_chain (removes the chain with tip objectHandle (inclusive) from the selection.<br>
</div>
<div><strong>objectHandle</strong>: handle of the object to remove from the selection. If sim_handle_all is specifies in &quot;what&quot;, then objectHandle is ignored<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=sim.removeObjectFromSelection(number what,number objectHandle)</div>
<div>(2) number result=sim.removeObjectFromSelection(table objectHandles)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) Same as C-function. The second argument can be omitted if &quot;what&quot; is sim.handle_all</div>
<div>(2) objectHandles: table containing the handles of objects to remove. Can be nil, in which case nothing happens<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectSelection">simxSetObjectSelection</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectSelection">simxSetObjectSelection</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveParticleObject" id="simRemoveParticleObject"></a>simRemoveParticleObject / sim.removeParticleObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a previously added particle object. See also <a href="#simAddParticleObject">sim.addParticleObject</a> and <a href="#simAddParticleObjectItem">sim.addParticleObjectItem</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveParticleObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added particle object. sim_handle_all removes all particle objects from the scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeParticleObject(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemovePointsFromPointCloud" id="simRemovePointsFromPointCloud"></a>simRemovePointsFromPointCloud / sim.removePointsFromPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes points from a <a href="pointClouds.htm">point cloud</a>. When a point cloud doesn't use an octree calculation structure, then individual points cannot be removed, only all points can be removed in that case. See also <a href="#simInsertPointsIntoPointCloud">sim.insertPointsIntoPointCloud</a>, <a href="#simSetPointCloudOptions">sim.setPointCloudOptions</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemovePointsFromPointCloud(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,simFloat tolerance,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</div>
<div><strong>pts</strong>: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all points</div>
<div><strong>ptCnt</strong>: the number of point coordinates contained in pts</div>
<div><strong>tolerance</strong>: a distance used as a tolerance value</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of points in the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalPointCnt=sim.removePointsFromPointCloud(number pointCloudHandle,number options,table points,number tolerance)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveScript" id="simRemoveScript"></a>simRemoveScript / sim.removeScript </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a script. Not all script types can be removed, and it will also depend on whether simulation is running or not. See also <a href="#simAddScript">sim.addScript</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveScript(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script to remove or sim_handle_all to remove all scripts</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.removeScript(number scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. Additionally you can specify sim.handle_self to have the script remove itself.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRemoveVoxelsFromOctree" id="simRemoveVoxelsFromOctree"></a>simRemoveVoxelsFromOctree / sim.removeVoxelsFromOctree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes voxels from an <a href="octrees.htm">octree</a>. See also <a href="#simInsertVoxelsIntoOctree">sim.insertVoxelsIntoOctree</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveVoxelsFromOctree(simInt octreeHandle,simInt options,const simFloat* pts,simInt ptCnt,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference frame</div>
<div><strong>pts</strong>: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxels</div>
<div><strong>ptCnt</strong>: the number of point coordinates contained in pts</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of voxels in the octree</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalVoxelCnt=sim.removeVoxelsFromOctree(number octreeHandle,number options,table points)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simReorientShapeBoundingBox" id="simReorientShapeBoundingBox"></a>simReorientShapeBoundingBox / sim.reorientShapeBoundingBox </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reorients the bounding box of a shape.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReorientShapeBoundingBox(simInt shapeHandle,simInt relativeToHandle,simInt reservedSetToZero)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: the handle of the shape that will be reoriented. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>relativeToHandle</strong>: the handle of an object relative to which the shape should be reoriented, or -1 to align the bounding box with the world, or sim_handle_self to build the smallest bounding box around the object.</div>
<div><strong>reservedSetToZero</strong>: reserved for future extensions. Set to 0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the bounding box could not be reoriented (the bounding box of pure shapes cannot be reoriented), otherwise 1.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.reorientShapeBoundingBox(number shapeHandle,number relativeToHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetCollision" id="simResetCollision"></a>simResetCollision / sim.resetCollision </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the collision state, colors, intersections, etc. for a registered collision object. See also <a href="#simHandleCollision">sim.handleCollision</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered collision objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetCollision(number collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetDistance" id="simResetDistance"></a>simResetDistance / sim.resetDistance </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the distance state, the distance segment, etc. for a registered distance object. See also <a href="#simHandleDistance">sim.handleDistance</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetDistance(simInt distanceObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered distance objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetDynamicObject" id="simResetDynamicObject"></a>simResetDynamicObject / sim.resetDynamicObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Dynamically resets an object that is dynamically simulated. This means that the object representation in the dynamics engine is removed, and added again. This can be useful when the set-up of a dynamically simulated chain needs to be modified during simulation (e.g. joint or shape attachement position/orientation changed). It should be noted that calling this on a dynamically simulated object might slightly change its position/orientation relative to its parent (since the object will be disconnected from the dynamics world in its current position/orientation), so the user is in charge of rectifying for that.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetDynamicObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object or <a href="apiConstants.htm#specialArgumentValues">sim_handle_all</a> (to reset all dynamic content in the scene). <strong>objectHandle</strong> can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_model</a>, if you wish to reset all objects in a <a href="models.htm">model</a> (where objectHandle would be the model base).</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetDynamicObject(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetGraph" id="simResetGraph"></a>simResetGraph / sim.resetGraph </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a graph object (resets all its data streams). See also <a href="#simHandleGraph">sim.handleGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetGraph(simInt graphHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all graph objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetGraph(number graphHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetMill" id="simResetMill"></a>simResetMill / sim.resetMill </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears all previously set mill calculation results (list of cut objects, surface and volume that were cut). See also <a href="#simHandleMill">sim.handleMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetMill(simInt millHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>millHandle</strong>: handle of the mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all mill objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetMill(number millHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetMilling" id="simResetMilling"></a>simResetMilling / sim.resetMilling </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets a cuttable object (e.g. a shape) to its initial shape (before it was milled), thus cancelling milling changes. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also <a href="#simApplyMilling">sim.applyMilling</a>, <a href="#simHandleMill">sim.handleMill</a> and <a href="#simResetMill">sim.resetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetMilling(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the cut object or sim_handle_all to reset all cut objects.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetMilling(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetProximitySensor" id="simResetProximitySensor"></a>simResetProximitySensor / sim.resetProximitySensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the detection state, detection color, detection segments, etc. of a proximity sensor object. See also <a href="#simHandleProximitySensor">sim.handleProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetProximitySensor(simInt sensorHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all proximity sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetScript" id="simResetScript"></a>simResetScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets a script interpreter linked to a specific script.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetScript(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script to reset or sim_handle_all to reset all scripts</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResetVisionSensor" id="simResetVisionSensor"></a>simResetVisionSensor / sim.resetVisionSensor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the detection state, etc. of a proximity sensor object. See also <a href="#simHandleVisionSensor">sim.handleVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetVisionSensor(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all vision sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.resetVisionSensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simResumeThreads" id="simResumeThreads"></a>simResumeThreads / sim.resumeThreads </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>In conjunction with <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a>, sim.resumeThreads allows specifying when and in which order threads are resumed. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution at the beginning of next simulation pass by default. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread. When sim.resumeThreads(x) is called, all threads that were assigned a resume location of x will be resumed. See also <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a>, <a href="#simSetThreadSwitchTiming">sim.setThreadSwitchTiming</a>, <a href="#simSwitchThread">sim.switchThread</a> and <a href="#simSetThreadIsFree">sim.setThreadIsFree</a>. This function can only be called in the <a href="mainScript.htm">main script</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number count=sim.resumeThreads(number location)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>location</strong>: indicates a location value associated with threads (through the <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a> function). Only threads with the same location value will be resumed.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: number of resumed threads, or -1 in case of an error.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRotateAroundAxis" id="simRotateAroundAxis"></a>simRotateAroundAxis / sim.rotateAroundAxis </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Rotates a transformation matrix around a random axis in space. This function, when used in combination with <a href="#simGetRotationAxis">sim.getRotationAxis</a>, can be used to build interpolations between transformation matrices. See also <a href="#simGetObjectMatrix">sim.getObjectMatrix</a>, <a href="#simSetObjectMatrix">sim.setObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRotateAroundAxis(const simFloat* matrixIn,const simFloat* axis,const simFloat* axisPos,simFloat angle,simFloat* matrixOut)  <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn</strong>: the transformation matrix to rotate</div>
<div><strong>axis</strong>: the axis vector in absolute coordinates to rotate around</div>
<div><strong>axisPos</strong>: the position of the rotation axis in absolute coordinates</div>
<div><strong>angle</strong>: the amount of rotation to perform</div>
<div><strong>matrixOut</strong>: the returned transformed (rotated) matrix</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrixOut=sim.rotateAroundAxis(table_12 matrixIn,table_3 axis,table_3 axisPos,number angle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrixOut</strong>: the transformed (rotated) matrix, or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRunSimulator" id="simRunSimulator"></a>simRunSimulator</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Runs the simulator. Should be the first and last command run. This will launch the main simulator loop. See also <a href="#simQuitSimulator">sim.quitSimulator</a> and the section on the <a href="mainClientApplication.htm">main client application</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRunSimulator(const simChar* applicationName,simInt options,simVoid(*initCallBack)(),simVoid(*loopCallBack)(),simVoid(*deinitCallBack)())<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>applicationName</strong>: ignored</div>
<div><strong>options</strong>: <a href="apiConstants.htm#startupOptions">start-up options</a> (combine them with the OR operator)</div>
<div><strong>initCallBack</strong>: the call-back address of the initialization routine. The initialization routine will be called just once, and should be used to load plugins for instance. Can be NULL for the default initialization routine.</div>
<div><strong>loopCallBack</strong>: the call-back address of the main simulator loop. That routine is called continuously in a loop, and should react to simulator messages (<a href="#simGetSimulatorMessage">simGetSimulatorMessage</a>), and handle running simulations. Can be NULL for the default loop routine.</div>
<div><strong>deinitCallBack</strong>: the call-back address of the deinitialization routine. The deinitialization routine will be called just once, before the simulation ends, and should be used to unload plugins for instance. Can be NULL for the default deinitialization routine.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the command was successfull<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simRunSimulatorEx" id="simRunSimulatorEx"></a>simRunSimulatorEx</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Runs the simulator. Should be the first and last command run. This will launch the main simulator loop. See also <a href="#simQuitSimulator">sim.quitSimulator</a> and the section on the <a href="mainClientApplication.htm">main client application</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRunSimulatorEx(const simChar* applicationName,simInt options,simVoid(*initCallBack)(),simVoid(*loopCallBack)(),simVoid(*deinitCallBack)(),simInt stopDelay,simChar* sceneOrModelToLoad)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>applicationName</strong>: ignored</div>
<div><strong>options</strong>: <a href="apiConstants.htm#startupOptions">start-up options</a> (combine them with the OR operator)</div>
<div><strong>initCallBack</strong>: the call-back address of the initialization routine. The initialization routine will be called just once, and should be used to load plugins for instance. Can be NULL for the default initialization routine.</div>
<div><strong>loopCallBack</strong>: the call-back address of the main simulator loop. That routine is called continuously in a loop, and should react to simulator messages (<a href="#simGetSimulatorMessage">simGetSimulatorMessage</a>), and handle running simulations. Can be NULL for the default loop routine.</div>
<div><strong>deinitCallBack</strong>: the call-back address of the deinitialization routine. The deinitialization routine will be called just once, before the simulation ends, and should be used to unload plugins for instance. Can be NULL for the default deinitialization routine.</div>
<div><strong>stopDelay</strong>: a delay in simulation milliseconds, after which the first simulation run will stop, or 0 for no automatic stopping.</div>
<div><strong>sceneOrModelToLoad</strong>: the name of the initial scene or model to load.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the command was successfull<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSaveImage" id="simSaveImage"></a>simSaveImage / sim.saveImage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves an image to file or to memory. See also <a href="#simLoadImage">sim.loadImage</a>, <a href="#simGetScaledImage">sim.getScaledImage</a> and <a href="#simGetVisionSensorCharImage">sim.getVisionSensorCharImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simSaveImage(const simUChar* image,const simInt* resolution,simInt options,const simChar* filename,simInt quality,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>image</strong>: a pointer to rgb or rgba values.</div>
<div><strong>resolution</strong>: the x/y resolution of the provided image.</div>
<div><strong>options</strong>: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.</div>
<div><strong>filename</strong>: the name of the file to write. The file extension indicates the format.</div>
<div><strong>quality</strong>: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.</div>
<div><strong>reserved</strong>: Reserved for future extension. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>1) number result=sim.saveImage(string image,table_2 resolution,number options,string filename,number quality)</div>
<div>2) string imgBuffer=sim.saveImage(string image,table_2 resolution,number options,string filename,number quality)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>image</strong>: a pointer to rgb or rgba values.</div>
<div><strong>resolution</strong>: the x/y resolution of the provided image.</div>
<div><strong>options</strong>: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.</div>
<div><strong>filename</strong>: the name of the file to write. The file extension indicates the format. If the filename only contains '.xxx', where xxx represents the file format, then the image will be saved to memory</div>
<div><strong>quality</strong>: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>1) <strong>result</strong>: -1 if operation was not successful</div>
<div>2) <strong>imgBuffer</strong>: a buffer containing the image in packed format (e.g. png, jpg, etc.)</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSaveModel" id="simSaveModel"></a>simSaveModel / sim.saveModel </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves a model (an object marked as &quot;Object is model base&quot; and all other objects in its hierarchy tree). Any existing file with same name will be overwritten. See also <a href="#simLoadModel">sim.loadModel</a>, and <a href="#simSaveScene">sim.saveScene</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSaveModel(int baseOfModelHandle,const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>baseOfModelHandle</strong>: handle of an object marked as &quot;Object is model base&quot;</div>
<div><strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>a) number result=sim.saveModel(number baseOfModelHandle,string filename)</div>
<div>b) string buffer=sim.saveModel(number baseOfModelHandle)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>baseOfModelHandle</strong>: handle of an object marked as &quot;Object is model base&quot;</div>
<div><strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;). If this argument is omitted, then the model will be saved to a buffer which will be returned</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>a) -1 if operation was not successful</div>
<div>b) nil if operation was not successful, or a buffer containing the saved model</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSaveScene" id="simSaveScene"></a>simSaveScene / sim.saveScene </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves a scene. Any existing file with same name will be overwritten. See also <a href="#simLoadScene">sim.loadScene</a>, <a href="#simCloseScene">simCloseScene</a>, and <a href="#simSaveModel">sim.saveModel</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSaveScene(const simChar* filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: scene filename. The filename extension is required (&quot;ttt&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.saveScene(string filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simScaleObject" id="simScaleObject"></a>simScaleObject / sim.scaleObject </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Scales specified objects in a non-isometric fashion, if possible (i.e. some objects can be fully isometrically scaled, others have 2 or all 3 axes linked). See also <a href="#simScaleObjects">sim.scaleObjects</a> for isometric scaling.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simScaleObject(simInt objectHandle,simFloat xScale,simFloat yScale,simFloat zScale,simInt options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: the handle of the object to scale.</div>
<div><strong>xScale/yScale/zScale</strong>: the scaling factors along the object's x, y and z-axis.</div>
<div><strong>options</strong>: reserved for future extension. Keep at 0.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.scaleObject(number objectHandle,number xScale,number yScale,number zScale,number options=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simScaleObjects" id="simScaleObjects"></a>simScaleObjects / sim.scaleObjects </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Scales (in dimensions) specified objects. All related values are automatically scaled appropriately (e.g. masses, forces, etc.). See also <a href="#simScaleObject">sim.scaleObject</a> for non-isometric scaling.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simScaleObjects(const simInt* objectHandles,simInt objectCount,simFloat scalingFactor,simBool scalePositionsToo)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandles</strong>: an array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.</div>
<div><strong>objectCount</strong>: the number of handles in the objectHandles array.</div>
<div><strong>scalingFactor</strong>: the scaling factor</div>
<div><strong>scalePositionsToo</strong>: if true, selected object's positions will also be scaled</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.scaleObjects(table objectHandles,number scalingFactor,boolean scalePositionsToo)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSendData" id="simSendData"></a>simSendData / sim.sendData </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends (or broadcasts) wireless data (in a simulation). See also <a href="#simReceiveData">sim.receiveData</a> and <a href="#simTubeOpen">sim.tubeOpen</a>. Cannot be called from <a href="addOns.htm">add-ons</a>. <br>
<br>
Wireless emissions can be visualized globally via the <a href="environmentPropertiesDialog.htm">environment dialog</a>, or individually as in following example:
<pre class=lightRedBoxNoMarginAndSmall>
sim.setBoolParameter(sim.boolparam_force_show_wireless_emission,true)
sim.sendData(...)
sim.setBoolParameter(sim.boolparam_force_show_wireless_emission,false)</pre>

</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSendData(simInt targetID,simInt dataHeader,const simChar* dataName,const simChar* data,simInt dataLength,simInt antennaHandle,simFloat actionRadius,simFloat emissionAngle1,simFloat emissionAngle2,simFloat persistence)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>targetID</strong>: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a script<br>
</div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see <a href="#simReceiveData">simReceiveData</a>)<br>
</div>
<div><strong>data</strong>: data to transmit</div>
<div><strong>dataLength</strong>: length of the data to transmit</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frame<br>
</div>
<div><strong>actionRadius</strong>: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the data<br>
</div>
<div><strong>emissionAngle1</strong>: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.<br>
</div>
<div><strong>emissionAngle2</strong>: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.<br>
</div>
<div><strong>persistence</strong>: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.sendData(number targetID,number dataHeader,string dataName,string data,number antennaHandle=sim.handle_self,number actionRadius=100,number emissionAngle1=3.1415,number emissionAngle2=6.283,number persistence=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>targetID</strong>: indicates what receivers will receive the message. Can be sim.handle_all, sim.handle_tree, sim.handle_chain, or the handle of a script. If sim.handle_tree is specified, then only child scripts built on top of current script's hierarchy will be able to receive the message. If sim.handle_chain is specified, then only child scripts parented with current script (or the main script) will be able to receive the message<br>
</div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see <a href="#simReceiveData">sim.receiveData</a>)<br>
</div>
<div><strong>data</strong>: data to transmit (each character can have values between 0 and 255). See also the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this transmission. Use sim.handle_default to simulate an antenna coinciding with the world reference frame, or sim.handle_self to use the object associated with the child script as antenna. Can be omitted (in that case, sim.handle_self is used)<br>
</div>
<div><strong>actionRadius</strong>: same as C-function. Can be omitted (in that case 100 is used)</div>
<div><strong>emissionAngle1</strong>: same as C-function. Can be omitted (in that case, pi is used)</div>
<div><strong>emissionAngle2</strong>: same as C-function. Can be omitted (in that case, 2pi is used)</div>
<div><strong>persistence</strong>: same as C-function. Can be omitted (in that case, 0.0 is used)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSendModuleMessage" id="simSendModuleMessage"></a>simSendModuleMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends a message to plugins. This function should normally only be used from the <a href="mainClientApplication.htm">main client application</a> side. See also <a href="#simLoadModule">sim.loadModule</a> and <a href="#simBroadcastMessage">simBroadcastMessage</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simSendModuleMessage(simInt message,simInt* auxiliaryData,simVoid* customData,simInt* replyData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>message</strong>: the message to send. Refer to <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_</a>-type messages.<br>
</div>
<div><strong>auxiliaryData</strong>: pointer to 4 integers. auxiliaryData[0] should be a unique identifier different from 0. Use a large random identifier, or better, your V-REP serial number if the message is yours. Otherwise, use the identifier of some other module. auxiliaryData[1] could be the messageID of the message you wish to send to another module. auxiliaryData[2] and auxiliaryData[3] can be any values specific to your application.<br>
</div>
<div><strong>customData</strong>: customData of your application (the broadcaster is in charge to release that buffer). Can be NULL.<br>
</div>
<div><strong>replyData</strong>: pointer to 4 integers that can be used by a module to reply to a broadcasted message. Can be NULL. If not NULL, all 4 values are automatically initialized to -1.<br>
</div>
<br>
<div>Broadcasted messages can be intercepted in a plugin's "v_repMessage"-function.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to custom reply data that can be used by a module to reply to a broadcasted message. The module that replies is in charge of allocating the data with <a href="#simCreateBuffer">simCreateBuffer</a> and the original broadcaster is in charge of releasing that data with <a href="#simReleaseBuffer">simReleaseBuffer</a>. A reply to a broadcasted message is triggered by a module that writes a value different from -1 into auxiliaryData[0]-auxiliaryData[3], thus aborting further broadcast of the original message and returning to the broadcaster. If the return value is different from NULL, the broadcast is also interrupted.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSerialCheck" id="simSerialCheck"></a>simSerialCheck / sim.serialCheck </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Reads how many bytes are waiting to be read on a serial port (RS-232). See also <a href="#simSerialRead">sim.serialRead</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialCheck(simInt portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of bytes that are waiting to be read<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.serialCheck(number portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSerialClose" id="simSerialClose"></a>simSerialClose / sim.serialClose </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Closes a serial port (RS-232). See also <a href="#simSerialOpen">sim.serialOpen</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialClose(simInt portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.serialClose(number portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSerialOpen" id="simSerialOpen"></a>simSerialOpen / sim.serialOpen </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a serial port (RS-232) for communication. When called from a script, the function can only be called when the simulation is running (and in that case the port is automatically closed at simulation stop). See also <a href="#simSerialClose">sim.serialClose</a>, <a href="#simSerialSend">sim.serialSend</a>, <a href="#simSerialCheck">sim.serialCheck</a> and <a href="#simSerialRead">sim.serialRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialOpen(simChar* portString,simInt baudRate,simVoid* reserved1,simVoid* reserved2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portString</strong>: a string specifying the port to open. Under Windows, use something similar to &quot;\\.\COM1&quot;. Under MacOS and Linux, use something similar to &quot;/dev/*&quot; (check the &quot;/dev&quot; folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.</div>
<div><strong>baudRate</strong>: the baudrate</div>
<div><strong>reserved1</strong>: reserved for future extension. Keep at NULL.</div>
<div><strong>reserved2</strong>: reserved for future extension. Keep at NULL.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise a port handle<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.serialOpen(string portString,number baudRate)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSerialRead" id="simSerialRead"></a>simSerialRead / sim.serialRead </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads from a previously opened serial port (RS-232). The C version of the function cannot be blocking. See also <a href="#simSerialCheck">sim.serialCheck</a> and <a href="#simSerialSend">sim.serialSend</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialRead(simInt portHandle,simChar* buffer,simInt dataLengthToRead)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div><strong>buffer</strong>: a buffer that will be filled with read data<br>
</div>
<div><strong>dataLengthToRead</strong>: the maximum data length that should be read<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the effective data length that was read<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.serialRead(number portHandle,number dataLengthToRead,Boolean blockingOperation,string closingString='',number timeout=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">sim.serialOpen</a> function</div>
<div><strong>dataLengthToRead</strong>: the maximum data length that should be read</div>
<div><strong>blockingOperation</strong>: if true and the calling script is running in a thread, then the function only returns when the desired data length was read (or if the closingString was met, or if there was a timeout (see next arguments)<br>
</div>
<div><strong>closingString</strong>: a string (containing any byte value) can be specified, that will break from the blocking operation if a match was found in the incoming data. Useful when you know that a data packet is always ended with a given signature. Can be an empty string for default operation.<br>
</div>
<div><strong>timeout</strong>: duration after which the blocking operation will be aborted, or 0 if the timeout is infinite.</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string containing read data (excluding the closingString if it was specified and found)</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSerialSend" id="simSerialSend"></a>simSerialSend / sim.serialSend </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Writes data to a previously opened serial port (RS-232). See also <a href="#simSerialRead">sim.serialRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialSend(simInt portHandle,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div><strong>data</strong>: a pointer to the data that should be sent</div>
<div><strong>dataLength</strong>: length of the data to be sent</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the effective data length that was written</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number charsSent=sim.serialSend(number portHandle,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetArrayParameter" id="simSetArrayParameter"></a>simSetArrayParameter / sim.setArrayParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets 3 values of an <a href="apiConstants.htm#arrayParameters">array parameter</a>. See also <a href="#simGetArrayParameter">sim.getArrayParameter</a>, <a href="#simSetBoolParameter">sim.setBoolParameter</a>, <a href="#simSetInt32Parameter">sim.setInt32Parameter</a> and <a href="#simSetFloatParameter">sim.setFloatParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetArrayParameter(simInt parameter,const simVoid* parameterValues)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#arrayParameters">array parameter identifier</a></div>
<div><strong>parameterValues</strong>: array of 3 simFloat values related to the parameter (simVoid is kept for backward compatibility).</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setArrayParameter(number parameter,table parameterValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetArrayParameter">simxSetArrayParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetArrayParameter">simxSetArrayParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetBoolParameter" id="simSetBoolParameter"></a>simSetBoolParameter / sim.setBoolParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a <a href="apiConstants.htm#booleanParameters">boolean parameter</a>. See also <a href="#simGetBoolParameter">sim.getBoolParameter</a>, <a href="#simSetInt32Parameter">sim.setInt32Parameter</a>, <a href="#simSetArrayParameter">sim.setArrayParameter</a> and <a href="#simSetFloatParameter">sim.setFloatParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetBoolParameter(simInt parameter,simBool boolState)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#booleanParameters">Boolean parameter identifier</a></div>
<div><strong>boolState</strong>: new boolean state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setBoolParameter(number parameter,boolean boolState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetBoolParameter">simxSetBoolParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetBooleanParameter">simxSetBooleanParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetCollectionName" id="simSetCollectionName"></a>simSetCollectionName / sim.setCollectionName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the name of a collection based on its handle. See also <a href="#simGetCollectionName">sim.getCollectionName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetCollectionName(simInt collectionHandle,const simChar* collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection</div>
<div><strong>collectionName</strong>: new name of the collection</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setCollectionName(number collectionHandle,string collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetConfigurationTree" id="simSetConfigurationTree"></a>simSetConfigurationTree / sim.setConfigurationTree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Restores configuration information previously retrieved with <a href="#simGetConfigurationTree">sim.getConfigurationTree</a> (object relative positions/orientations, joint/path values). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetConfigurationTree(const simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>data</strong>: data returned by a previous call to <a href="#simGetConfigurationTree">simGetConfigurationTree</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setConfigurationTree(number rawBufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a block of memory previously returned by <a href="#simGetConfigurationTree">sim.getConfigurationTree</a>. If not needed anymore, you can release the raw buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a> (all raw buffers are however automatically released at the end of a simulation)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetDebugWatchList" id="simSetDebugWatchList"></a>sim.setDebugWatchList</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows to watch specific variables when a script is in a debug mode that displays variable changes.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>sim.setDebugWatchList(table listOfVariables)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>listOfVariables</strong>: the list of variables to watch (e.g. {"x","arr[3]","model.handle"}), or nil to watch all variables.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetDoubleSignal" id="simSetDoubleSignal"></a>simSetDoubleSignal / sim.setDoubleSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of a double signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetDoubleSignal">sim.getDoubleSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  and <a href="#simPersistentDataWrite">sim.persistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetDoubleSignal(const simChar* signalName,simDouble signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setDoubleSignal(string signalName,number signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetFloatSignal">simxSetFloatSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetFloatSignal">simxSetFloatSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetEngineBoolParameter" id="simSetEngineBoolParameter"></a>simSetEngineBoolParameter / sim.setEngineBoolParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets a bool-type physics engine property. You might have to call <a href="#simResetDynamicObject">sim.resetDynamicObject</a> for changes to take effect. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetEngineBoolParameter(simInt paramId,simInt objectHandle,const simVoid* object,simBool val)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>val</strong>: the new property values.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setEngineBoolParameter(number paramId,number objectHandle,boolean boolParam)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetEngineFloatParameter" id="simSetEngineFloatParameter"></a>simSetEngineFloatParameter / sim.setEngineFloatParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets a float-type physics engine property. You might have to call <a href="#simResetDynamicObject">sim.resetDynamicObject</a> for changes to take effect. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetEngineFloatParameter(simInt paramId,simInt objectHandle,const simVoid* object,simFloat val)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>val</strong>: the new property values.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setEngineFloatParameter(number paramId,number objectHandle,number floatParam)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetEngineInt32Parameter" id="simSetEngineInt32Parameter"></a>simSetEngineInt32Parameter / sim.setEngineInt32Parameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets an int32-type physics engine property. You might have to call <a href="#simResetDynamicObject">sim.resetDynamicObject</a> for changes to take effect. See also <a href="apiFunctionListCategory.htm#engineParameters">the other engine properties setter and getter API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetEngineInt32Parameter(simInt paramId,simInt objectHandle,const simVoid* object,simInt val)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramId</strong>: the <a href="apiConstants.htm#engineParameters">engine parameter identifier</a>.</div>
<div><strong>objectHandle</strong>: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the <em>object</em> argument will be evaluated.<br>
</div>
<div><strong>object</strong>: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the <em>objectHandle</em> argument will be evaluated.</div>
<div><strong>val</strong>: the new property values.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setEngineInt32Parameter(number paramId,number objectHandle,number int32Param)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 in case of success. This function call doesn't generate any error message.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetExplicitHandling" id="simSetExplicitHandling"></a>simSetExplicitHandling / sim.setExplicitHandling </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the explicit handling flags for a general object. See also <a href="#simGetExplicitHandling">sim.getExplicitHandling</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetExplicitHandling(simInt generalObjectHandle,int explicitFlags)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalObjectHandle</strong>: handle of a general object (can be a scene object, a collision object, a distance object, etc.)<br>
</div>
<div><strong>explicitFlags</strong>: the explicit handling flags. For now only bit 0 is used<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setExplicitHandling(number generalObjectHandle,number explicitFlags)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetFloatParameter" id="simSetFloatParameter"></a>simSetFloatParameter / sim.setFloatParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a <a href="apiConstants.htm#floatingParameters">floating point parameter</a>. See also <a href="#simGetFloatParameter">sim.getFloatParameter</a>, <a href="#simSetBoolParameter">sim.setBoolParameter</a>, <a href="#simSetArrayParameter">sim.setArrayParameter</a> and <a href="#simSetInt32Parameter">sim.setInt32Parameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetFloatParameter(simInt parameter,simFloat floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#floatingParameters">floating parameter identifier</a></div>
<div><strong>floatState</strong>: new state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setFloatParameter(number parameter,number floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetFloatParameter">simxSetFloatParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetFloatingParameter">simxSetFloatingParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetGraphUserData" id="simSetGraphUserData"></a>simSetGraphUserData / sim.setGraphUserData </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets one value in a user-defined graph data stream. See also <a href="#simResetGraph">sim.resetGraph</a> and <a href="#simHandleGraph">sim.handleGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetGraphUserData(simInt graphHandle,const simChar* dataStreamName,simFloat data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object</div>
<div><strong>dataStreamName</strong>: the name of the data stream. The data stream must be of type &quot;user-defined&quot;</div>
<div><strong>data</strong>: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setGraphUserData(number graphHandle,string dataStreamName,number data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetIkElementProperties" id="simSetIkElementProperties"></a>simSetIkElementProperties / sim.setIkElementProperties </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets properties of a specific inverse kinematics element (IK element). See also <a href="#simSetIkGroupProperties">sim.setIkGroupProperties</a> and <a href="#simGetIkGroupHandle">sim.getIkGroupHandle</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIkElementProperties(simInt ikGroupHandle,simInt tipDummyHandle,simInt constraints,const simFloat* precision,const simFloat* weight,void* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group that contains the IK element to modify</div>
<div><strong>tipDummyHandle</strong>: handle of the tip dummy object of the IK element</div>
<div><strong>constraints</strong>: the <a href="apiConstants.htm#ikConstraints">constraints</a> of the ik element. sim_ik_avoidance_constraint is not allowed</div>
<div><strong>precision</strong>: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.</div>
<div><strong>weight</strong>: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetIkGroupProperties" id="simSetIkGroupProperties"></a>simSetIkGroupProperties / sim.setIkGroupProperties </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets properties of an inverse kinematics group (IK group). See also <a href="#simSetIkElementProperties">sim.setIkElementProperties</a> and <a href="#simGetIkGroupHandle">sim.getIkGroupHandle</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIkGroupProperties(simInt ikGroupHandle,simInt resolutionMethod,simInt maxIterations,simFloat damping,void* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group </div>
<div><strong>resolutionMethod</strong>: the <a href="apiConstants.htm#ikCalculationMethods">IK resolution method</a></div>
<div><strong>maxIterations</strong>: the maximum number of iteractions for the calculations</div>
<div><strong>damping</strong>: the DLS damping factor.</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setIkGroupProperties(number ikGroupHandle,number resolutionMethod,number maxIterations,number damping)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetInt32Parameter" id="simSetInt32Parameter"></a>simSetInt32Parameter / sim.setInt32Parameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets an <a href="apiConstants.htm#integerParameters">integer parameter</a>. See also <a href="#simGetInt32Parameter">sim.getInt32Parameter</a>, <a href="#simSetBoolParameter">sim.setBoolParameter</a>, <a href="#simSetArrayParameter">sim.setArrayParameter</a> and <a href="#simSetFloatParameter">sim.setFloatParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetInt32Parameter(simInt parameter,simInt intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#integerParameters">integer parameter identifier</a></div>
<div><strong>intState</strong>: new state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setInt32Parameter(number parameter,number intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetIntParameter">simxSetIntParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetIntegerParameter">simxSetIntegerParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetIntegerSignal" id="simSetIntegerSignal"></a>simSetIntegerSignal / sim.setIntegerSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of an integer signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetIntegerSignal">sim.getIntegerSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  and <a href="#simPersistentDataWrite">sim.persistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIntegerSignal(const simChar* signalName,simInt signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setIntegerSignal(string signalName,number signalValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetIntSignal">simxSetIntSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetIntegerSignal">simxSetIntegerSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointDependency" id="simSetJointDependency"></a>simSetJointDependency / sim.setJointDependency </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a joint dependent of another joint. The dependent joint should first be set into dependent mode via <a href="#simSetJointMode">sim.setJointMode</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointDependency(simInt jointHandle,simInt masterJointHandle,simFloat offset,simFloat coeff)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint to become slave</div>
<div><strong>masterJointHandle</strong>: handle of the joint to become master, or -1 to free the slave joint from dependency.</div>
<div><strong>offset</strong>: the offset in equation slave=offset+master*coeff</div>
<div><strong>coeff</strong>: the coeff in equation slave=offset+master*coeff</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointDependency(number jointHandle,number masterJointHandle,number offset,number coeff)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointForce" id="simSetJointForce"></a>simSetJointForce / sim.setJointForce</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the maximum force or torque that a joint can exert. The joint will apply that force/torque until the joint target velocity has been reached. To apply a negative force/torque, set a negative target velocity. This function has no effect when the joint is not dynamically enabled, or when it is a spherical joint. See also <a href="#simGetJointForce">sim.getJointForce</a>. and <a href="#simSetJointTargetVelocity">sim.setJointTargetVelocity</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointForce(simInt objectHandle,simFloat forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>forceOrTorque</strong>: the maximum force or torque that the joint can exert. This cannot be a negative value.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointForce(number objectHandle,number forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetJointForce">simxSetJointForce</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetJointForce">simxSetJointForce</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointInterval" id="simSetJointInterval"></a>simSetJointInterval / sim.setJointInterval </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the interval parameters of a joint (i.e. range values). The attributes or interval parameters might have no effect, depending on the joint-type. See also <a href="#simGetJointInterval">sim.getJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointInterval(simInt objectHandle,simBool cyclic,const simFloat* interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclic<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1])<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointInterval(number objectHandle,boolean cyclic,table_2 interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointMode" id="simSetJointMode"></a>simSetJointMode / sim.setJointMode </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the operation mode of a joint. Might have as side-effect the change of additional properties of the joint. See also <a href="#simGetJointMode">sim.getJointMode</a> and <a href="#simSetJointDependency">sim.setJointDependency</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointMode(simInt jointHandle,simInt jointMode,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint object</div>
<div><strong>jointMode</strong>: a <a href="apiConstants.htm#jointModes">joint mode</a> value</div>
<div><strong>options</strong>: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointMode(number jointHandle,number jointMode,number options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointPosition" id="simSetJointPosition"></a>simSetJointPosition / sim.setJointPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic position of a joint. May have no effect depending on the joint mode. This function cannot be used with spherical joints (use <a href="#simSetSphericalJointMatrix">sim.setSphericalJointMatrix</a> instead). See also <a href="#simGetJointPosition">sim.getJointPosition</a> and <a href="#simSetJointTargetPosition">sim.setJointTargetPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointPosition(simInt objectHandle,simFloat position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>position</strong>: position of the joint (angular or linear value depending on the joint type)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointPosition(number objectHandle,number position)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetJointPosition">simxSetJointPosition</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetJointPosition">simxSetJointPosition</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointTargetPosition" id="simSetJointTargetPosition"></a>simSetJointTargetPosition / sim.setJointTargetPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the target position of a joint if the joint is in torque/force mode (also make sure that the joint's motor and position control are enabled). See also <a href="#simGetJointTargetPosition">sim.getJointTargetPosition</a> and <a href="#simSetJointPosition">sim.setJointPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointTargetPosition(simInt objectHandle,simFloat targetPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetPosition</strong>: target position of the joint (angular or linear value depending on the joint type)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointTargetPosition(number objectHandle,number targetPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetJointTargetPosition">simxSetJointTargetPosition</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetJointTargetPosition">simxSetJointTargetPosition</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetJointTargetVelocity" id="simSetJointTargetVelocity"></a>simSetJointTargetVelocity / sim.setJointTargetVelocity</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic target velocity of a non-spherical joint. This command makes only sense when the joint mode is torque/force mode: the dynamics functionality and the joint motor have to be enabled (position control should however be disabled). See also <a href="#simGetJointTargetVelocity">sim.getJointTargetVelocity</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointTargetVelocity(simInt objectHandle,simFloat targetVelocity)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetVelocity</strong>: target velocity of the joint (linear or angular velocity depending on the joint-type). </div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setJointTargetVelocity(number objectHandle,number targetVelocity)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetJointTargetVelocity">simxSetJointTargetVelocity</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetJointTargetVelocity">simxSetJointTargetVelocity</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetLastError" id="simSetLastError"></a>simSetLastError</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a custom error or warning message. This function is useful for plugins which wish to generate custom error/warning messages that will be displayed in the calling script. Errors/warnings are set and memorized on a thread-basis (e.g. threads originating from threaded scripts have each an individual error handler). See also <a href="#simGetLastError">sim.getLastError</a>, the sim.intparam_error_report_mode and the <a href="apiConstants.htm#errorReportModes">error report modes</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLastError(const simChar* funcName,const simChar* errorMessage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>funcName</strong>: name of the function where the error originated. If funcName starts with &quot;warning@&quot;, then a warning messages will be registered instead.</div>
<div><strong>errorMessage</strong>: error or warning message</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetLightParameters" id="simSetLightParameters"></a>simSetLightParameters / sim.setLightParameters </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets various parameters of a light object. See also <a href="#simGetLightParameters">sim.getLightParameters</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLightParameters(simInt objectHandle,simInt state,const simFloat* setToNULL,const simFloat* diffusePart,const simFloat* specularPart)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the light</div>
<div><strong>state</strong>: bit-coded. for now, only bit 0 is used: 1=light on</div>
<div><strong>setToNULL</strong>: not used, set to NULL</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part. Can be NULL</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setLightParameters(number objectHandle,number state,nil,table_3 diffusePart,table_3 specularPart)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetLinkDummy" id="simSetLinkDummy"></a>simSetLinkDummy / sim.setLinkDummy </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Defines (or breaks) a dummy-dummy link pair. Useful to create dynamic loop closure constraints on the fly (among others). See also <a href="#simGetLinkDummy">sim.getLinkDummy</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLinkDummy(simInt dummyHandle,simInt linkedDummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dummyHandle</strong>: handle of the first dummy in the dummy-dummy link pair.</div>
<div><strong>linkedDummyHandle</strong>: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.getLinkDummy(number dummyHandle,number linkedDummyHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetModelProperty" id="simSetModelProperty"></a>simSetModelProperty / sim.setModelProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the properties of a model. See also <a href="#simGetModelProperty">sim.getModelProperty</a>, <a href="#simSetObjectProperty">sim.setObjectProperty</a> and <a href="#simSetObjectSpecialProperty">sim.setObjectSpecialProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetModelProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that serves as the model base</div>
<div><strong>prop</strong>: model property. See the <a href="apiConstants.htm#modelProperties">model property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setModelProperty(number objectHandle,number prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: -</div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetModelProperty">simxSetModelProperty</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetModuleInfo" id="simSetModuleInfo"></a>simSetModuleInfo</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Attaches additional information to a loaded plugin. See also <a href="#simGetModuleInfo">sim.getModuleInfo</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetModuleInfo(const simChar* moduleName,simInt infoType,const simChar* stringInfo,simInt intInfo)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>moduleName</strong>: the name of the plugin.</div>
<div><strong>infoType</strong>: the type of information to set:</div>
<div class=tab>0: <em>extended version string</em></div>
<div class=tab>1: <em>build date string</em></div>
<div class=tab>2: <em>extended version integer</em></div>
<div><strong>stringInfo</strong>: a string information value, in case the information type is for a string.</div>
<div><strong>intInfo</strong>: an integer information value, in case the information type is for an integer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetModuleMenuItemState" id="simSetModuleMenuItemState"></a>simSetModuleMenuItemState</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Updates the state of a menu item added with the <a href="#simAddModuleMenuEntry">simAddModuleMenuEntry</a> command.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetModuleMenuItemState(simInt itemHandle,simInt state,const simChar* label)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>itemHandle</strong>: handle of the item as returned by the <a href="#simAddModuleMenuEntry">simAddModuleMenuEntry</a> function</div>
<div><strong>state</strong>: state of the item. Bit 0 (1)indicates the enabled state, bit 1 (2)indicates the checked state</div>
<div><strong>label</strong>: label of the item. Can be NULL in which case the label is kept unchanged. If label is &quot;&quot;, the item becomes a separator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetNameSuffix" id="simSetNameSuffix"></a>simSetNameSuffix / sim.setNameSuffix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
<div>Sets the name suffix adjustment number (for detailed information on this, read also the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). In V-REP, all objects are identified by a name and a handle. When an object (scene object or general-type object) is copied at the same time as a child script, the newly created object's name will become &quot;oldName#0&quot;, should the same object be pasted another time, the next name will be &quot;oldName#1&quot;, etc. <br>
</div>
<br> 
<div>From within a child script, retrieving object handles is performed by automatically appending a name suffix to the object name (each script gets initialized with the name suffix number of the object it is attached to). This allows to copy-paste objects and scripts without having to manually adjust the scripts (the scripts will automatically know which object they have to access based on the set name suffix). From within a script, most of the time you won't need to set the name suffix, but in some special cases you might want to temporarily disable it (e.g. &quot;myChildScript#42&quot; (which has its name suffix automatically set to 42) copied itself together with its attached robot (&quot;myRobot#42&quot;) and now from within &quot;myChildScript#42&quot; you want to shift &quot;myRobot#43&quot; to avoid collision. In that case set the name suffix to 43, shift &quot;myRobot&quot; (retrieve its handle with <a href="#simGetObjectHandle">sim.getObjectHandle</a>(&quot;myRobot&quot;) then set the suffix back to 42). From within a script, the <a href="#simSetNameSuffix">sim.setNameSuffix</a> command is influencing only current script.<br>
</div>
<br> 
<div>When accessing the API from outside of a script however, the name adjustment mechanism needs to be adjusted manually (make sure you reset the name suffix to its initial state after you are done retrieving handles). Imagine you have one robot in your scene that is named &quot;robot&quot;. You can access the robot from a C/C++ application with <a href="#simGetObjectHandle">sim.getObjectHandle</a>(&quot;robot&quot;). If the robot is duplicated, the second robot's name will be &quot;robot#0&quot;, the third will be &quot;robot#1&quot;, etc. From within you C/C++ application you can now access all robots with the same code, you just need to adjust the name suffix number. E.g. <a href="#simSetNameSuffix">sim.setNameSuffix</a>(42), then <a href="#simGetObjectHandle">sim.getObjectHandle</a>(&quot;robot&quot;) will retrieve the handle of &quot;robot#42&quot;. Once you are done accessing objects, reset the name suffix number to -1 (<a href="#simSetNameSuffix">sim.setNameSuffix</a>(-1)).<br>
</div>
<br> 
<div>Setting the name suffix to -1 disables the name adjustment mechanism (default when accessing the API from outside of a script)<br>
</div>
<br> 
<div>See also the <a href="#simGetNameSuffix">sim.getNameSuffix</a> function.<br>
</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetNameSuffix(simInt nameSuffixNumber)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>nameSuffixNumber</strong>: a number starting from -1 (-1 is for no suffix, 0 is for the 0 suffix, etc.)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result sim.setNameSuffix(number nameSuffixNumber)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetNavigationMode" id="simSetNavigationMode"></a>simSetNavigationMode / sim.setNavigationMode </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the navigation and selection mode for the mouse. See also <a href="#simGetNavigationMode">sim.getNavigationMode</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetNavigationMode(simInt navigationMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>navigationMode</strong>: <a href="apiConstants.htm#navigationModes">mouse navigation mode</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setNavigationMode(number navigationMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectConfiguration" id="simSetObjectConfiguration"></a>simSetObjectConfiguration / sim.setObjectConfiguration </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets configuration information for an object (object relative position/orientation, joint/path value). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before). See also <a href="#simGetObjectConfiguration">sim.getObjectConfiguration</a> and <a href="#simSetConfigurationTree">sim.setConfigurationTree</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectConfiguration(const simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>data</strong>: data returned by a previous call to <a href="#simGetObjectConfiguration">simGetObjectConfiguration</a><br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectConfiguration(number rawBufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a raw data buffer (value returned by a previous call to <a href="#simGetObjectConfiguration">sim.getObjectConfiguration</a>). If not needed anymore, you can release the raw buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a> (all raw buffers are however automatically released at the end of a simulation)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectFloatParameter" id="simSetObjectFloatParameter"></a>simSetObjectFloatParameter / sim.setObjectFloatParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a floating-point parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simGetObjectFloatParameter">sim.getObjectFloatParameter</a>, <a href="#simSetObjectInt32Parameter">sim.setObjectInt32Parameter</a> and <a href="#simSetObjectStringParameter">sim.setObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectFloatParameter(simInt objectHandle,simInt parameterID,simFloat parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectFloatParameter(number objectHandle,number parameterID,number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectFloatParameter">simxSetObjectFloatParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectFloatParameter">simxSetObjectFloatParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectInt32Parameter" id="simSetObjectInt32Parameter"></a>simSetObjectInt32Parameter / sim.setObjectInt32Parameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets an int32 parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simGetObjectInt32Parameter">sim.getObjectInt32Parameter</a>, <a href="#simSetObjectFloatParameter">sim.setObjectFloatParameter</a> and <a href="#simSetObjectStringParameter">sim.setObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectInt32Parameter(simInt objectHandle,simInt parameterID,simInt parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a></div>
<div><strong>parameter</strong>: parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectInt32Parameter(number objectHandle,number parameterID,number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectIntParameter">simxSetObjectIntParameter</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectIntParameter">simxSetObjectIntParameter</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectMatrix" id="simSetObjectMatrix"></a>simSetObjectMatrix / sim.setObjectMatrix </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the transformation matrix of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before). See also <a href="#simGetObjectMatrix">sim.getObjectMatrix</a>, <a href="#simSetObjectPosition">sim.setObjectPosition</a>, <a href="#simSetObjectOrientation">sim.setObjectOrientation</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectMatrix(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.<br>
</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectMatrix(number objectHandle,number relativeToObjectHandle,table_12 matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectMatrix">simxSetObjectMatrix</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectName" id="simSetObjectName"></a>simSetObjectName / sim.setObjectName </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the name of an object based on its handle. See also <a href="#simGetObjectName">sim.getObjectName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectName(simInt objectHandle,const simChar* objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object. By adding <em>sim.handleflag_altname</em> to the object handle, the object alternative name can be set. By adding <em>sim.handleflag_silenterror</em> to the object handle, errors linked to the naming can be suppressed from output.</div>
<div><strong>objectName</strong>: name (or alternative name) of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectName(number objectHandle,string objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectOrientation" id="simSetObjectOrientation"></a>simSetObjectOrientation / sim.setObjectOrientation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the orientation (<a href="eulerAngles.htm">Euler angles</a>) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before). See also <a href="#simSetObjectQuaternion">sim.setObjectQuaternion</a>, <a href="#simGetObjectOrientation">sim.getObjectOrientation</a>, <a href="#simSetObjectPosition">sim.setObjectPosition</a>, <a href="#simSetObjectMatrix">sim.setObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectOrientation(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* eulerAngles)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.<br>
</div>
<div><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectOrientation(number objectHandle,number relativeToObjectHandle,table_3 eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectOrientation">simxSetObjectOrientation</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectOrientation">simxSetObjectOrientation</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectParent" id="simSetObjectParent"></a>simSetObjectParent / sim.setObjectParent</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets an object's parent object. See also <a href="#simGetObjectParent">sim.getObjectParent</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectParent(simInt objectHandle,simInt parentObjectHandle,simBool keepInPlace)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that will become child of the parent object. Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_assembly</a> (simply add sim_handleflag_assembly to <strong>objectHandle</strong>), if the two objects can be assembled via a predefined assembly transformation (refer to the <strong>assembling</strong> option in the <a href="commonPropertiesDialog.htm">object common properties</a>). In that case, <strong>parentObjectHandle</strong> can't be -1, and <strong>keepInPlace</strong> should be set to false.</div>
<div><strong>parentObjectHandle</strong>: handle of the object that will become parent, or -1 if the object should become parentless.</div>
<div><strong>keepInPlace</strong>: indicates whether the object's absolute position and orientation should stay same</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectParent">simxSetObjectParent</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectParent">simxSetObjectParent</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectPosition" id="simSetObjectPosition"></a>simSetObjectPosition / sim.setObjectPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the position (x, y and z-coordinates) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before). See also <a href="#simGetObjectPosition">sim.getObjectPosition</a>, <a href="#simSetObjectOrientation">sim.setObjectOrientation</a>, <a href="#simSetObjectMatrix">sim.setObjectMatrix</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectPosition(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.<br>
</div>
<div><strong>position</strong>: coordinates of the object (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectPosition(number objectHandle,number relativeToObjectHandle,table_3 position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectPosition">simxSetObjectPosition</a>, <a href="b0RemoteApi-cpp.htm#simxSetObjectPose">simxSetObjectPose</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectPosition">simxSetObjectPosition</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectProperty" id="simSetObjectProperty"></a>simSetObjectProperty / sim.setObjectProperty </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the properties of a scene object. See also <a href="#simGetObjectProperty">sim.getObjectProperty</a>, <a href="#simSetObjectSpecialProperty">sim.setObjectSpecialProperty</a> and <a href="#simSetModelProperty">sim.setModelProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle</div>
<div><strong>prop</strong>: object property. See the <a href="apiConstants.htm#sceneObjectProperties">object property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectProperty(number objectHandle,number prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectQuaternion" id="simSetObjectQuaternion"></a>simSetObjectQuaternion / sim.setObjectQuaternion  </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the quaternion (x,y,z,w) of an object. Be very careful to set only valid value (i.e. normalized), otherwise you will experience strange effects. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">sim.resetDynamicObject</a> just before). See also <a href="#simSetObjectOrientation">sim.setObjectOrientation</a> and the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectQuaternion(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* quaternion)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.<br>
</div>
<div><strong>quaternion</strong>: the quaternion (x,y,z,w)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectQuaternion(number objectHandle,number relativeToObjectHandle,table_4 quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectQuaternion">simxSetObjectQuaternion</a>, <a href="b0RemoteApi-cpp.htm#simxSetObjectPose">simxSetObjectPose</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetObjectQuaternion">simxSetObjectQuaternion</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectSizeValues" id="simSetObjectSizeValues"></a>simSetObjectSizeValues / sim.setObjectSizeValues </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the x, y and z size values of a scene object. The size values are different from the real object sizes. Use this to be able to react to scaling operations. See also <a href="#simGetObjectSizeValues">sim.getObjectSizeValues</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectSizeValues(simInt objectHandle,const simFloat* sizeValues)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object</div>
<div><strong>sizeValues (input)</strong>: a pointer to 3 size values (x, y and z)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectSizeValues(number objectHandle,table_3 sizeValues)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectSpecialProperty" id="simSetObjectSpecialProperty"></a>simSetObjectSpecialProperty / sim.setObjectSpecialProperty </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the special properties of a scene object. See also <a href="#simGetObjectSpecialProperty">sim.getObjectSpecialProperty</a>, <a href="#simSetObjectProperty">sim.setObjectProperty</a> and <a href="#simSetModelProperty">sim.setModelProperty</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectSpecialProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle</div>
<div><strong>prop</strong>: object special property. See the <a href="apiConstants.htm#sceneObjectSpecialProperties">object special property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectSpecialProperty(number objectHandle,number prop)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetObjectStringParameter" id="simSetObjectStringParameter"></a>simSetObjectStringParameter / sim.setObjectStringParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a string parameter of a <a href="objects.htm">scene object</a> or <a href="calculationModules.htm#calcObjects">calculation object</a>. See also <a href="#simGetObjectStringParameter">sim.getObjectStringParameter</a>, <a href="#simSetObjectInt32Parameter">sim.setObjectInt32Parameter</a> and <a href="#simSetObjectFloatParameter">sim.setObjectFloatParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectStringParameter(simInt objectHandle,simInt parameterID,simChar* parameter,simInt parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a></div>
<div><strong>parameter</strong>: parameter value (can contain embedded zeros)</div>
<div><strong>parameterLength</strong>: the length of the parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setObjectStringParameter(number objectHandle,number parameterID,string parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
Same as C-function
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetObjectStringParameter">simxSetObjectStringParameter</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetPage" id="simSetPage"></a>simSetPage / sim.setPage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Switches between pages (main scene views). See also <a href="#simGetPage">sim.getPage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPage(simInt index)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: index of the page. Valid values are 0-7</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setPage(number index)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetPathPosition" id="simSetPathPosition"></a>simSetPathPosition / sim.setPathPosition </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic position of a path object (i.e. the position along the path). The position is given in meters, but the actual position is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object.This function is the equivalent of <a href="#simSetJointPosition">sim.setJointPosition</a>, but for a path object. See also <a href="#simGetPathPosition">sim.getPathPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPathPosition(simInt objectHandle,simFloat position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected path length calculation method)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setPathPosition(number objectHandle,number position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetPointCloudOptions" id="simSetPointCloudOptions"></a>simSetPointCloudOptions / sim.setPointCloudOptions </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets various properties of a <a href="pointClouds.htm">point cloud</a>. See also <a href="#simGetPointCloudOptions">sim.getPointCloudOptions</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPointCloudOptions(simInt pointCloudHandle,simFloat maxVoxelSize,simInt maxPtCntPerVoxel,simInt options,simFloat pointSize,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>maxVoxelSize</strong>: the maximum size of the octree voxels containing points</div>
<div><strong>maxPtCntPerVoxel</strong>: the maximum number of points allowed in a same octree voxel</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): points have random colors</div>
<div class=tab>bit1 set (2): show octree structure</div>
<div class=tab>bit2 set (4): reserved. keep unset</div>
<div class=tab>bit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="collidableObjects.htm">collidable</a>, <a href="measurableObjects.htm">measurable</a> or <a href="detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</div>
<div class=tab>bit4 set (16): color is emissive</div>
<div><strong>pointSize</strong>: the size of the points, in pixels</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setPointCloudOptions(number pointCloudHandle,number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetReferencedHandles" id="simSetReferencedHandles"></a>simSetReferencedHandles / sim.setReferencedHandles </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Attaches a list of custom handles to a given scene object. Those custom handles are handles of other objects, that are linked to the given scene object (for whatever purpose). The advantage of storing references to other objects with this function is that V-REP will take care of correctly adjusting the references if needed: For instance, imagine <em>objectA</em> storing the handle of <em>objectB</em> via this function. If <em>objectB</em> is deleted, then the stored handle will become -1. If <em>objectA</em> and <em>objectB</em> are duplicated at the same time, then the duplicate of <em>objectA</em> will store the handle of the duplicate of <em>objectB</em>. Optionally, if <em>sim.handleflag_keeporiginal </em>is specified, then linking to original objects is guaranteed, e.g. in above example, after a duplication of <em>objectA</em>, the duplicate of <em>objectA</em> will store the handle of the original <em>objectB</em> (if <em>objectB</em> still exists). See also <a href="#simGetReferencedHandles">sim.getReferencedHandles</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetReferencedHandles(simInt objectHandle,simInt count,const simInt* referencedHandles,const simInt* reserved1,const simInt* reserved2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object that will store the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved.</div>
<div><strong>count</strong>: the number of handles to store</div>
<div><strong>referencedHandles</strong>: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups and collections.</div>
<div><strong>reserved1</strong>: reserved for future extensions</div>
<div><strong>reserved2</strong>: reserved for future extensions</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setReferencedHandles(number objectHandle,table referencedHandles)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the  C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to the  C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetScriptAttribute" id="simSetScriptAttribute"></a>simSetScriptAttribute / sim.setScriptAttribute </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets various script attributes or properties. See also <a href="#simGetScriptAttribute">sim.getScriptAttribute</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptAttribute(simInt scriptHandle,simInt attributeID,simFloat floatVal,simInt intOrBoolVal)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div><strong>attributeID</strong>: the <a href="apiConstants.htm#scriptAttributes">script attributeID</a></div>
<div><strong>floatVal</strong>: the floating point attribute (if applicable)</div>
<div><strong>intOrBoolVal</strong>: the integer or Boolean attribute (if applicable)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setScriptAttribute(number scriptHandle,number attributeID,number/boolean attribute)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetScriptRawBuffer" id="simSetScriptRawBuffer"></a>simSetScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Attaches a raw buffer to a given script. All raw buffers are automatically released at the end of a simulation. See also <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptRawBuffer(simInt scriptHandle,const simChar* buffer,simInt bufferSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>buffer</strong>: pointer to the buffer</div>
<div><strong>bufferSize</strong>: size of the buffer (the function will copy the buffer which can then immediately be released by the calling application)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a handle to the buffer. Using that handle and the <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a>, the buffer can be retrieved. In case of an error, the return value is -1<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetScriptSimulationParameter" id="simSetScriptSimulationParameter"></a>simSetScriptSimulationParameter / sim.setScriptSimulationParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a main script's or child script's parameter in its simulation parameter list. Useful for simple interaction with the user or for simple parameter exchange with other scripts. See also <a href="#simGetScriptSimulationParameter">sim.getScriptSimulationParameter</a> and the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptSimulationParameter(simInt scriptHandle,const simChar* parameterName,const simChar* parameterValue,simInt parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script, or sim_handle_main_script or sim_handle_all</div>
<div><strong>parameterName</strong>: name of the parameter to set</div>
<div><strong>parameterValue</strong>: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))<br>
</div>
<div><strong>parameterLength</strong>: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of parameters that were set (can be &gt;1 if sim_handle_all was specified) or -1 if the parameterName could not be found or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number setCount=sim.setScriptSimulationParameter(number scriptHandle,string parameterName,string/number parameterValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>scriptHandle</strong>: handle of the script, or sim.handle_main_script, sim.handle_all, sim.handle_tree, sim.handle_chain or sim.handle_self</div>
<div><strong>parameterName</strong>: Same as C-function</div>
<div><strong>parameterValue</strong>: Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetScriptText" id="simSetScriptText"></a>simSetScriptText / sim.setScriptText </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a new content for a script (i.e. attaches a new Lua code). During a simulation, the new script content might not be taken into consideration if a previous code was already executed at least once. See also <a href="#simGetScriptText">simGetScriptText</a>, <a href="#simAddScript">sim.addScript</a> and <a href="#simAssociateScriptWithObject">sim.associateScriptWithObject</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptText(simInt scriptHandle,const simChar* scriptText)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div><strong>scriptText</strong>: pointer to a script buffer (0-terminated buffer). This function will copy the buffer content, so that it can immediately be released after this call<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setScriptText(number scriptHandle,string scriptText)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetScriptVariable" id="simSetScriptVariable"></a>simSetScriptVariable / sim.setScriptVariable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets or clears a script variable (i.e. a Lua variable). Call this only:<br>
a) from the main thread, or:<br>
b) from a thread that originated from a threaded child script. In that case, you cannot set a variable in a non-threaded child script.<br>
See also <a href="#simCallScriptFunction">sim.callScriptFunction</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptVariable(simInt scriptHandleOrType,const simChar* variableNameAtScriptName,simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandleOrType</strong>: the handle of the script, otherwise the type of the script:</div>
<div class=tab><em>sim_scripttype_mainscript</em> (0): the <a href="mainScript.htm">main script</a> is the target.</div>
<div class=tab><em>sim_scripttype_childscript</em> (1): a <a href="childScripts.htm">child script</a> is the target. In that case, <em>arrayNameAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div class=tab><em>sim_scripttype_customizationscript</em> (6): a <a href="customizationScripts.htm">customization script</a> is the target. In that case, <em>arrayNameAtScriptName</em> should also contain the name of the object associated with the script.</div>
<div><strong>variableNameAtScriptName</strong>: the name of the variable. If <em>scriptHandleOrType</em> is <em>sim_scripttype_childscript</em>, or <em>sim_scripttype_customizationscript</em>, then <em>variableNameAtScriptName</em> should also contain the name of the object associated with the script: &quot;variableName@scriptName&quot;.</div>
<div><strong>stackHandle</strong>: the <a href="#simCreateStack">handle of a stack object</a>. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value <em>nil</em>. See also the <a href="apiFunctionListCategory.htm#stacks">available stack functions</a>.</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setScriptVariable(string variableNameAtScriptName,number scriptHandleOrType,variable)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to the C-function, with the difference that a stack object is not required, and the desired variable value can directly be appended to the first two arguments.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetShapeColor" id="simSetShapeColor"></a>simSetShapeColor / sim.setShapeColor </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets the color (or transforms it) of one or several shapes. See also <a href="#simGetShapeColor">sim.getShapeColor</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeColor(simInt shapeHandle,simChar* colorName,simInt colorComponent,simFloat* rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape, or sim_handle_all if the command should be directed at all shapes<br>
</div>
<div><strong>colorName</strong>: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:</div>
<div class=tab>&quot;@0&quot;: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.</div>
<div class=tab>&quot;@1&quot;: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.</div>
<div class=tab>&quot;@2&quot;: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.</div>
<div><strong>colorComponent</strong>: a <a href="apiConstants.htm#colorComponents">color component</a></div>
<div><strong>rgbData</strong>: red, green and blue components of the color (3 values), or the transparency value (1 value)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setShapeColor(number shapeHandle,string colorName,number colorComponent,table_3 rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetShapeMassAndInertia" id="simSetShapeMassAndInertia"></a>simSetShapeMassAndInertia / sim.setShapeMassAndInertia </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies mass and inertia information to a shape. If simulation is running, the shape will be dynamically reset (similar to calling <a href="#simResetDynamicObject">sim.resetDynamicObject</a> right after). See also <a href="#simGetShapeMassAndInertia">sim.getShapeMassAndInertia</a>, <a href="#simGetObjectMatrix">sim.getObjectMatrix</a> and <a href="#simBuildMatrix">sim.buildMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeMassAndInertia(simInt shapeHandle,simFloat mass,const simFloat* inertiaMatrix,const simFloat* centerOfMass,const simFloat* transformation)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the <a href="shapes.htm">shape object</a></div>
<div><strong>mass</strong>: the new mass of the object</div>
<div><strong>inertia matrix</strong>: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of <strong>transformation</strong> (see further below). </div>
<div><strong>centerOfMass</strong>: the new position of the center of mass, relative to the specified <strong>transformation</strong> (see next item).</div>
<div><strong>transformation</strong>: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See <a href="#simGetObjectMatrix">here</a> to see how matrix transformations are specified in V-REP.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<a href="#simReleaseBuffer"></a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setShapeMassAndInertia(number shapeHandle,number mass,table_9 inertiaMatrix,table_3 centerOfMass,table_12 transformation=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>See the C-function for details</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>See the C-function for details</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetShapeMaterial" id="simSetShapeMaterial"></a>simSetShapeMaterial / sim.setShapeMaterial </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the material (used by the physics engines) of a specific shape. You might have to also call <a href="#simResetDynamicObject">sim.resetDynamicObject</a> for changes to take effect.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeMaterial(simInt shapeHandle,simInt materialIdOrShapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: the handle of the shape. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>materialIdOrShapeHandle</strong>: a <a href="apiConstants.htm#dynMatTypes">predefined dynamic material ID</a>, or the handle of another shape you wish to copy the material properties from.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setShapeMaterial(number shapeHandle,number materialIdOrShapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetShapeTexture" id="simSetShapeTexture"></a>simSetShapeTexture / sim.setShapeTexture </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies (or removes) a texture to a shape. See also <a href="#simGetTextureId">sim.getTextureId</a>, <a href="#simGetShapeTextureId">sim.getShapeTextureId</a>, <a href="#simCreateTexture">sim.createTexture</a> and <a href="#simApplyTexture">simApplyTexture</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeTexture(simInt shapeHandle,simInt textureId,simInt mappingMode,simInt options,const simFloat* uvScaling,const simFloat* position,const simFloat* orientation</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: the handle of the shape.</div>
<div><strong>textureId</strong>: the ID of the texture or -1 to remove any existing texture. See also <a href="#simGetTextureId">simGetTextureId</a>, <a href="#simGetShapeTextureId">simGetShapeTextureId</a> and <a href="#simCreateTexture">simCreateTexture</a>.</div>
<div><strong>mappingMode</strong>: the <a href="apiConstants.htm#textureMappingModes">texture mapping mode</a>.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0: if set (1), then adjacent texture pixels are not interpolated.</div>
<div class=tab>bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).</div>
<div class=tab>bit2: if set (4), then the texture will be repeated along the U direction.</div>
<div class=tab>bit3: if set (8), then the texture will be repeated along the V direction.</div>
<div><strong>uvScaling</strong>: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.</div>
<div><strong>position</strong>: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.</div>
<div><strong>orientation</strong>: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setShapeTexture(number shapeHandle,number textureId,number mappingMode,number options,table_2 uvScaling,table_3 position=nil,table_3 orientation=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetSimulationPassesPerRenderingPass" id="simSetSimulationPassesPerRenderingPass"></a>simSetSimulationPassesPerRenderingPass</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the number of simulation passes (calculation passes) per frame (display). This function will have an effect only if using a <strong>custom dt</strong> (which can be set in the <a href="simulationPropertiesDialog.htm">simulation settings dialog</a>). See also <a href="#simGetSimulationPassesPerRenderingPass">simGetSimulationPassesPerRenderingPass</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetSimulationPassesPerRenderingPass(simInt p)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>p</strong>: the number of simulation passes for one rendering pass</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of error, otherwise the new number of simulation passes per frame. </div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetSphericalJointMatrix" id="simSetSphericalJointMatrix"></a>simSetSphericalJointMatrix / sim.setSphericalJointMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic orientation matrix of a spherical joint object. This function cannot be used with non-spherical joints (use <a href="#simSetJointPosition">sim.setJointPosition</a> instead). See also <a href="#simGetJointMatrix">sim.getJointMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetSphericalJointMatrix(simInt objectHandle,const simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])<br>
</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])<br>
</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setSphericalJointMatrix(number objectHandle,table_12 matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: -</div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetSphericalJointMatrix">simxSetSphericalJointMatrix</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetStringNamedParam" id="simSetStringNamedParam"></a>simSetStringNamedParam / sim.setStringNamedParam</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a named string or buffer value. See also <a href="#simGetStringNamedParam">sim.getStringNamedParam</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetStringNamedParam(const simChar* paramName,const simChar* stringParam,simInt paramLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>paramName</strong>: the key or name of the parameter</div>
<div><strong>stringParam</strong>: the string or buffer value</div>
<div><strong>paramLength</strong>: the size of the string or buffer value</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if an existing parameter was replaced, 1 if the parameter was set<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setStringNamedParam(string paramName,string stringParam)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetStringParameter" id="simSetStringParameter"></a>simSetStringParameter / sim.setStringParameter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a <a href="apiConstants.htm#stringParameters">string parameter</a>. See also <a href="#simGetStringParameter">sim.getStringParameter</a>, <a href="#simSetBoolParameter">sim.setBoolParameter</a>, <a href="#simSetArrayParameter">sim.setArrayParameter</a>, <a href="#simSetFloatParameter">sim.setFloatParameter</a> and <a href="#simSetInt32Parameter">sim.setInt32Parameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetStringParameter(simInt parameter,const simChar* stringState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#stringParameters">string parameter identifier</a></div>
<div><strong>stringState</strong>: new state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful. -1 if parameter is not known<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setStringParameter(number parameter,string stringState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetStringParameter">simxSetStringParameter</a></div>
<div>Legacy remote API: -</div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetStringSignal" id="simSetStringSignal"></a>simSetStringSignal / sim.setStringSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of a string signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetStringSignal">sim.getStringSignal</a>, the <a href="apiFunctionListCategory.htm#signals">other signal functions</a>,  the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a> and <a href="#simPersistentDataWrite">sim.persistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetStringSignal(const simChar* signalName,const simChar* signalValue,simInt stringLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal (which may contain any value, including embedded zeros)</div>
<div><strong>stringLength</strong>: the size of the string value.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setStringSignal(string signalName,string signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetStringSignal">simxSetStringSignal</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetStringSignal">simxSetStringSignal</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetThreadAutomaticSwitch" id="simSetThreadAutomaticSwitch"></a>simSetThreadAutomaticSwitch / sim.setThreadAutomaticSwitch </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows to temporarily forbid thread switches. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. For complete control over the switching moment, see also <a href="#simGetThreadAutomaticSwitch">sim.getThreadAutomaticSwitch</a>, <a href="#simSetThreadSwitchTiming">sim.setThreadSwitchTiming</a>, <a href="#simSwitchThread">sim.switchThread</a>, <a href="#simSetThreadIsFree">sim.setThreadIsFree</a> and <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setThreadAutomaticSwitch(Boolean switchIsAutomatic)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>switchIsAutomatic</strong>: if true, the thread will be able to automatically switch to another thread, otherwise the switching is temporarily disabled.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the command was successful, 0 if it didn't have an effect (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetThreadIsFree" id="simSetThreadIsFree"></a>simSetThreadIsFree / sim.setThreadIsFree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Threads created by V-REP are never running concurrently, they rather behave like coroutines. This allows achieving same results as with &quot;pure threads&quot;, except when an external command is blocking (e.g. commands not directly supported by V-REP). Those can be lengthly image processing routines, or socket communication routines for example. When such external blocking commands are called, V-REP appears frozen until the external commands return. To avoid such a situation, you can declare a non-blocking section with the <a href="#simSetThreadIsFree">sim.setThreadIsFree</a> command: <a href="#simSetThreadIsFree">sim.setThreadIsFree</a>(true) starts a non-blocking section, and <a href="#simSetThreadIsFree">sim.setThreadIsFree</a>(false) closes it. Try to avoid using V-REP commands when in a non-blocking section (bad synchronization), and never forget to close a non-blocking section, otherwise V-REP will hang indefinitely. Use <a href="#simSetThreadIsFree">sim.setThreadIsFree</a> with extra care when calling it from C. A thread running in a non-blocking section cannot be paused nor stopped. This command has no effect when called from the main thread or a non-threaded script.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetThreadIsFree(simBool freeMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>freeMode</strong>: specify 1 to start a non-blocking section. Specify 0 to end a non-blocking section<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setThreadIsFree(Boolean freeMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>freeMode</strong>: specify true to start a non-blocking section. Specify false to end a non-blocking section<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetThreadResumeLocation" id="simSetThreadResumeLocation"></a>simSetThreadResumeLocation / sim.setThreadResumeLocation </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying when and in which order child script threads are resumed. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use <em>regular</em> threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution when the <a href="mainScript.htm">main script</a> calls <a href="#simResumeThreads">sim.resumeThreads</a> with the corresponding argument, which represents a <a href="apiConstants.htm#threadResumeLocations">child script thread resume location</a>. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread with this function. See also <a href="#simSetThreadSwitchTiming">sim.setThreadSwitchTiming</a>, <a href="#simSetThreadAutomaticSwitch">sim.setThreadAutomaticSwitch</a>, <a href="#simSwitchThread">sim.switchThread</a> and <a href="#simSetThreadIsFree">sim.setThreadIsFree</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setThreadResumeLocation(number location,number priority)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>location</strong>: a <a href="apiConstants.htm#threadResumeLocations">child script thread resume location</a>.</div>
<div><strong>priority</strong>: a <a href="apiConstants.htm#scriptExecutionOrder">script resume or execution priority</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the command was applied, 0 if it was not (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetThreadSwitchTiming" id="simSetThreadSwitchTiming"></a>simSetThreadSwitchTiming / sim.setThreadSwitchTiming </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying a switching time for the thread in which the current script runs. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads (the execution duration per calculation pass). By default this value is 2 millisecond, but this function allows changing that value (on a thread-basis). Acceptable values are between 0 and 200. For complete control over the switching moment, see also <a href="#simSetThreadAutomaticSwitch">sim.setThreadAutomaticSwitch</a>, <a href="#simSwitchThread">sim.switchThread</a>, <a href="#simSetThreadIsFree">sim.setThreadIsFree</a> and <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setThreadSwitchTiming(number deltaTimeInMilliseconds)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>deltaTimeInMilliseconds</strong>: desired non-stop execution time before a switching occurs. A value of x will let the thread execute for x-1 to x milliseconds before switching to another thread.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the timing was set, 0 if it was not set (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetVisionSensorCharImage" id="simSetVisionSensorCharImage"></a>simSetVisionSensorCharImage / sim.setVisionSensorCharImage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the rgb-image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as <strong>external input</strong>. Use <a href="#simGetVisionSensorResolution">sim.getVisionSensorResolution</a> to know the size of the image buffer that you need to provide (buffer size=resolutionX *resolutionY*3). The &quot;regular&quot; use of this function is to first read the data from a vision sensor with <a href="#simGetVisionSensorCharImage">sim.getVisionSensorCharImage</a>, do some custom filtering, then write the modified image back. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be &quot;looked through&quot; like camera objects. See also <a href="#simSetVisionSensorImage">sim.setVisionSensorImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetVisionSensorCharImage(simInt sensorHandle,const simUChar* image)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object.   Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_greyscale</a> (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values..</div>
<div><strong>image</strong>: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 255. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the applied filter didn't trigger anything, 1 if the appIied filter triggered a detection<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.setVisionSensorCharImage(number sensorHandle,string image)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div>Similar as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetVisionSensorImage">simxSetVisionSensorImage</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetVisionSensorImage">simxSetVisionSensorImage</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetVisionSensorFilter" id="simSetVisionSensorFilter"></a>simSetVisionSensorFilter / sim.setVisionSensorFilter </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the parameters and settings of a specific <a href="visionSensorFilterComposition.htm">filter component</a> of a <a href="visionSensors.htm">vision sensor</a>. See also <a href="#simGetVisionSensorFilter">sim.getVisionSensorFilter</a> and the other <a href="apiFunctionListCategory.htm#visionSensor">vision sensor related API functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetVisionSensorFilter(simInt visionSensorHandle,simInt filterIndex,simInt options,const simInt* pSizes,const simUChar* bytes,const simInt* ints,const simFloat* floats,const simUChar* custom)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>.</div>
<div><strong>filterIndex</strong>: the zero-based index of the filter position.</div>
<div><strong>options</strong>: bit-coded value:</div>
<div class=tab>bit 0 set (1): the component is enabled</div>
<div><strong>pSizes</strong>: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).</div>
<div><strong>bytes</strong>: a buffer of bytes values representing the byte parameters of the filter component.</div>
<div><strong>ints</strong>: a buffer of ints values representing the int parameters of the filter component.</div>
<div><strong>floats</strong>: a buffer of floats values representing the float parameters of the filter component.</div>
<div><strong>custom</strong>: a buffer of bytes values representing the custom parameters of the filter component.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the <em>filterIndex</em> is not valid, otherwise the <a href="apiConstants.htm#filterComponents">type of filter component</a> pointed by the <em>filterIndex</em>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number filterType=sim.setVisionSensorFilter(number sensorHandle,number filterIndex,number options,table byteVals,table intVals,table floatVals,string customBuffer)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSetVisionSensorImage" id="simSetVisionSensorImage"></a>simSetVisionSensorImage / sim.setVisionSensorImage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the rgb-image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as <strong>external input</strong>. Use <a href="#simGetVisionSensorResolution">sim.getVisionSensorResolution</a> to know the size of the image buffer that you need to provide (buffer size=resolutionX *resolutionY*3). The &quot;regular&quot; use of this function is to first read the data from a vision sensor with <a href="#simGetVisionSensorImage">sim.getVisionSensorImage</a>, do some custom filtering, then write the modified image back. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be &quot;looked through&quot; like camera objects. See also <a href="#simSetVisionSensorCharImage">sim.setVisionSensorCharImage</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetVisionSensorImage(simInt sensorHandle,const simFloat* image)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object. Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim_handleflag_greyscale</a> (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values.</div>
<div><strong>image</strong>: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 1. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the applied filter didn't trigger anything, 1 if the appIied filter triggered a detection<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn> <div> (1) number result=sim.setVisionSensorImage(number sensorHandle,table image) </div>
<div> (2) number result=sim.setVisionSensorImage(number sensorHandle,string image)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object. Can be combined with <a href="apiConstants.htm#specialHandleFlags">sim.handleflag_greyscale</a> (simply add sim.handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values.</div>
<div>(1) a table containing individual values [0-1] for the red, green and blue components, or for the grey component.</div>
<div>(2) a string containing individual chars [0-255] for the red, green and blue components, or for the grey component.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxSetVisionSensorImage">simxSetVisionSensorImage</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxSetVisionSensorImage">simxSetVisionSensorImage</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simStartSimulation" id="simStartSimulation"></a>simStartSimulation / sim.startSimulation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a start of a simulation (or a resume of a paused simulation). See also <a href="#simPauseSimulation">sim.pauseSimulation</a>, <a href="#simStopSimulation">sim.stopSimulation</a> and <a href="#simGetSimulationState">sim.getSimulationState</a>. See also the <a href="simulation.htm">simulation state diagram</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simStartSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.startSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxStartSimulation">simxStartSimulation</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxStartSimulation">simxStartSimulation</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simStopSimulation" id="simStopSimulation"></a>simStopSimulation / sim.stopSimulation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a stop of the running simulation. See also <a href="#simStartSimulation">sim.startSimulation</a>, <a href="#simPauseSimulation">sim.pauseSimulation</a> and <a href="#simGetSimulationState">sim.getSimulationState</a>. See also the <a href="simulation.htm">simulation state diagram</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simStopSimulation()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.stopSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 

<tr class=apiTableTr> 
<td class=remApiTableLeftCParam>
Remote API equiv.
</td> 
<td class=remApiTableRightCParam>
<div>B0-based remote API: <a href="b0RemoteApi-cpp.htm#simxStopSimulation">simxStopSimulation</a></div>
<div>Legacy remote API: <a href="remoteApiFunctions.htm#simxStopSimulation">simxStopSimulation</a></div>
</td> 
</tr> 

</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSubtractObjectFromOctree" id="simSubtractObjectFromOctree"></a>simSubtractObjectFromOctree / sim.subtractObjectFromOctree </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object from an <a href="octrees.htm">octree</a>, as voxel subtractions. See also <a href="#simInsertObjectIntoOctree">sim.insertObjectIntoOctree</a>, <a href="#simRemoveVoxelsFromOctree">sim.removeVoxelsFromOctree</a> and the other <a href="apiFunctionListCategory.htm#octree">octree related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSubtractObjectFromOctree(simInt octreeHandle,simInt objectHandle,simInt options,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>octreeHandle</strong>: the handle of the octree. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>objectHandle</strong>: the handle of the object to subtract. Only potentially <a href="collidableObjects.htm">collidable objects</a> are supported</div>
<div><strong>options</strong>: reserved. Set to 0</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of voxels in the octree</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalVoxelCnt=sim.subtractObjectFromOctree(number octreeHandle,number objectHandle,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSubtractObjectFromPointCloud" id="simSubtractObjectFromPointCloud"></a>simSubtractObjectFromPointCloud / sim.subtractObjectFromPointCloud </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object from a <a href="pointClouds.htm">point cloud</a>, as a subtraction. See also <a href="#simInsertPointsIntoPointCloud">sim.insertPointsIntoPointCloud</a>, <a href="#simInsertObjectIntoPointCloud">sim.insertObjectIntoPointCloud</a>, <a href="#simRemovePointsFromPointCloud">sim.removePointsFromPointCloud</a> and the other <a href="apiFunctionListCategory.htm#pointCloud">point cloud related functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSubtractObjectFromPointCloud(simInt pointCloudHandle,simInt objectHandle,simInt options,simFloat tolerance,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pointCloudHandle</strong>: the handle of the point cloud. See also <a href="#simGetObjectHandle">simGetObjectHandle</a></div>
<div><strong>objectHandle</strong>:  the handle of the object to subtract. Only potentially <a href="measurableObjects.htm">measurable objects</a> are supported.</div>
<div><strong>options</strong>: reserved. Set to 0</div>
<div><strong>tolerance</strong>: a distance used as a tolerance value</div>
<div><strong>reserved</strong>: reserved for future extensions. Set to NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the total number of points in the point cloud</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number totalPointCnt=sim.subtractObjectFromPointCloud(number pointCloudHandle,number objectHandle,number options,number tolerance)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simSwitchThread" id="simSwitchThread"></a>simSwitchThread / sim.switchThread </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying the exact moment at which the current thread should switch to another thread. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads. By default this value is 2 millisecond, but can be modified with <a href="#simSetThreadSwitchTiming">sim.setThreadSwitchTiming</a>. That timing can be shortened with <a href="#simSwitchThread">sim.switchThread</a>. Use with care when calling this function from a plugin. See also the <a href="#simSetThreadAutomaticSwitch">sim.setThreadAutomaticSwitch</a>, <a href="#simSetThreadResumeLocation">sim.setThreadResumeLocation</a> and <a href="#simSetThreadIsFree">sim.setThreadIsFree</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSwitchThread()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the thread was switched (the current thread gave control to other threads until the next calculation pass), 0 if it was not switched (e.g. because the function was called from the main or application thread, or from a thread started by the user), or -1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.switchThread()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the thread was switched (the current thread gave control to other threads until the next calculation pass), 0 if it was not switched (e.g. because the function was called from the main or application thread), or -1 in case of an error.
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTextEditorClose" id="simTextEditorClose"></a>sim.textEditorClose </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes a  text edition window previously opened with <a href="#simTextEditorOpen">sim.textEditorOpen</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>string text,table_2 pos,table_2 size=sim.textEditorClose(number handle)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>handle</strong>: the handle of the text editor window.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>text</strong>: the text of the editor, or nil in case of an error</div>
<div><strong>pos</strong>: the size of the editor, or nil in case of an error</div>
<div><strong>size</strong>: the absolute position the editor, or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTextEditorGetInfo" id="simTextEditorGetInfo"></a>sim.textEditorGetInfo </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retieves information from a text edition window previously opened with <a href="#simTextEditorOpen">sim.textEditorOpen</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>string text,table_2 pos,table_2 size,boolean visible=sim.textEditorGetInfo(number handle)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>handle</strong>: the handle of the text editor window.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>text</strong>: the text of the editor, or nil if the given handle is not associated with any text editor window (or the window was already closed)</div>
<div><strong>pos</strong>: the size of the editor</div>
<div><strong>size</strong>: the absolute position the editor</div>
<div><strong>visible</strong>: the visible state the editor</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTextEditorOpen" id="simTextEditorOpen"></a>sim.textEditorOpen</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a text edition window. See <a href="#simOpenTextEditor">simOpenTextEditor</a> for the C version of this function. See also <a href="#simTextEditorClose">sim.textEditorClose</a>, <a href="#simTextEditorShow">sim.textEditorShow</a> and <a href="#simTextEditorGetInfo">sim.textEditorGetInfo</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam><div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>number handle=sim.textEditorOpen(string initText,string properties)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>initText</strong>: the initial text to be displayed.</div>
<div><strong>xml</strong>: an XML description of the text editor's properties. Can be an empty string for default properties. Following is a valid content:</div>
<br>

<pre class=lightRedBoxNoMarginAndSmall>&lt;editor title=&quot;Window title&quot; editable=&quot;true&quot; searchable=&quot;true&quot;
  tab-width=&quot;4&quot; toolbar=&quot;false&quot; statusbar=&quot;false&quot; resizable=&quot;true&quot; modal=&quot;false&quot;
  on-close=&quot;callbackFunction&quot; closeable=&quot;true&quot; position=&quot;100 100&quot; size=&quot;800 600&quot;
  placement=&quot;absolute&quot; font=&quot;Courier&quot; font-size=&quot;14&quot; activate=&quot;false&quot; editable=&quot;true&quot;
  line-numbers=&quot;true&quot; max-lines=&quot;0&quot; is-lua=&quot;true&quot; wrap-word=&quot;false&quot;
  text-col=&quot;50 50 50&quot; background-col=&quot;190 190 190&quot; selectionColor=&quot;128 128 255&quot;
  comment-col=&quot;0 140 0&quot; number-col=&quot;220 0 220&quot; string-col=&quot;255 255 0&quot;
  character-col=&quot;255 255 0&quot; operator-col=&quot;0 0 0&quot; identifier-col=&quot;64 64 64&quot;
  preprocessor-col=&quot;0 128 128&quot; keyword1-col=&quot;152 0 0&quot; keyword2-col=&quot;220 80 20&quot;
  keyword3-col=&quot;0 0 255&quot; keyword4-col=&quot;152 64 0&quot;&gt;

  &lt;keywords1&gt;
    &lt;item word=&quot;sim.getObjectHandle&quot; autocomplete=&quot;true&quot;
      calltip=&quot;number handle=sim.getObjectHandle(number objectName)&quot; /&gt;
    &lt;item word=&quot;sim.getObjectPosition&quot; autocomplete=&quot;true&quot;
      calltip=&quot;table_3 pos=sim.getObjectPosition(number handle,
        number relHandle)&quot; /&gt;
  &lt;/keywords1&gt;
  &lt;keywords2&gt;
    &lt;item word=&quot;sim.getObjectOrientation&quot; autocomplete=&quot;true&quot;
      calltip=&quot;table_3 euler=sim.getObjectOrientation(number handle,
        number relHandle)&quot; /&gt;
  &lt;/keywords2&gt;
&lt;/editor&gt;</pre>
<em>placement </em> attribute recognizes following values: <em>center</em>, <em>absolute</em> and <em>relative</em>.

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>handle</strong>: the handle of the text editor.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTextEditorShow" id="simTextEditorShow"></a>sim.textEditorShow </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Shows or hides a  text edition window previously opened with <a href="#simTextEditorOpen">sim.textEditorOpen</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn><div>number res=sim.textEditorShow(number handle,boolean showState)</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>handle</strong>: the handle of the text editor window.</div>
<div><strong>showState</strong>: the desired show state of the text editor window.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>res</strong>: -1 in case of an error, 1 if the visibility state was toggled.</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTransformBuffer" id="simTransformBuffer"></a>simTransformBuffer / sim.transformBuffer </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Modified a buffer than contains packed data. See also the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn><div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>1) string outBuffer=sim.transformBuffer(string inBuffer,number inFormat,number multiplier,number offset,number outFormat)</div>
<div>2) table outBuffer=sim.transformBuffer(string inBuffer,sim.buffer_uint8,0,number splitSize,sim.buffer_split)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>inBuffer</strong>: the input buffer that contains packed data.</div>
<div><strong>inFormat</strong>: a <a href="apiConstants.htm#bufferTypes">buffer type</a>.</div>
<div><strong>multiplier</strong>: a multiplier value. We have out=offset+multiplier*in</div>
<div><strong>offset/splitSize</strong>: an offset or split size value. We have out=offset+multiplier*in</div>
<div><strong>outFormat</strong>: the desired <a href="apiConstants.htm#bufferTypes">buffer type</a> for the returned buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>1) <strong>outBuffer</strong>: the modified buffer, or nil in case of an error</div>
<div>2) <strong>table</strong>: the various split buffers, or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTransformImage" id="simTransformImage"></a>simTransformImage / sim.transformImage </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Transforms an image in various ways. See also <a href="#simLoadImage">sim.loadImage</a>, <a href="#simGetScaledImage">sim.getScaledImage</a>, <a href="#simTransformBuffer">sim.transformBuffer</a> and <a href="#simCombineRgbImages">sim.combineRgbImages</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTransformImage(simUChar* image,const simInt* resolution,simInt options,const simFloat* floatParams,const simInt* intParams,simVoid* reserved)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>image</strong>: a pointer to rgb or rgba values of the image</div>
<div><strong>resolution</strong>: the resolution of the image</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set (1): the provided image is rgba, otherwise it is rgb</div>
<div class=tab>bit1 set (2): the image will be flipped on its x-axis</div>
<div class=tab>bit2 set (4): the image will be flipped on its y-axis</div>
<div><strong>floatParams</strong>: Reserved for future extension. Set to NULL.</div>
<div><strong>intParams</strong>: Reserved for future extension. Set to NULL.</div>
<div><strong>reserved</strong>: Reserved for future extension. Set to NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.transformImage(string image,table_2 resolution,number options)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTransformVector" id="simTransformVector"></a>simTransformVector</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies a vector with a transformation matrix (v=m*v). See also the other <a href="apiFunctionListCategory.htm#coordinatesAndTransformations">matrix/transformation functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTransformVector(const simFloat* matrix,simFloat* vect)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: the transformation matrix</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>vect</strong>: the vector to be transformed (a pointer to 3 values (the last element of the homogeneous coordinates is not required (1)))<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>See <a href="#simMultiplyVector">sim.multiplyVector</a></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTubeClose" id="simTubeClose"></a>simTubeClose / sim.tubeClose </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes a communication tube previously opened with <a href="#simTubeOpen">sim.tubeOpen</a>. Data written with <a href="#simTubeWrite">sim.tubeWrite</a> and that hasn't been read yet on the other side of the tube will persist.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeClose(simInt tubeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function. Once a tube was closed on one side, it is again ready for a new connection.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.tubeClose(number tubeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTubeOpen" id="simTubeOpen"></a>simTubeOpen / sim.tubeOpen </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a tube for communication within V-REP. A tube is similar to a bidirectional communication pipe. Messages written on one side can be read on the other side in the same order as they were written. Tubes opened via a script will automatically close upon simulation end. A scene switch will close all communication tubes and tube handles will not be valid anymore. See also <a href="#simTubeClose">sim.tubeClose</a>, <a href="#simTubeWrite">sim.tubeWrite</a>, <a href="#simTubeRead">sim.tubeRead</a>, <a href="#simTubeStatus">sim.tubeStatus</a>, <a href="#simSendData">sim.sendData</a> and <a href="#simReceiveData">sim.receiveData</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeOpen(simInt dataHeader,const simChar* dataName,simInt readBufferSize,simBool notUsedButKeepFalse)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataName<br>
</div>
<div><strong>readBufferSize</strong>: the number of data packets that can be stored in the input buffer of this side of the tube<br>
</div>
<div><strong>notUsedButKeepFalse</strong>: not used. Keep to false.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the tube handle.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number tubeHandle=sim.tubeOpen(number dataHeader,string dataName,number readBufferSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTubeRead" id="simTubeRead"></a>simTubeRead / sim.tubeRead </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Receives a data packet from a communication tube previously opened with <a href="#simTubeOpen">sim.tubeOpen</a>. The tube needs to be connected (see <a href="#simTubeStatus">sim.tubeStatus</a>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simTubeRead(simInt tubeHandle,simInt* dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>dataLength</strong>: size of the returned data packet</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to a data packet, or NULL if nothing could be read. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=sim.tubeRead(number tubeHandle,boolean blockingOperation=false)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>tubeHandle</strong>: Same as C-function</div>
<div><strong>blockingOperation</strong>: if true, then the call will block until something can be read or until an error occurred. The script should be threaded in that case. Default value is false.<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: string containing the received data, or nil in case of an error or if no data is present. If received data is packed, see also the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTubeStatus" id="simTubeStatus"></a>simTubeStatus / sim.tubeStatus </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks the status of a communication tube previously opened with <a href="#simTubeOpen">sim.tubeOpen</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeStatus(simInt tubeHandle,simInt* readPacketsCount,simInt* writePacketsCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>readPacketsCount</strong>: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULL</div>
<div><strong>writePacketsCount</strong>: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if the tube is not connected, 1 if the tube is connected<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number status,number readPacketsCount,number writePacketsCount=sim.tubeStatus(number tubeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>status</strong>: nil if operation was not successful, otherwise 0 if the tube is not connected, 1 if the tube is connected</div>
<div><strong>readPacketsCount</strong>: nil if operation was not successful, otherwise the number of packets waiting to be read</div>
<div><strong>writePacketsCount</strong>: nil if operation was not successful, otherwise the number of packets waiting to be read on the other side of the tube</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simTubeWrite" id="simTubeWrite"></a>simTubeWrite / sim.tubeWrite </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends a data packet into a communication tube previously opened with <a href="#simTubeOpen">sim.tubeOpen</a>. The tube needs to be connected (see <a href="#simTubeStatus">sim.tubeStatus</a>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeWrite(simInt tubeHandle,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>data</strong>: pointer to a data packet. <a href="#simTubeWrite">simTubeWrite</a> will copy that packet so that it can directly be released</div>
<div><strong>dataLength</strong>: size of the data packet</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.tubeWrite(number tubeHandle,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>tubeHandle</strong>: Same as C-function</div>
<div><strong>data</strong>: string representing a data packet (each character can have values between 0 and 255). See also the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnfoldStackTable" id="simUnfoldStackTable"></a>simUnfoldStackTable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Extracts all key-value pairs from the table at the top of the stack, and removes the table. See also <a href="#simGetStackSize">simGetStackSize</a> and the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simUnfoldStackTable(simInt stackHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUngroupShape" id="simUngroupShape"></a>simUngroupShape / sim.ungroupShape </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Ungroups a compound shape into several <a href="shapes.htm">simple shapes</a>. See also <a href="#simGroupShapes">sim.groupShapes</a>, <a href="#simConvexDecompose">sim.convexDecompose</a>, <a href="#simGetQHull">sim.getQHull</a> and <a href="#simGetDecimatedMesh">sim.getDecimatedMesh</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt* simUngroupShape(simInt shapeHandle,simInt* shapeCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: the handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped.</div>
<div><strong>shapeCount</strong> (output): the size of the returned buffer.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to an array holding the handles of the resulting shapes, or NULL in case of an error. The user is in charge of releasing the array buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table simpleShapeHandles=sim.ungroupShape(number shapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function</div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnloadModule" id="simUnloadModule"></a>simUnloadModule / sim.unloadModule </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unloads a V-REP plugin. This should usually be done just before ending the simulator. Alternatively, you can also unload a plugin that was dynamically loaded at any time. This can however lead to a crash if the plugin registered custom Lua functions via simRegisterCustomLuaFunction (deprecated) without specifying a function name as <em>functionName@pluginName</em>. See also <a href="#simSendModuleMessage">simSendModuleMessage</a> and <a href="#simLoadModule">sim.loadModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simUnloadModule(simInt pluginhandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><span class="apiTableRightCSyn"><strong>pluginhandle</strong></span>: handle of the plugin</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 if plugin was not unloaded (e.g. because it was not loaded, or because it was loaded more than once). Different from 0 if the plugin was successfully unloaded</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.unloadModule(number pluginHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function</div>
</td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnlockResources" id="simUnlockResources"></a>simUnlockResources</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unlocks resources previously locked via <a href="#simLockResources">simLockResources</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simUnlockResources(simInt lockHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>lockHandle</strong>: the lock handle returned by <a href="#simLockResources">simLockResources</a>.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackDoubleTable" id="simUnpackDoubleTable"></a>simUnpackDoubleTable / sim.unpackDoubleTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of double floating-point numbers. See also <a href="#simPackDoubleTable">sim.packDoubleTable</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table doubleNumbers=sim.unpackDoubleTable(string data,number startDoubleIndex=0,number doubleCount=0,number additionalByteOffset=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed floating-point numbers</div>
<div><strong>startDoubleIndex</strong>: the zero-based index from which on data should be unpacked (from data[8*startDoubleIndex+1+additionalByteOffset]). Can be omitted in which case 0 is used</div>
<div><strong>doubleCount</strong>: the amount of doubles that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of doubles should be unpacked from the indicated startIndex)</div>
<div><strong>additionalByteOffset</strong>: a byte offset that will be added before reading the doubles. Can be omitted, in which case 0 is used.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>doubleNumbers</strong>: a table containing unpacked double floating-point numbers if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackFloatTable" id="simUnpackFloatTable"></a>simUnpackFloatTable / sim.unpackFloatTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of floating-point numbers. See also <a href="#simPackFloatTable">sim.packFloatTable</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table floatingNumbers=sim.unpackFloatTable(string data,number startFloatIndex=0,number floatCount=0,number additionalByteOffset=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed floating-point numbers</div>
<div><strong>startFloatIndex</strong>: the zero-based index from which on data should be unpacked (from data[4*startFloatIndex+1+additionalByteOffset]). Can be omitted in which case 0 is used</div>
<div><strong>floatCount</strong>: the amount of floats that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of floats should be unpacked from the indicated startFloatIndex)</div>
<div><strong>additionalByteOffset</strong>: a byte offset that will be added before reading the floats. Can be omitted, in which case 0 is used.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>floatingNumbers</strong>: a table containing unpacked floating-point numbers if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackInt32Table" id="simUnpackInt32Table"></a>simUnpackInt32Table / sim.unpackInt32Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of int32 numbers. See also <a href="#simPackInt32Table">sim.packInt32Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table int32Numbers=sim.unpackInt32Table(string data,number startInt32Index=0,number int32Count=0,number additionalByteOffset=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed int32 numbers</div>
<div><strong>startInt32Index</strong>: the zero-based index from which on data should be unpacked (from data[4*startInt32Index+1+additionalByteOffset]). Can be omitted in which case 0 is used</div>
<div><strong>int32Count</strong>: the amount of int32s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of int32s should be unpacked from the indicated startInt32Index)</div>
<div><strong>additionalByteOffset</strong>: a byte offset that will be added before reading the int32s. Can be omitted, in which case 0 is used.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>int32Numbers</strong>: a table containing unpacked int32 numbers if operation was successful, nil otherwise</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackTable" id="simUnpackTable"></a>simUnpackTable / sim.unpackTable </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a buffer into a table. See also <a href="#simPackTable">sim.packTable</a>, the <a href="apiFunctionListCategory.htm#stacks">other stack functions</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simUnpackTable(simInt stackHandle,const simChar* buffer,simInt bufferSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>stackHandle</strong>: a stack handle obtained with <a href="#simCreateStack">simCreateStack</a>. The unpacked table will be pushed onto the stack.</div>
<div><strong>buffer</strong>: the packed table (buffer).</div>
<div><strong>bufferSize</strong>: the size of the buffer.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table aTable=sim.unpackTable(string buffer)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>buffer</strong>: a string buffer.</div> 
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>aTable</strong>: a script table.</div>
</td>
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackUInt16Table" id="simUnpackUInt16Table"></a>simUnpackUInt16Table / sim.unpackUInt16Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of uint16 numbers. See also <a href="#simPackUInt16Table">sim.packUInt16Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table uint16Numbers=sim.unpackUInt16Table(string data,number starUint16Index=0,number uint16Count=0,number additionalByteOffset)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed uint16 numbers</div>
<div><strong>starUint16Index</strong>: the zero-based index from which on data should be unpacked (from data[2*starUint16Index+1+additionalByteOffset]). Can be omitted in which case 0 is used.</div>
<div><strong>uint16Count</strong>: the amount of uint16s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint16s should be unpacked from the indicated starUint16Index).</div>
<div><strong>additionalByteOffset</strong>: a byte offset that will be added before reading the uint16s. Can be omitted, in which case 0 is used.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>uint16Numbers</strong>: a table containing unpacked uint16 numbers if operation was successful, nil otherwise</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackUInt32Table" id="simUnpackUInt32Table"></a>simUnpackUInt32Table / sim.unpackUInt32Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of uint32 numbers. See also <a href="#simPackUInt32Table">sim.packUInt32Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table uint32Numbers=sim.unpackUInt32Table(string data,number startUint32Index=0,number uint32Count=0,number additionalByteOffset=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed uint32 numbers</div>
<div><strong>startUint32Index</strong>: the zero-based index from which on data should be unpacked (from data[4*startUint32Index+1+additionalByteOffset]). Can be omitted in which case 0 is used</div>
<div><strong>uint32Count</strong>: the amount of uint32s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint32s should be unpacked from the indicated startUint32Index)</div>
<div><strong>additionalByteOffset</strong>: a byte offset that will be added before reading the uint32s. Can be omitted, in which case 0 is used.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>integerNumbers</strong>: a table containing unpacked uint32 numbers if operation was successful, nil otherwise</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simUnpackUInt8Table" id="simUnpackUInt8Table"></a>simUnpackUInt8Table / sim.unpackUInt8Table </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of uint8 numbers. See also <a href="#simPackUInt8Table">sim.packUInt8Table</a> and the <a href="apiFunctionListCategory.htm#packing">other packing/unpacking functions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table uint8Numbers=sim.unpackUInt8Table(string data,number startUint8Index=0,number uint8Count=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains uint8 numbers</div>
<div><strong>startUint8Index</strong>: the zero-based index from which on data should be unpacked (from data[startUint8Index]). Can be omitted in which case 0 is used.
</div>
<div><strong>uint8Count</strong>: the amount of uint8s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint8s should be unpacked from the indicated startUint8Index).
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>uint8Numbers</strong>: a table containing uint8 numbers if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simWait" id="simWait"></a>simWait / sim.wait </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Waits for a certain amount of time. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simWaitForSignal">sim.waitForSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=sim.wait(number deltaTime,Boolean simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>deltaTime</strong>: the minimum time duration to wait. If the function was called at simulation time X (or real-time X), then the function will return when simulation time&gt;=X+deltaTime (or when real-time&gt;=X+deltaTime)<br>
</div>
<div><strong>simulationTime</strong>: indicates whether we want to wait in terms of simulation- or real-time. Can be omitted (is true by default)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: the &quot;wait resolution&quot; of this function is the simulation time step, and the sim.wait command may overshoot the requested waiting time. deltaTimeLeft is the negative overshoot time. If the function was called at simulation time X, and the function returned at simulation time Y, then deltaTimeLeft is deltaTime-(Y-X). In case of an error, deltaTimeLeft is nil. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is 0 if the simulationTime argument was false<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simWaitForSignal" id="simWaitForSignal"></a>simWaitForSignal / sim.waitForSignal </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Waits for a signal. Signals are cleared at simulation start. This function will first check whether an integer signal with that name is present, then if a float signal with that name is present and finally if a string signal with that name is present. The function only returns when the signal is present (defined). This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also the <a href="apiFunctionListCategory.htm#signals">other signal functions</a> and <a href="#simWait">sim.wait</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>Number/string signalValue=sim.waitForSignal(string signalName)</div>
<br>
<div>The function is equivalent to:</div>
<br>
<pre class=lightRedBoxNoMarginAndSmall>
signalValue=nil
while (signalValue==nil) do
    signalValue=sim.getIntegerSignal(signalName) or sim.getFloatSignal(signalName) or
                                                  sim.getStringSignal(signalName)
    if (signalValue==nil) then
        sim.switchThread()
    end
end</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>signalName</strong>: name of the signal</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal, or nil when the command is cancelled by stopping the simulation</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simWriteCustomDataBlock" id="simWriteCustomDataBlock"></a>simWriteCustomDataBlock / sim.writeCustomDataBlock </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds or removes custom data to be stored and saved together with an object, a script or a scene (i.e. the data will be part of the object, the script or the scene). If the tag name starts with the string &quot;@tmp&quot;, then the data will not be saved during a scene or model save operation. The data can also be saved globally for the application (for the current V-REP session). See also <a href="#simReadCustomDataBlock">sim.readCustomDataBlock</a> and the <a href="apiFunctionListCategory.htm#packing">data packing/unpacking functions</a>. If you wish to store a reference to another object, have a look at <a href="#simSetReferencedHandles">sim.setReferencedHandles</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simWriteCustomDataBlock(simInt objectHandle,const simChar* tagName,const simChar* data,simInt dataSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.</div>
<div><strong>tagName</strong>: a string that identifies the data. An empty string will remove all custom data blocks.<br>
</div>
<div><strong>data</strong>: your custom data. If NULL, the current data under the specified dataName will be removed. <br>
</div>
<div><strong>dataSize</strong>: the size of your custom data</div>
<br>
<div>The data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.writeCustomDataBlock(number objectHandle,string tagName,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.  In addition, you can specify sim.handle_self for the <strong>objectHandle</strong> argument, if your target is the current script.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>
<h3 class=subsectionBar><a name="simWriteTexture" id="simWriteTexture"></a>simWriteTexture / sim.writeTexture </h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Overwrites a specific texture (or a portion of it) with RGB data. See also <a href="#simGetTextureId">sim.getTextureId</a>, <a href="#simReadTexture">sim.readTexture</a> and <a href="#simCreateTexture">sim.createTexture</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simWriteTexture(simInt textureId,simInt options,const simChar* textureData,simInt posX,simInt posY,simInt sizeX,simInt sizeY,simFloat interpolation)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>textureId</strong>: the ID of the texture. See also <a href="#simGetTextureId">simGetTextureId</a>.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab><strong>bit0</strong> reserved. Do not set.</div>
<div class=tab><strong>bit1</strong> reserved. Do not set.</div>
<div class=tab><strong>bit2</strong> set (4)=only an elliptical/circular portion of the texture data will be written.</div>
<div><strong>textureData</strong>: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).</div>
<div><strong>posX / posY</strong>: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texture</div>
<div><strong>sizeX / sizeY</strong>: the x/y size of the RGB data. Set to 0/0 to overwrite the full texture</div>
<div><strong>interpolation</strong>: the fade or interpolation factor. 0 for no fade.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=sim.writeTexture(number textureId,number options,string textureData,number posX=0,number posY=0,number sizeX=0,number sizeY=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>
<br>
<br>

<br>
<br>
</td>
</tr>
</table> 
</div>  
  
</body>

</html>
